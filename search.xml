<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>对浏览器的理解</title>
    <url>/2021/11/09/2021/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<h1 id="浏览器的事件循环"><a href="#浏览器的事件循环" class="headerlink" title="浏览器的事件循环"></a>浏览器的事件循环</h1><p>浏览器的事件循环是一种机制，用于管理和处理异步任务，以确保 JavaScript 在单线程环境中能够处理事件、执行代码和保持响应性。</p>
<p>事件循环的基本原理如下：</p>
<ol>
<li><strong>调用栈（Call Stack）：</strong> JavaScript代码的执行是通过调用栈来处理的。当你调用一个函数，它会被推入调用栈，当函数执行完成，它就会从调用栈中弹出。</li>
<li><strong>任务队列（Task Queue）：</strong> 任务队列存放异步任务，如事件处理函数、定时器回调等。任务队列中的任务在调用栈为空时才会被执行。</li>
<li><strong>事件循环（Event Loop）：</strong> 不断地检查调用栈和任务队列。如果调用栈为空，它会从任务队列中取出一个任务推入调用栈执行。这个过程不断重复，形成事件循环。</li>
</ol>
<p>基本流程：</p>
<ul>
<li>当执行同步代码时，代码会依次推入调用栈执行。</li>
<li>当遇到异步任务时（如定时器、事件监听器、网络请求等），会将任务放入任务队列。</li>
<li>当调用栈为空时，事件循环检查任务队列是否有任务。</li>
<li>如果有任务，将任务推入调用栈执行，重复上述过程。</li>
</ul>
<p>以下是事件循环的简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconsole.log(&#x27;Start&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setTimeout callback&#x27;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Promise resolved&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;End&#x27;);</span><br></pre></td></tr></table></figure>

<p>输出的顺序是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeStart</span><br><span class="line">End</span><br><span class="line">Promise resolved</span><br><span class="line">setTimeout callback</span><br></pre></td></tr></table></figure>

<p>这是因为 <code>setTimeout</code> 回调会被放入任务队列，而 <code>Promise</code> 的回调则会在微任务队列中，微任务队列的执行优先级高于任务队列。因此，先执行微任务中的 <code>Promise</code>，然后再执行 <code>setTimeout</code> 的回调。</p>
<h1 id="settimeout为什么不一定在指定时间后调用"><a href="#settimeout为什么不一定在指定时间后调用" class="headerlink" title="settimeout为什么不一定在指定时间后调用"></a>settimeout为什么不一定在指定时间后调用</h1><p><code>setTimeout</code> 的确切执行时间并不是精确的，并且不能保证在指定的时间后立即执行。这是因为JavaScript是单线程的，它在事件循环中处理任务队列，而不是通过多线程实现的。</p>
<p><code>setTimeout</code> 的行为受到事件循环和浏览器的实现方式的影响。具体来说，<code>setTimeout</code> 的执行时间取决于下面的几个因素：</p>
<ol>
<li><strong>最小延迟时间：</strong> 浏览器通常有一个最小的定时器延迟，即使你将定时器设置为0，它也可能会有一定的延迟，通常是4毫秒。这是因为浏览器会将定时器任务添加到任务队列，并在下一个事件循环迭代中执行。</li>
<li><strong>事件循环阶段：</strong> 如果在执行 <code>setTimeout</code> 的时候，事件循环正处于某个特定的阶段，那么定时器的回调会等到下一个合适的事件循环阶段再执行。这可能导致定时器的执行时间延迟。</li>
<li><strong>页面是否被隐藏：</strong> 如果页面被隐藏（例如，用户切换到其他标签或最小化浏览器），某些浏览器可能会将定时器的执行时间延迟，以减少对系统资源的使用。</li>
</ol>
<p>总体来说，<code>setTimeout</code> 并不是实现实时精确计时的最佳工具。如果需要更精确的计时，可以考虑使用 <code>requestAnimationFrame</code> 或 <code>Web Workers</code>，这些机制提供了更可靠的定时和并行处理能力。</p>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>监听器 变量引用 闭包  循环引用</p>
<p>垃圾回收机制：标记清除法 引用计数法有问题（循环引用）</p>
<h1 id="强制缓存与协商缓存"><a href="#强制缓存与协商缓存" class="headerlink" title="强制缓存与协商缓存"></a>强制缓存与协商缓存</h1><p>HTTP缓存是一种优化性能的重要机制，它可以减少资源的加载时间并减轻服务器的负担。缓存主要分为强制缓存和协商缓存两种策略。</p>
<h3 id="强制缓存："><a href="#强制缓存：" class="headerlink" title="强制缓存："></a>强制缓存：</h3><p>强制缓存是通过<code>Cache-Control</code>和<code>Expires</code>两个HTTP头来实现的。它告诉浏览器在特定时间内不需要再次请求相同的资源，而是直接从本地缓存中获取。常用的设置有：</p>
<ul>
<li><strong>Cache-Control：</strong> 使用<code>max-age</code>来设置资源在本地缓存中的最长时间（秒），例如 <code>Cache-Control: max-age=3600</code> 表示缓存有效期为1小时。</li>
<li><strong>Expires：</strong> 是一个过时的设置，它指定了缓存资源的到期时间。服务器返回的时间是绝对时间，由于存在时钟不同步等问题，因此<code>Cache-Control</code>的使用更为推荐。</li>
</ul>
<p>如果资源在强制缓存期间被请求，浏览器会直接从缓存中获取资源，而不发起实际的请求。</p>
<h3 id="协商缓存："><a href="#协商缓存：" class="headerlink" title="协商缓存："></a>协商缓存：</h3><p>协商缓存依赖于服务器与浏览器之间的“协商”，即服务器根据请求的条件来判断是否返回实际的资源或告诉浏览器直接使用缓存。协商缓存的实现主要依赖于以下两个HTTP头：</p>
<ul>
<li><strong>Last-Modified &#x2F; If-Modified-Since：</strong> 服务器在响应头中返回资源的最后修改时间，下次请求时浏览器通过<code>If-Modified-Since</code>头将上次的最后修改时间发送给服务器。如果资源在这之后没有被修改，服务器返回304 Not Modified，浏览器直接使用缓存。</li>
<li><strong>ETag &#x2F; If-None-Match：</strong> 服务器在响应头中返回资源的唯一标识，称为ETag。下次请求时浏览器通过<code>If-None-Match</code>头将上次的ETag发送给服务器。如果资源的ETag匹配，服务器返回304 Not Modified，浏览器直接使用缓存。</li>
</ul>
<p>协商缓存更加灵活，不仅可以判断资源是否修改，还可以使用更精确的标识来验证。如果同时存在<code>Last-Modified</code>和<code>ETag</code>，浏览器会优先使用<code>ETag</code>。</p>
<h1 id="cookie-sessionStorage-localStorage-的区别"><a href="#cookie-sessionStorage-localStorage-的区别" class="headerlink" title="cookie&#x2F;sessionStorage&#x2F;localStorage 的区别"></a>cookie&#x2F;sessionStorage&#x2F;localStorage 的区别</h1><p>参考答案:<br>cookie sessionStorage、localStorage都是保存本地数据的方式<br>其中，cookie 兼容性较好，所有浏览器均支持。</p>
<p>浏览器针对 cookie 会有一些默认行为，比如当响应头中出现 set-cookie 字段时，浏览器会自动保存 cookie 的值;</p>
<p>再比如，浏览器发送请求时，会附带匹配的 cookie 到请求头中。这些默认行为，使得cookie 长期以来担任着维持登录状态的责任。与此同时，也正是因为浏览器的默认行为给了恶意攻击者可乘之机，CSRF 攻击就是一个典型的利用 cookie 的攻击方式。虽然cookie 不断的改进，但前端仍然需要另一种更加安全的保存数据的方式<br>HTML5 新增了 sessionStorage 和 localStorage，前者用于保存会话级别的数据后者用于更持久的保存数据。浏览器针对它们没有任何默认行为，这样一来，就把保存数据读取数据的工作交给了前端开发者，这就让恶意攻击者难以针对登录状态进行攻击。</p>
<p>cookie 的大小是有限制的，一般浏览器会限制同一个域下的 cookie 总量为 4M，</p>
<p>而sessionStorage 和 localStorage 则没有限制cookie 会与 domain、path 关联，而 sessionStorage 和 localStorage 只与domain 关联</p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240507202004397.png"  alt="image-20240507202004397"></p>
<h1 id="cookie-sessionStorage-localStorage-的区别-1"><a href="#cookie-sessionStorage-localStorage-的区别-1" class="headerlink" title="cookie&#x2F;sessionStorage&#x2F;localStorage 的区别"></a>cookie&#x2F;sessionStorage&#x2F;localStorage 的区别</h1><p>Cookie、SessionStorage 和 LocalStorage 是用于在客户端存储数据的三种机制，它们之间有以下区别：</p>
<ol>
<li><strong>存储容量</strong>：<ul>
<li>Cookie：每个 Cookie 的大小一般被限制在 4KB 左右。</li>
<li>SessionStorage：通常可以存储 5MB 到 10MB 的数据。</li>
<li>LocalStorage：通常可以存储 5MB 到 10MB 的数据。</li>
</ul>
</li>
<li><strong>数据存储位置</strong>：<ul>
<li>Cookie：存储在客户端的浏览器中，并且会随着每次 HTTP 请求被发送到服务器端。</li>
<li>SessionStorage：存储在客户端的浏览器中，但数据仅在当前会话（当前页面或者标签页）有效，在关闭页面或者标签页时会被清除。</li>
<li>LocalStorage：存储在客户端的浏览器中，并且数据在不同的会话之间是共享的，除非手动清除。</li>
</ul>
</li>
<li><strong>数据生命周期</strong>：<ul>
<li>Cookie：可以设置过期时间，可以在设置的过期时间之前一直保存在客户端。</li>
<li>SessionStorage：仅在当前会话中有效，关闭页面或者标签页时会被清除。</li>
<li>LocalStorage：永久有效，除非被手动清除。</li>
</ul>
</li>
<li><strong>数据与服务器的通信</strong>：<ul>
<li>Cookie：会随着每次 HTTP 请求被发送到服务器端，因此可以用于在客户端和服务器之间传递数据。</li>
<li>SessionStorage 和 LocalStorage：数据仅在客户端存储，不会随着 HTTP 请求发送到服务器端。</li>
</ul>
</li>
<li><strong>访问权限</strong>：<ul>
<li>Cookie、SessionStorage 和 LocalStorage 的访问权限都受到同源策略的限制，即只能访问同源（协议、域名、端口号均相同）页面的存储数据。</li>
</ul>
</li>
</ol>
<h1 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h1><p>解析html（生成dom树，cssom树）–&gt; 样式计算（合并dom,cssom树）–&gt; 布局（布局树）–&gt; 分层（层次树）–&gt; 生成绘制指令集（未执行, 渲染主线程工作结束）–&gt; 分块（合成线程）–&gt; 光栅化 gpu将每个块变成位图 就是确认每一个像素点的 <em>rgb</em> 信息 –&gt;  绘制 （合成线程中执行）</p>
<p>为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 <em>HTML</em> 中的外部 <em>CSS</em> 文件和外部的 <em>JS</em> 文件。</p>
<p>如果主线程解析到 <em>link</em> 位置，此时外部的 <em>CSS</em> 文件还没有下载解析好，主线程不会等待，继续解析后续的 <em>HTML</em>。这是因为<strong>下载和解析 <em>CSS</em> 的工作是在预解析线程中进行的</strong>。这就是 <em>CSS</em> 不会阻塞 <em>HTML</em> 解析的根本原因。</p>
<p>这是<strong>因为 <em>JS</em> 代码的执行过程可能会修改当前的 <em>DOM</em> 树</strong>，所以 <em>DOM</em> 树的生成必须暂停。这就是 <em>JS</em> 会阻塞 <em>HTML</em> 解析的根本原因</p>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>算法总结</title>
    <url>/2022/11/09/2022/algorithm/</url>
    <content><![CDATA[<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><p>快速排序的关键在于分解步骤中如何选择基准元素以及如何进行分区。通常，可以选择数组中的一个元素作为基准，然后通过交换元素的方式将小于基准的元素移到基准的左边，大于基准的元素移到基准的右边。</p>
<p>由于快速排序使用了递归，它是一种高效的排序算法，<strong>平均时间复杂度为O(n log n)<strong>。然而，</strong>最坏情况下的时间复杂度为O(n^2)<strong>，这发生在每次选择的基准元素都是当前数组中的最大或最小值的情况下。为了避免最坏情况，可以</strong>采用随机选择基准元素</strong>的策略。</p>
]]></content>
      <tags>
        <tag>Algo</tag>
      </tags>
  </entry>
  <entry>
    <title>axios的使用</title>
    <url>/2023/11/09/2023/axios/</url>
    <content><![CDATA[<h1 id="Ajax-和-Axios的区别"><a href="#Ajax-和-Axios的区别" class="headerlink" title="Ajax 和 Axios的区别"></a>Ajax 和 Axios的区别</h1><p>Ajax 和 Axios 都用于发出异步的 HTTP 请求，但它们具有不同的基本机制。</p>
<ol>
<li>Ajax 是一组 Web 开发技术，利用客户端的许多 Web 技术来创建异步 Web 应用程序。</li>
<li>Ajax 是一种传统的 JavaScript 异步请求方法，通常使用 <code>XMLHttpRequest</code> 对象或 <code>fetch</code> API。</li>
<li>Ajax 是一组利用各种 Web 技术的 Web 开发技术</li>
</ol>
<hr>
<ol>
<li>Axios 是一个基于 Promise 的 HTTP 客户端，用于在浏览器和 Node.js 中轻松发送异步 HTTP 请求到 REST 端点并执行 CRUD .</li>
<li>Axios 则是一个更现代、用户友好的替代方案，它基于 Promise，并提供了比传统的 Ajax 方法更简单、更清晰的语法来发出 HTTP 请求。</li>
<li>Axios 是一个特定的 JavaScript 库，提供了一种简单的方式来发出异步的 HTTP 请求</li>
</ol>
]]></content>
      <tags>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>md使用技巧</title>
    <url>/2022/11/09/2022/md/</url>
    <content><![CDATA[<h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Typora是一款功能全面、简洁高效，而且又非常优雅的Markdown编辑器。它把源码编辑和效果预览合二为一，在输入标记之后随即生成预览效果，提供了“所见即所得”的Markdown写作体验。</p>
<p>Typora是目前最受欢迎的Markdown编辑器之一。它的主要特性如下。<br>1）实时预览：传统的Markdown编辑器都有两个窗口，左边是源码，右边是渲染后的效果。Typora独辟蹊径，把源码编辑和效果预览合二为一，实现了真正的所见即所得。<br>2）扩展语法：Typora不光支持GFM，还扩展了数学公式、流程图等功能。<br>3）快捷操作：Typora对几乎所有的Markdown标记都提供了快捷操作方式，使用起来非常高效。<br>4）界面漂亮：默认支持6种主题，可自定义，好看又好用。<br>5）文件转换：支持多种文件格式通过导入&#x2F;导出功能跟.md格式相互转换。<br>6）支持中文：支持中文，可以帮助大家更好地理解各项功能。<br>7）视图模式：支持大纲和文档列表视图，方便在不同段落和不同文件之间进行切换。<br>8）跨平台：支持macOS、Windows和Linux系统。<br>9）目前免费：这么好用的编辑器竟然是免费的。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>1.下载安装</strong></p>
<p>下载地址：<a class="link"   href="https://typora.io/#download%E3%80%82" >https://typora.io/#download。<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>2.设置语言</strong></p>
<p>在默认情况下，Typora会使用操作系统的语言，如果想要自定义语言，可以在Typora编辑器上执行如下操作：【偏好设置】→【通用】→【语言】，选择语言后，重启Typora即可生效。</p>
<p><strong>3.其他偏好设置推荐</strong></p>
<p>【文件】→【偏好设置】→【外观】→【侧边栏】勾选<code>侧边栏的大纲视图允许折叠和展开</code></p>
<p>【文件】→【偏好设置】→【编辑器】→【默认换行符】选择<code>LF</code></p>
<p>【文件】→【偏好设置】→【图像】→【插入图片时】选择<code>复制图片到./$&#123;filename&#125;.assets 文件夹</code>和勾选<code>对本地位置的图片应用上述规则</code>和勾选<code>优先使用相对路径</code></p>
<p>【文件】→【偏好设置】→【Markdown】→【Markdown扩展语法】全部勾选；【空格与换行】勾选<code>显示&lt;br/&gt;</code>和选择<code>忽略连续的空格与单个换行</code></p>
<p><strong>4.主题</strong></p>
<p>Typora提供了5款漂亮的主题供大家选择，每一个都很漂亮。可通过菜单栏上的【主题】进行切换，默认是Github主题。主题也可以根据自己喜欢进行自定义。</p>
<p>Typora实际上也是一个浏览器，每一个主题就是一个css文件，如果想自定义主题，可直接修改该css文件。</p>
<p>【文件】→【偏好设置】→【外观】→【主题】打开主题文件夹就能看到所有主题对应的css文件。</p>
<p>比如要修改Github主题，该主题对应的css文件就是github.css，不建议直接修改原来的css文件，而是创建名为github.user.css进行编写自定义样式，该样式文件Typora也会自动加载。</p>
<p>github.user.css（）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*自定义样式*/</span></span><br><span class="line"><span class="comment">/*修改了引用标签的样式*/</span></span><br><span class="line"><span class="selector-tag">blockquote</span>&#123;<span class="attribute">border-left</span>: <span class="number">4px</span> solid <span class="number">#62ca38</span><span class="meta">!important</span>;<span class="attribute">background</span>:<span class="number">#f8f8f8</span><span class="meta">!important</span>;<span class="attribute">padding</span>:<span class="number">10px</span><span class="meta">!important</span>;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>5.空格与换行</strong></p>
<p>官方说明：<a class="link"   href="https://support.typora.io/Line-Break/" >https://support.typora.io/Line-Break/<i class="fas fa-external-link-alt"></i></a></p>
<p>在Markdown中，换行符非常令人困惑，Typora的官方建议是：</p>
<ul>
<li>使用Typora的默认设置。</li>
<li>用Typora的混合视图编写。</li>
<li>按下<code>Enter</code>键插入新的段落，并避免插入新行。</li>
<li>如果您确实需要一个单独的换行符，请使用以下语法：<code>&lt;br/&gt;</code>。</li>
</ul>
<p><strong>空格</strong></p>
<p>连续空格类似于单行换行符，大多数Markdown引擎都会忽略它们。</p>
<p>默认情况下，Typora将<strong>在编辑视图中保留连续的空格，并在打印或导出时将其忽略。</strong>您可以在首选项面板中更改此选项。</p>
<p>如果您确实想插入其他Markdpwn引擎支持的连续空格，则可以</p>
<ul>
<li>转义空格，<code>\</code>在每个空格之前输入</li>
<li>使用HTML实体<code> &amp;nbsp;</code>。</li>
</ul>
<p><strong>换行</strong></p>
<p>Markdown提供了插入单个强行换行符的方法：</p>
<ul>
<li>插入两个空格和一个换行符。</li>
<li><code>&lt;br/&gt;</code>直接插入HTML标签。</li>
</ul>
<p>几乎所有Markdown引擎都会将其解析为输出中的强行换行。</p>
<p><strong>段落</strong></p>
<p>在Markdown中，<strong>两个换行符</strong>表示创建一个新段落，在Typora中，当您<code>Enter</code>按键时，将创建一个新段落，并且如果切换到源代码模式，则会插入两个换行符。</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>没有macOS系统的电脑，所以暂未收集。</p>
<p><strong>段落</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>操作步骤</th>
<th>Windows</th>
<th>macOS</th>
</tr>
</thead>
<tbody><tr>
<td>一级标题</td>
<td>段落→一级标题</td>
<td>Ctrl+1</td>
<td>command+1</td>
</tr>
<tr>
<td>二级标题</td>
<td>段落→二级标题</td>
<td>Ctrl+2</td>
<td>command+2</td>
</tr>
<tr>
<td>三级标题</td>
<td>段落→三级标题</td>
<td>Ctrl+3</td>
<td>command+3</td>
</tr>
<tr>
<td>四级标题</td>
<td>段落→四级标题</td>
<td>Ctrl+4</td>
<td>command+4</td>
</tr>
<tr>
<td>五级标题</td>
<td>段落→五级标题</td>
<td>Ctrl+5</td>
<td>command+5</td>
</tr>
<tr>
<td>六级标题</td>
<td>段落→六级标题</td>
<td>Ctrl+6</td>
<td>command+6</td>
</tr>
<tr>
<td>段落</td>
<td>段落→段落</td>
<td>Ctrl+0</td>
<td>command+0</td>
</tr>
<tr>
<td>提升标题级别</td>
<td>段落→提升标题级别</td>
<td>Ctrl+&#x3D;</td>
<td>command+&#x3D;</td>
</tr>
<tr>
<td>降低标题级别</td>
<td>段落→降低标题级别</td>
<td>Ctrl+-</td>
<td>command+-</td>
</tr>
<tr>
<td>插入表格</td>
<td>段落→表格→插入表格</td>
<td>Ctrl+T</td>
<td></td>
</tr>
<tr>
<td>下方插入行</td>
<td>段落→表格→下方插入行</td>
<td>Ctrl+Enter</td>
<td></td>
</tr>
<tr>
<td>删除行</td>
<td>段落→表格→删除行</td>
<td>Ctrl+Shift+退格</td>
<td></td>
</tr>
<tr>
<td>代码块</td>
<td>段落→代码块</td>
<td>Ctrl+Shift+K</td>
<td></td>
</tr>
<tr>
<td>公式块</td>
<td>段落→公式块</td>
<td>Ctrl+Shift+M</td>
<td></td>
</tr>
<tr>
<td>有序列表</td>
<td>段落→有序列表</td>
<td>Ctrl+Shift+[</td>
<td></td>
</tr>
<tr>
<td>无序列表</td>
<td>段落→无序列表</td>
<td>Ctrl+Shift+]</td>
<td></td>
</tr>
<tr>
<td>增加缩进</td>
<td>段落→缩进→增加缩进</td>
<td>Ctrl+]</td>
<td></td>
</tr>
<tr>
<td>减少缩进</td>
<td>段落→缩进→减少缩进</td>
<td>Ctrl+[</td>
<td></td>
</tr>
</tbody></table>
<p><strong>格式</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>操作步骤</th>
<th>Windows</th>
<th>macOS</th>
</tr>
</thead>
<tbody><tr>
<td>加粗</td>
<td>格式→加粗</td>
<td>Ctrl+B</td>
<td></td>
</tr>
<tr>
<td>斜体</td>
<td>格式→斜体</td>
<td>Ctrl+I</td>
<td></td>
</tr>
<tr>
<td>下划线</td>
<td>格式→下划线</td>
<td>Ctrl+U</td>
<td></td>
</tr>
<tr>
<td>删除线</td>
<td>格式→删除线</td>
<td>Ctrl+Shift+5</td>
<td></td>
</tr>
<tr>
<td>代码</td>
<td>格式→代码</td>
<td>Ctrl+Shift+&#96;</td>
<td></td>
</tr>
<tr>
<td>超链接</td>
<td>格式→超链接</td>
<td>Ctrl+K</td>
<td></td>
</tr>
<tr>
<td>清除格式</td>
<td>格式→清除格式</td>
<td>Ctrl+\</td>
<td></td>
</tr>
</tbody></table>
<p><strong>视图</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>操作步骤</th>
<th>Windows</th>
<th>macOS</th>
</tr>
</thead>
<tbody><tr>
<td>显示&#x2F;隐藏侧边栏</td>
<td>视图→显示&#x2F;隐藏侧边栏</td>
<td>Ctrl+Shift+L</td>
<td></td>
</tr>
<tr>
<td>查找&#x2F;替换</td>
<td></td>
<td>Ctrl+F</td>
<td></td>
</tr>
<tr>
<td>源代码模式</td>
<td>视图→源代码模式</td>
<td>Ctrl+&#x2F;</td>
<td></td>
</tr>
<tr>
<td>实际大小</td>
<td>视图→实际大小</td>
<td>Ctrl+Shift+9</td>
<td></td>
</tr>
<tr>
<td>放大</td>
<td>视图→放大</td>
<td>Ctrl+Shift+&#x3D;</td>
<td></td>
</tr>
<tr>
<td>缩放</td>
<td>视图→缩放</td>
<td>Ctrl+Shift+-</td>
<td></td>
</tr>
</tbody></table>
<p>以下是Markdown语法教程</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>据 GitHub Flavored Markdown（GFM）官方文档介绍，Markdown是由约翰·格鲁伯（John Gruber）在亚伦·斯沃茨（Aaron Swartz）的帮助下开发，并在2004年发布的标记语言。<br>其设计灵感主要来源于纯文本电子邮件的格式，目标是让人们能够使用易读、易写的纯文本格式编写文档，而且这些文档可以转换为HTML（Hyper Text Markup Language，超文本标记语言）文档。<br>简单点说，Markdown就是由一些简单的符号（如*&#x2F;-&gt; [] （）#）组成的用于排版的标记语言，其最重要的特点就是可读性强。</p>
<p>目前最流行的扩展语法是GitHub Flavored Markdown，简称GFM，毕竟GitHub是全球最大的程序员网站。</p>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>标题支持使用两种标记：<strong>底线（-&#x2F;&#x3D;）</strong>和<strong>左侧#</strong></p>
<p>底线（-&#x2F;&#x3D;）方式（<strong>不推荐</strong>）：<br>语法说明如下。<br>1）底线是&#x3D;表示一级标题。<br>2）底线是-表示二级标题。<br>3）底线符号的数量至少2个。<br>4）这种语法只支持这两级标题。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="section">一级标题</span></span><br><span class="line"><span class="section">=========</span></span><br><span class="line"></span><br><span class="line"><span class="section">二级标题</span></span><br><span class="line"><span class="section">---------</span></span><br></pre></td></tr></table></figure>



<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>#方式（<strong>推荐</strong>）<br>语法说明如下。<br>1）在行首插入#可标记出标题。<br>2）#的个数表示了标题的等级。<br>3）建议在#后加一个空格。<br>4）Markdown中最多只支持前六级标题。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br><span class="line"><span class="section">####### 七级标题（不支持）</span></span><br></pre></td></tr></table></figure>

<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>####### 七级标题（不支持）</p>
<h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>1）<strong>段落内换行</strong>，在结尾使用两个及以上空格加回车。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">我就是一段普通的文字。</span><br><span class="line"></span><br><span class="line">这段文字需要段内换行，这后面是两个空格  </span><br><span class="line">这一句话是跟上面属于同一段落。</span><br><span class="line"></span><br><span class="line">这段文字需要段内换行，这后面是html的换行标签<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span>这一句话是跟上面属于同一段落。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>我就是一段普通的文字。</p>
<p>这段文字需要段内换行，这后面是两个空格<br>这一句话是跟上面属于同一段落。</p>
<p>这段文字需要段内换行，这后面是html的换行标签<br/>这一句话是跟上面属于同一段落。</p>
<p>2）<strong>重新开始一个段落</strong>是段落后面使用一个空行来表示。</p>
<p><strong>注意：Typora默认是回车就会新起一个段落。</strong></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">我就是一段普通的文字。</span><br><span class="line"></span><br><span class="line">我也是一段普通的文字。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>我就是一段普通的文字。</p>
<p>我也是一段普通的文字。</p>
<h1 id="粗体斜体删除线"><a href="#粗体斜体删除线" class="headerlink" title="粗体斜体删除线"></a>粗体斜体删除线</h1><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">粗体由两个<span class="emphasis">*或两个_包裹，斜体由1个*</span>或1个<span class="emphasis">_包裹。</span></span><br><span class="line"><span class="emphasis">建议粗体使用2个*包裹，斜体使用1个*包裹，因为*比较常见，而且比_</span>可读性更强。</span><br><span class="line">删除线由两个~包裹。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>语法</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>**粗体**</code></td>
<td><strong>粗体</strong></td>
</tr>
<tr>
<td><code>*斜体*</code></td>
<td><em>斜体</em></td>
</tr>
<tr>
<td><code>~~删除线~~</code></td>
<td><del>删除线</del></td>
</tr>
<tr>
<td><code>***斜粗体***</code></td>
<td><em><strong>斜粗体</strong></em></td>
</tr>
<tr>
<td><code>**~~粗体删除线~~**</code></td>
<td><strong><del>粗体删除线</del></strong></td>
</tr>
<tr>
<td><code>*~~斜体删除线~~*</code></td>
<td><em><del>斜体删除线</del></em></td>
</tr>
<tr>
<td><code>***~~粗体斜体删除线~~***</code></td>
<td><em><strong><del>粗体斜体删除线</del></strong></em></td>
</tr>
</tbody></table>
<h1 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h1><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><u>下划线</u></p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&lt;!--注释--&gt;</span><br></pre></td></tr></table></figure>

<!--注释-->



<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>分隔线由3个以上的*&#x2F;-&#x2F;_来标记。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">线上面文字</span><br><span class="line"></span><br><span class="line"><span class="strong">***</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">线上面文字</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">---</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">线上面文字</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">___</span></span><br><span class="line"><span class="strong"></span></span><br></pre></td></tr></table></figure>

<p>语法说明如下。<br>1）分隔线须使用至少3个以上的*&#x2F;-&#x2F;_来标记。<br>2）行内不能有其他的字符。<br>3）可以在标记符中间加上空格。<br>4）上下最好都留一个空行。</p>
<p>线上面文字</p>
<hr>
<p>线上面文字</p>
<hr>
<p>线上面文字</p>
<hr>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p><strong>GFM不支持</strong></p>
<p>在需要添加注脚的文字后加上脚注名字<code>[^脚注名字]</code>,称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p>
<p>脚注与脚注之间尽量空一行。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">Markdown是一种纯文本标记语言</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^2</span>]: <span class="link">HyperText Markup Language 超文本标记语言</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^Le</span>]: <span class="link">开源笔记平台，支持Markdown和笔记直接发为博文</span></span><br></pre></td></tr></table></figure>

<p>使用 Markdown<a href="Markdown%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BA%AF%E6%96%87%E6%9C%AC%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">^1</a>可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote<a href="%E5%BC%80%E6%BA%90%E7%AC%94%E8%AE%B0%E5%B9%B3%E5%8F%B0%EF%BC%8C%E6%94%AF%E6%8C%81Markdown%E5%92%8C%E7%AC%94%E8%AE%B0%E7%9B%B4%E6%8E%A5%E5%8F%91%E4%B8%BA%E5%8D%9A%E6%96%87">^Le</a> 编辑器进行书写。</p>
<p>[^2]: HyperText Markup Language 超文本标记语言</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>支持使用有序列表和无序列表，有序列表用数字序号+英文句号+空格+列表内容来标记，无序列表由*&#x2F;+&#x2F;-+空格+列表内容来标记。</p>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>有序列表的语法如下。</p>
<p>数字 + . + 空格 + 列表内容</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 列表内容</span><br><span class="line"><span class="bullet">2.</span> 列表内容</span><br><span class="line"><span class="bullet">3.</span> 列表内容</span><br></pre></td></tr></table></figure>

<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>无序列表的语法如下。</p>
<p>*&#x2F;+&#x2F;- + 空格 + 列表内容， 使用 *&#x2F;+&#x2F;-来标记无序列表的效果是相同的。</p>
<p>推荐使用-。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 使用【<span class="emphasis">*】无序列表</span></span><br><span class="line"><span class="emphasis">*</span> 使用【<span class="emphasis">*】无序列表</span></span><br><span class="line"><span class="emphasis">*</span> 使用【<span class="emphasis">*】无序列表</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">+ 使用【+】无序列表</span></span><br><span class="line"><span class="emphasis">+ 使用【+】无序列表</span></span><br><span class="line"><span class="emphasis">+ 使用【+】无序列表</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- 使用【-】无序列表</span></span><br><span class="line"><span class="emphasis">- 使用【-】无序列表</span></span><br><span class="line"><span class="emphasis">- 使用【-】无序列表</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用【*】无序列表</p>
</li>
<li><p>使用【*】无序列表</p>
</li>
<li><p>使用【*】无序列表</p>
</li>
</ul>
<ul>
<li><p>使用【+】无序列表</p>
</li>
<li><p>使用【+】无序列表</p>
</li>
<li><p>使用【+】无序列表</p>
</li>
</ul>
<ul>
<li>使用【-】无序列表</li>
<li>使用【-】无序列表</li>
<li>使用【-】无序列表</li>
</ul>
<h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>任务列表的语法如下。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 未勾选</span><br><span class="line"><span class="bullet">-</span> [x] 已勾选</span><br></pre></td></tr></table></figure>

<p>任务列表的语法如下。<br>1）任务列表以-+空格开头，由 [空格&#x2F;x] 组成。<br>2）x可以小写，也可以大写，有些编辑器可能不支持大写，所以为避免解析错误，推荐使用小写x。<br>3）当方括号中的字符为空格时，复选框是未选中状态，为x时是选中状态。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">今日工作：</span><br><span class="line"><span class="bullet">-</span> [x] 吃</span><br><span class="line"><span class="bullet">-</span> [x] 喝</span><br><span class="line"><span class="bullet">-</span> [ ] 玩</span><br><span class="line"></span><br><span class="line">明日计划：</span><br><span class="line"><span class="bullet">-</span> [ ] 吃</span><br><span class="line"><span class="bullet">	-</span> [x] 吃鱼</span><br><span class="line"><span class="bullet">	-</span> [ ] 吃瓜</span><br><span class="line"><span class="bullet">-</span> [ ] 玩</span><br><span class="line"><span class="bullet">-</span> [x] 睡</span><br></pre></td></tr></table></figure>

<p>今日工作：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 吃</li>
<li><input checked="" disabled="" type="checkbox"> 喝</li>
<li><input disabled="" type="checkbox"> 玩</li>
</ul>
<p>明日计划：</p>
<ul>
<li><input disabled="" type="checkbox"> 吃<ul>
<li><input checked="" disabled="" type="checkbox"> 吃鱼</li>
<li><input disabled="" type="checkbox"> 吃瓜</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 玩</li>
<li><input checked="" disabled="" type="checkbox"> 睡</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用由&gt; 引用内容来标记</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用内容分</span></span><br></pre></td></tr></table></figure>

<p>语法说明如下。<br>1）多行引用也可以在每一行的开头都插入&gt;。<br>2）在引用中可以嵌套引用。<br>3）在引用中可以使用其他的Markdown语法。<br>4）段落与换行的格式在引用中也是适用的。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 我是引用的句子。</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 这是多行引用的第一行，我的最后有两个空格  </span></span><br><span class="line">我是第二行。</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 这是多行引用的第一行</span></span><br><span class="line"><span class="code">	第二行，第二行前面有1个TAB</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="quote">&gt; 引用中可以嵌套引用</span></span><br><span class="line">&gt;&gt; 我是引用中嵌套引用</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 引用中使用其他 Markdown 标记[<span class="string">百度</span>](<span class="link">https://baidu.com</span>)</span></span><br><span class="line"><span class="code">    第二行，**加粗**和*斜体*也是支持的，第二行前面有4个空格</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>我是引用的句子。</p>
</blockquote>
<blockquote>
<p>这是多行引用的第一行，我的最后有两个空格<br>我是第二行。</p>
</blockquote>
<blockquote>
<p>这是多行引用的第一行<br>第二行，第二行前面有1个TAB</p>
</blockquote>
<blockquote>
<p>引用中可以嵌套引用</p>
<blockquote>
<p>我是引用中嵌套引用</p>
</blockquote>
</blockquote>
<blockquote>
<p>引用中使用其他 Markdown 标记<a class="link"   href="https://baidu.com/" >百度<i class="fas fa-external-link-alt"></i></a><br>第二行，<strong>加粗</strong>和<em>斜体</em>也是支持的，第二行前面有4个空格</p>
</blockquote>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>插入图片的语法如下。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt</span>](<span class="link">/url &quot;title&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>语法说明如下。<br>1）alt在图片无法显示时显示的文字,title是鼠标放上去提示文字，都可以为空。<br>2）图片地址可以是本地图片的路径也可以是网络图片的地址。<br>3）本地图片支持相对路径和绝对路径两种方式。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">![<span class="string">百度</span>](<span class="link">https://www.baidu.com/img/PCfb_5bf082d29588c07f842ccde3f97243ea.png &quot;百度一下，你就知道&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img   src="https://www.baidu.com/img/PCfb_5bf082d29588c07f842ccde3f97243ea.png"  alt="百度" title="百度一下，你就知道"></p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="文字链接"><a href="#文字链接" class="headerlink" title="文字链接"></a>文字链接</h2><p>文字链接就是把链接地址直接写在文本中。语法是用方括号包裹链接文字，后面紧跟着括号包裹的链接地址，如下所示。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="string">link</span>](<span class="link">/uri &quot;title&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">https://baidu.com &quot;百度一下，你就知道&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><a class="link"   href="https://baidu.com/"  title="百度一下，你就知道">百度<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h2><p>引用链接是把链接地址作为<strong>变量</strong>先在Markdown文件的页尾定义好，然后在正文中进行引用。其语法如下。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="string">link</span>][<span class="symbol">link reference</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">link reference</span>]: <span class="link">/uri &quot;title&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>][<span class="symbol">baidu</span>]</span><br><span class="line">[<span class="symbol">baidu</span>]: <span class="link">https://baidu.com &quot;百度一下，你就知道&quot;</span></span><br></pre></td></tr></table></figure>

<p><a class="link"   href="https://baidu.com/"  title="百度一下，你就知道">百度<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="网址链接"><a href="#网址链接" class="headerlink" title="网址链接"></a>网址链接</h2><p>将网络地址或邮箱地址使用&lt;&gt;包裹起来会被自动转换为超链接。其语法如下。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">URL或邮箱地址</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">&lt;https://baidu.com&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml">&lt;liudehua@162.com&gt;</span></span><br></pre></td></tr></table></figure>

<p><a class="link"   href="https://baidu.com/" >https://baidu.com<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="mailto:&#108;&#x69;&#x75;&#100;&#101;&#x68;&#117;&#x61;&#64;&#49;&#54;&#50;&#x2e;&#x63;&#x6f;&#109;" >&#108;&#x69;&#x75;&#100;&#101;&#x68;&#117;&#x61;&#64;&#49;&#54;&#50;&#x2e;&#x63;&#x6f;&#109;<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h1><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="string">锚点描述</span>](<span class="link">#锚点名</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="string">回到标题</span>](<span class="link">#标题</span>)</span><br></pre></td></tr></table></figure>

<p><a href="#%E6%A0%87%E9%A2%98">回到标题</a></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h2><p>行内代码引用使用&#96;包裹，语法如下。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="code">`代码`</span></span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">使用<span class="code">`cd ..`</span>命令切换到上一级目录</span><br></pre></td></tr></table></figure>

<p>使用<code>cd ..</code>命令切换到上一级目录</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块以Tab键或4个空格开头，语法如下。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">以TAB键开头：</span><br><span class="line"><span class="code">	def print():</span></span><br><span class="line"><span class="code">	pass</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">或者以4个空格开头：</span></span><br><span class="line"><span class="code">    def print():</span></span><br><span class="line"><span class="code">    pass</span></span><br></pre></td></tr></table></figure>

<p>以TAB键开头：</p>
<pre><code>def print():
pass
</code></pre>
<p>或者以4个空格开头：</p>
<pre><code>def print():
pass
</code></pre>
<h2 id="围栏代码块"><a href="#围栏代码块" class="headerlink" title="围栏代码块"></a>围栏代码块</h2><p>在基础语法中，代码块使用Tab键或4个空格开头；在扩展语法中，围栏代码块使用连续3个&#96;或3个~包裹，还支持语法高亮，可读性和可维护性更强一些。</p>
<p>围栏代码块语法如下。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">\<span class="code">```无编程语言名称</span></span><br><span class="line"><span class="code">​```</span></span><br><span class="line">代码片段</span><br><span class="line">​<span class="code">```</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">\```</span>有编程语言名称</span><br><span class="line">​<span class="code">``` java</span></span><br><span class="line"><span class="code">代码片段</span></span><br><span class="line"><span class="code">​```</span></span><br><span class="line"></span><br><span class="line">\<span class="code">~~~无编程语言名称</span></span><br><span class="line"><span class="code">~~~</span></span><br><span class="line">代码片段</span><br><span class="line"><span class="code">~~~</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">\~~~</span>有编程语言名称</span><br><span class="line"><span class="code">~~~ java</span></span><br><span class="line"><span class="code">代码片段</span></span><br><span class="line"><span class="code">~~~</span></span><br></pre></td></tr></table></figure>

<p>语法说明如下。<br>围栏代码块使用连续3个&#96;或3个~包裹，支持语法高亮并可以加上编程语言的名字。</p>
<p>`&#96;&#96;无编程语言名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String name = &quot;Tom&quot;;</span><br><span class="line">int age = 18;</span><br></pre></td></tr></table></figure>

<p>`&#96;&#96;有编程语言名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<p>~~~无编程语言名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String name = &quot;Tom&quot;;</span><br><span class="line">int age = 18;</span><br></pre></td></tr></table></figure>

<p>~~~有编程语言名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>



<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>表格的语法如下。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">|表头1| 表头2 | 表头3|</span><br><span class="line">|---- | ---- | ----|</span><br><span class="line">|内容1 | 内容2 | 内容3|</span><br><span class="line">|内容1 | 内容2 | 内容3|</span><br></pre></td></tr></table></figure>

<p>语法说明如下。<br>1）单元格使用|来分隔，为了阅读更清晰，建议最前和最后都使用|。<br>2）单元格和|之间的空格会被移除。<br>3）表头与其他行使用-来分隔。<br>4）表格对齐格式如下。<br>左对齐（默认）	 :-<br>右对齐	-:<br>居中对齐 	:-:<br>5）块级元素（代码区块、引用区块）不能插入表格中。</p>
<p>关于创建表格的建议如下。<br>1）在表格的前、后各空1行。<br>2）在每一行最前和最后都使用|，每一行中的|要尽量都对齐。<br>3）不要使用庞大复杂的表格，那样会难以维护和阅读。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">普通表格</span><br><span class="line">| 序号 | 标题 | 网址 |</span><br><span class="line">| --- | ---- | --- |</span><br><span class="line">| 01  | 博客  |https://cnblogs.com|</span><br><span class="line">| 02  | 百度  |https://baidu.com|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对齐表格</span><br><span class="line">| 左对齐 | 居中对齐 | 右对齐 |</span><br><span class="line">| :--- | :----: | ---: |</span><br><span class="line">| 01  | 博客  |https://cnblogs.com|</span><br><span class="line">| 02  | 百度  |https://baidu.com|</span><br><span class="line"></span><br><span class="line">表格使用其他标记</span><br><span class="line">| 序号 | 标题 | 网址 |</span><br><span class="line">| --- | ---- | --- |</span><br><span class="line">| <span class="strong">**01**</span>  | [<span class="string">博客</span>](<span class="link">https://cnblogs.com</span>)  |https://cnblogs.com|</span><br><span class="line">| <span class="emphasis">*02*</span>  | [<span class="string">百度</span>](<span class="link">https://baidu.com &quot;百度一下，你就知道&quot;</span>)  |https://baidu.com|</span><br></pre></td></tr></table></figure>

<p>普通表格</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>标题</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td>博客</td>
<td><a class="link"   href="https://cnblogs.com/" >https://cnblogs.com<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td>02</td>
<td>百度</td>
<td><a class="link"   href="https://baidu.com/" >https://baidu.com<i class="fas fa-external-link-alt"></i></a></td>
</tr>
</tbody></table>
<p>对齐表格</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="center">居中对齐</th>
<th align="right">右对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">01</td>
<td align="center">博客</td>
<td align="right"><a class="link"   href="https://cnblogs.com/" >https://cnblogs.com<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td align="left">02</td>
<td align="center">百度</td>
<td align="right"><a class="link"   href="https://baidu.com/" >https://baidu.com<i class="fas fa-external-link-alt"></i></a></td>
</tr>
</tbody></table>
<p>表格使用其他标记</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>标题</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td><strong>01</strong></td>
<td><a class="link"   href="https://cnblogs.com/" >博客<i class="fas fa-external-link-alt"></i></a></td>
<td><a class="link"   href="https://cnblogs.com/" >https://cnblogs.com<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td><em>02</em></td>
<td><a class="link"   href="https://baidu.com/"  title="百度一下，你就知道">百度<i class="fas fa-external-link-alt"></i></a></td>
<td><a class="link"   href="https://baidu.com/" >https://baidu.com<i class="fas fa-external-link-alt"></i></a></td>
</tr>
</tbody></table>
<h1 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h1><table>
<thead>
<tr>
<th>语法</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>:smile:</code></td>
<td>:smile:</td>
</tr>
<tr>
<td><code>:laughing:</code></td>
<td>:laughing:</td>
</tr>
<tr>
<td><code>:+1:</code></td>
<td>:+1:</td>
</tr>
<tr>
<td><code>:-1:</code></td>
<td>:-1:</td>
</tr>
<tr>
<td><code>:clap:</code></td>
<td>:clap:</td>
</tr>
</tbody></table>
<p>更多的表情符号请参考<a class="link"   href="http://www.webpagefx.com/tools/emoji-cheat-sheet/%E3%80%82" >http://www.webpagefx.com/tools/emoji-cheat-sheet/。<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="高亮上标下标"><a href="#高亮上标下标" class="headerlink" title="高亮上标下标"></a>高亮上标下标</h1><p><strong>GFM不支持</strong></p>
<p><strong>Typora默认未开启，需要在文件&gt;偏好设置&gt;Markdown&gt;勾选Markdown扩展语法才能支持，请谨慎使用这几个语法。</strong></p>
<p>&#x3D;&#x3D;高亮&#x3D;&#x3D; <code>==高亮==</code></p>
<p>内容^上标^ <code>内容^上标^</code></p>
<p>内容<del>下标</del> <code>内容~下标~</code></p>
<h1 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h1><p>当我们想在Markdown文件中插入一些标记符号，但又不想让这些符号被渲染时，可以使用\进行转义，语法如下。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">\特殊符号</span><br></pre></td></tr></table></figure>

<p>可被转义的特殊符号如下。</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>`</td>
<td>反引号</td>
</tr>
<tr>
<td>*</td>
<td>星号</td>
</tr>
<tr>
<td>_</td>
<td>底线</td>
</tr>
<tr>
<td>{}</td>
<td>花括号</td>
</tr>
<tr>
<td>[]</td>
<td>方括号</td>
</tr>
<tr>
<td>()</td>
<td>括弧</td>
</tr>
<tr>
<td>#</td>
<td>井字号</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>-</td>
<td>减号</td>
</tr>
<tr>
<td>.</td>
<td>英文句号</td>
</tr>
<tr>
<td>!</td>
<td>感叹号</td>
</tr>
</tbody></table>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><strong>GFM不支持</strong></p>
<p>语法说明如下。<br>1）TOC是Table of Contents的缩写。<br>2）在想插入目录的位置输入[TOC]，按回车键后就可以自动生成文章的目录了。<br>直接输入[TOC]标记已经很简便了，可如果我们忘记了语法，也可以执行：菜单栏→【段落】→【内容目录】。<br>效果如下图所示。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure>



<p>[TOC]</p>
<h1 id="图表（了解）"><a href="#图表（了解）" class="headerlink" title="图表（了解）"></a>图表（了解）</h1><h2 id="横向流程图"><a href="#横向流程图" class="headerlink" title="横向流程图"></a>横向流程图</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">graph LR</span></span><br><span class="line"><span class="code">A[方形] --&gt;B(圆角)</span></span><br><span class="line"><span class="code">    B --&gt; C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">    C --&gt;|a=1| D[结果1]</span></span><br><span class="line"><span class="code">    C --&gt;|a=2| E[结果2]</span></span><br><span class="line"><span class="code">    F[横向流程图]</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure>



<h2 id="竖向流程图"><a href="#竖向流程图" class="headerlink" title="竖向流程图"></a>竖向流程图</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">graph TD</span></span><br><span class="line"><span class="code">A[方形] --&gt; B(圆角)</span></span><br><span class="line"><span class="code">    B --&gt; C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">    C --&gt; |a=1| D[结果1]</span></span><br><span class="line"><span class="code">    C --&gt; |a=2| E[结果2]</span></span><br><span class="line"><span class="code">    F[竖向流程图]</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a=1| D[结果1]</span><br><span class="line">    C --&gt; |a=2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure>





<h2 id="横向标准流程图"><a href="#横向标准流程图" class="headerlink" title="横向标准流程图"></a>横向标准流程图</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="code">```flow</span></span><br><span class="line"><span class="code">st=&gt;start: 开始框</span></span><br><span class="line"><span class="code">op=&gt;operation: 处理框</span></span><br><span class="line"><span class="code">cond=&gt;condition: 判断框(是或否?)</span></span><br><span class="line"><span class="code">sub1=&gt;subroutine: 子流程</span></span><br><span class="line"><span class="code">io=&gt;inputoutput: 输入输出框</span></span><br><span class="line"><span class="code">e=&gt;end: 结束框</span></span><br><span class="line"><span class="code">st-&gt;op-&gt;cond</span></span><br><span class="line"><span class="code">cond(yes)-&gt;io-&gt;e</span></span><br><span class="line"><span class="code">cond(no)-&gt;sub1(right)-&gt;op</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>





<h2 id="竖向标准流程图"><a href="#竖向标准流程图" class="headerlink" title="竖向标准流程图"></a>竖向标准流程图</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="code">```flow</span></span><br><span class="line"><span class="code">st=&gt;start: 开始框</span></span><br><span class="line"><span class="code">op=&gt;operation: 处理框</span></span><br><span class="line"><span class="code">cond=&gt;condition: 判断框(是或否?)</span></span><br><span class="line"><span class="code">sub1=&gt;subroutine: 子流程</span></span><br><span class="line"><span class="code">io=&gt;inputoutput: 输入输出框</span></span><br><span class="line"><span class="code">e=&gt;end: 结束框</span></span><br><span class="line"><span class="code">st(right)-&gt;op(right)-&gt;cond</span></span><br><span class="line"><span class="code">cond(yes)-&gt;io(bottom)-&gt;e</span></span><br><span class="line"><span class="code">cond(no)-&gt;sub1(right)-&gt;op</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>



<h2 id="UML时序图"><a href="#UML时序图" class="headerlink" title="UML时序图"></a>UML时序图</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="code">```sequence</span></span><br><span class="line"><span class="code">对象A-&gt;对象B: 对象B你好吗?（请求）</span></span><br><span class="line"><span class="code">Note right of 对象B: 对象B的描述</span></span><br><span class="line"><span class="code">Note left of 对象A: 对象A的描述(提示)</span></span><br><span class="line"><span class="code">对象B--&gt;对象A: 我很好(响应)</span></span><br><span class="line"><span class="code">对象A-&gt;对象B: 你真的好吗？</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure>



<h2 id="UML时序图源码-复杂"><a href="#UML时序图源码-复杂" class="headerlink" title="UML时序图源码(复杂)"></a>UML时序图源码(复杂)</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="code">```sequence</span></span><br><span class="line"><span class="code">Title: 标题：复杂使用</span></span><br><span class="line"><span class="code">对象A-&gt;对象B: 对象B你好吗?（请求）</span></span><br><span class="line"><span class="code">Note right of 对象B: 对象B的描述</span></span><br><span class="line"><span class="code">Note left of 对象A: 对象A的描述(提示)</span></span><br><span class="line"><span class="code">对象B--&gt;对象A: 我很好(响应)</span></span><br><span class="line"><span class="code">对象B-&gt;小三: 你好吗</span></span><br><span class="line"><span class="code">小三--&gt;&gt;对象A: 对象B找我了</span></span><br><span class="line"><span class="code">对象A-&gt;对象B: 你真的好吗？</span></span><br><span class="line"><span class="code">Note over 小三,对象B: 我们是朋友</span></span><br><span class="line"><span class="code">participant C</span></span><br><span class="line"><span class="code">Note right of C: 没人陪我玩</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure>



<h2 id="UML标准时序图"><a href="#UML标准时序图" class="headerlink" title="UML标准时序图"></a>UML标准时序图</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span></span><br><span class="line"><span class="code">  sequenceDiagram</span></span><br><span class="line"><span class="code">    participant 张三</span></span><br><span class="line"><span class="code">    participant 李四</span></span><br><span class="line"><span class="code">    张三-&gt;王五: 王五你好吗？</span></span><br><span class="line"><span class="code">    loop 健康检查</span></span><br><span class="line"><span class="code">        王五-&gt;王五: 与疾病战斗</span></span><br><span class="line"><span class="code">    end</span></span><br><span class="line"><span class="code">    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...</span></span><br><span class="line"><span class="code">    李四--&gt;&gt;张三: 很好!</span></span><br><span class="line"><span class="code">    王五-&gt;李四: 你怎么样?</span></span><br><span class="line"><span class="code">    李四--&gt;王五: 很好!</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">  sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure>



<h2 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">%% 语法示例</span></span><br><span class="line"><span class="code">        gantt</span></span><br><span class="line"><span class="code">        dateFormat  YYYY-MM-DD</span></span><br><span class="line"><span class="code">        title 软件开发甘特图</span></span><br><span class="line"><span class="code">        section 设计</span></span><br><span class="line"><span class="code">        需求                      :done,    des1, 2014-01-06,2014-01-08</span></span><br><span class="line"><span class="code">        原型                      :active,  des2, 2014-01-09, 3d</span></span><br><span class="line"><span class="code">        UI设计                     :         des3, after des2, 5d</span></span><br><span class="line"><span class="code">    未来任务                     :         des4, after des3, 5d</span></span><br><span class="line"><span class="code">        section 开发</span></span><br><span class="line"><span class="code">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span></span><br><span class="line"><span class="code">        设计框架                             :crit, done, after des2, 2d</span></span><br><span class="line"><span class="code">        开发                                 :crit, active, 3d</span></span><br><span class="line"><span class="code">        未来任务                              :crit, 5d</span></span><br><span class="line"><span class="code">        耍                                   :2d</span></span><br><span class="line"><span class="code">        section 测试</span></span><br><span class="line"><span class="code">        功能测试                              :active, a1, after des3, 3d</span></span><br><span class="line"><span class="code">        压力测试                               :after a1  , 20h</span></span><br><span class="line"><span class="code">        测试报告                               : 48h</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% 语法示例</span><br><span class="line">        gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title 软件开发甘特图</span><br><span class="line">        section 设计</span><br><span class="line">        需求                      :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        原型                      :active,  des2, 2014-01-09, 3d</span><br><span class="line">        UI设计                     :         des3, after des2, 5d</span><br><span class="line">    未来任务                     :         des4, after des3, 5d</span><br><span class="line">        section 开发</span><br><span class="line">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span><br><span class="line">        设计框架                             :crit, done, after des2, 2d</span><br><span class="line">        开发                                 :crit, active, 3d</span><br><span class="line">        未来任务                              :crit, 5d</span><br><span class="line">        耍                                   :2d</span><br><span class="line">        section 测试</span><br><span class="line">        功能测试                              :active, a1, after des3, 3d</span><br><span class="line">        压力测试                               :after a1  , 20h</span><br><span class="line">        测试报告                               : 48h</span><br></pre></td></tr></table></figure>

























]]></content>
      <tags>
        <tag>实用软件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>html</title>
    <url>/2023/08/11/2023/html/</url>
    <content><![CDATA[<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><p><img   src="/../images/html/Standard-box-model.png"  alt="images"><br><img   src="/../images/html/Weird-box-model.webp"  alt="images"></p>
<h1 id="元素的offsetHeight、scrollHeight、clientHeight属性"><a href="#元素的offsetHeight、scrollHeight、clientHeight属性" class="headerlink" title="元素的offsetHeight、scrollHeight、clientHeight属性"></a>元素的offsetHeight、scrollHeight、clientHeight属性</h1><p>offsetHeight: 包含元素的边框、内边距、内容和元素的水平滚动条（如果存在且渲染的话）<br><img   src="/../images/html/dimensions-offset.png"  alt="images"></p>
<p>offsetTop: 仅仅是元素边框之间的距离，当前元素相对于最近的定位父元素或者最近的 <code>table</code>, <code>td</code>, <code>th</code>, <code>body</code> 元素<br><img   src="/../images/html/offsetTop.webp"  alt="images"></p>
<p>scrollHeight: 只读属性 包括由于溢出导致的视图中不可见内容 即包括元素的内边距、内容高度<br><img   src="/../images/html/scrollheight.png"  alt="images"></p>
<p>scrollTop: 可以获取或设置元素内容从其顶部边缘滚动的像素数<br><img   src="/../images/html/scrollTop.webp"  alt="images"></p>
<p>clientHeight: 通过 CSS <code>height</code> + CSS <code>padding</code> - 水平滚动条高度（如果存在）来计算<br><img   src="/../images/html/dimensions-client.png"  alt="images"></p>
<p>clientTop: 获取元素顶部边框的宽度（以像素表示）</p>
]]></content>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>css学习记录</title>
    <url>/2023/11/09/2023/css/</url>
    <content><![CDATA[<h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a><a class="link"   href="https://www.w3school.com.cn/css/css3_flexbox.asp" >flex布局<i class="fas fa-external-link-alt"></i></a></h1><ul>
<li><code>flex-direction</code> 定义容器要在哪个方向上堆叠 flex 项目</li>
<li><code>flex-wrap</code>  规定是否应该对 flex 项目换行</li>
<li><code>flex-flow </code>   用于同时设置 flex-direction 和 flex-wrap 属性的简写属性</li>
<li><code>flex</code> 用于同时设置<code>flex-grow</code>(默认0) <code>flex-shrink</code> (默认1) <code>flex-basis</code> (默认auto)</li>
<li><code>justify-content</code>   用于对齐 flex 项目 （一行 左右方向操作）</li>
<li><code>align-items </code> 用于垂直对齐 flex 项目  (不换行的时候 上下方向操作)</li>
<li><code>align-content </code> 用于对齐弹性线 （换行得时候 上下方向操作）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex-flow: flex-direction flex-wrap</span><br><span class="line">flex: flex-grow(有剩余宽度的情况 0) flex-shrink(超出规定宽度的情况 1) flex-basis(基本的宽度 auto flex-basis比width具有更高的优先级)</span><br></pre></td></tr></table></figure>

<p><strong>align-self</strong>：auto | flex-start | flex-end | center | baseline | stretch</p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240323194835754.png"  alt="image-20240323194835754"></p>
<h1 id="li元素"><a href="#li元素" class="headerlink" title="li元素"></a>li元素</h1><p>list-style: &lt;’ <a class="link"   href="https://james-curtis.github.io/css-handbook/properties/list/list-style-type.htm" >list-style-type<i class="fas fa-external-link-alt"></i></a> ‘&gt; || &lt;’ <a class="link"   href="https://james-curtis.github.io/css-handbook/properties/list/list-style-position.htm" >list-style-position<i class="fas fa-external-link-alt"></i></a> ‘&gt; || &lt;’ <a class="link"   href="https://james-curtis.github.io/css-handbook/properties/list/list-style-image.htm" >list-style-image<i class="fas fa-external-link-alt"></i></a> ‘&gt;</p>
<p>disc outside none</p>
<h1 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h1><p>定位元素。即定义了<a class="link"   href="https://eric-gitta-moore.github.io/css-handbook/properties/positioning/position.htm" >position<i class="fas fa-external-link-alt"></i></a>为<code>非static</code>的元素</p>
<h1 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h1><h5 id="transform-translate-50-是参考哪个元素的50-参考自身的宽高"><a href="#transform-translate-50-是参考哪个元素的50-参考自身的宽高" class="headerlink" title="transform: translate(-50%);是参考哪个元素的50%  参考自身的宽高"></a>transform: translate(-50%);是参考哪个元素的50%  参考自身的宽高</h5><p><code>transform: translate(-50%,-50%);</code> 表示将元素沿着其自身的宽度和高度的一半进行平移。</p>
<p>需要注意的是，这种技术通常与绝对定位（absolute positioning）或固定定位（fixed positioning）一起使用，以便相对于其父元素进行居中定位。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.big</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.small</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://www.w3school.com.cn/css/css3_2dtransforms.asp"><code>transform</code></a> 变换  translate左右移动</p>
<p><code>transition</code> 过渡   元素慢慢变化</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition-property</span>: width;</span><br><span class="line"><span class="attribute">transition-duration</span>: <span class="number">2s</span>;</span><br><span class="line"><span class="attribute">transition-timing-function</span>: linear;</span><br><span class="line"><span class="attribute">transition-delay</span>: <span class="number">1s</span>;</span><br></pre></td></tr></table></figure>



<p><code>animation</code> 动画   none 0 ease 0 1 normal</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation</span>: name duration <span class="built_in">timing-function</span>(动画的速度) delay iteration-count direction;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@keyframes</span> 定义关键帧</span><br><span class="line"></span><br><span class="line"><span class="attribute">name</span>: 动画名</span><br><span class="line"><span class="attribute">duration</span>: 持续时间</span><br><span class="line">iteration-count：设置动画应运行多少次  infinite 无限次</span><br><span class="line">direction：反向或交替运行动画  normal - 动画正常播放（向前）。默认值</span><br><span class="line">                            reverse - 动画以反方向播放（向后）</span><br><span class="line">                            alternate - 动画先向前播放，然后向后</span><br><span class="line">                            alternate-reverse - 动画先向后播放，然后向前</span><br><span class="line">timing-function(动画的速度)</span><br><span class="line">                            ease - 指定从慢速开始，然后加快，然后缓慢结束的动画（默认）</span><br><span class="line">                            linear - 规定从开始到结束的速度相同的动画</span><br><span class="line">                            ease-in - 规定慢速开始的动画</span><br><span class="line">                            ease-out - 规定慢速结束的动画</span><br><span class="line">                            ease-in-out - 指定开始和结束较慢的动画</span><br><span class="line">                            cubic-bezier(n,n,n,n) - 运行您在三次贝塞尔函数中定义自己的值</span><br></pre></td></tr></table></figure>





<h1 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h1><p><a class="link"   href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" >链接<i class="fas fa-external-link-alt"></i></a></p>
<p>justify-item 横向</p>
<p>align-item 纵向</p>
<p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-items: &lt;align-items&gt; &lt;justify-items&gt;;</span><br></pre></td></tr></table></figure>

<p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: &lt;align-content&gt; &lt;justify-content&gt;</span><br></pre></td></tr></table></figure>



<h1 id="background"><a href="#background" class="headerlink" title="background"></a>background</h1><h1 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类&amp;伪元素"></a><a class="link"   href="https://www.w3school.com.cn/css/css_pseudo_elements.asp" >伪类&amp;伪元素<i class="fas fa-external-link-alt"></i></a></h1><p>: 伪类</p>
<p><code>:link</code>  未浏览</p>
<p><code>:visited</code>  已浏览</p>
<p><code>:hover</code>  鼠标放上去</p>
<p><code>:active</code> 点击得时候</p>
<p>:: 伪元素</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">例子</th>
<th align="left">例子描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/cssref/selector_after.asp" >::after<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">p::after</td>
<td align="left">在每个 <p> 元素之后插入内容。</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/cssref/selector_before.asp" >::before<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">p::before</td>
<td align="left">在每个 <p> 元素之前插入内容。</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/cssref/selector_first-letter.asp" >::first-letter<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">p::first-letter</td>
<td align="left">选择每个 <p> 元素的首字母。</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/cssref/selector_first-line.asp" >::first-line<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">p::first-line</td>
<td align="left">选择每个 <p> 元素的首行。</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/cssref/selector_selection.asp" >::selection<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">p::selection</td>
<td align="left">选择用户选择的元素部分。</td>
</tr>
</tbody></table>
<h1 id="nth-child-nth-of-type"><a href="#nth-child-nth-of-type" class="headerlink" title="nth-child&amp;nth-of-type()"></a>nth-child&amp;nth-of-type()</h1><p>:nth-child(n) :nth-last-child(n)(倒着数) :first-child :last-child  表示在每一组有父子结构的都会生效</p>
<p>:first-of-type :last-of-type :nth-of-type(n) :nth-last-of-type(n)  匹配父元素的倒数第n个子元素</p>
<p><a href="https://www.cnblogs.com/2050/p/3569509.html"><code>first-child</code>与<code>first-of-type</code>的区别</a> </p>
<p><strong>:first-child</strong> 匹配的是某父元素的第一个子元素，可以说是结构上的第一个子元素。</p>
<p><strong>:first-of-type</strong> 匹配的是某父元素下相同类型子元素中的第一个，比如 p:first-of-type，就是指所有类型为p的子元素中的第一个。这里不再限制是第一个子元素了，只要是该类型元素的第一个就行了。</p>
<p>同样类型的选择器 :last-child 和 :last-of-type、:nth-child(n) 和 :nth-of-type(n) 也可以这样去理解。</p>
<h1 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h1><p><a class="link"   href="https://www.w3school.com.cn/css/css_attribute_selectors.asp" >链接<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li><p>[attribute|&#x3D;”value”] 选择器用于选取指定属性以指定值开头的元素</p>
</li>
<li><p>[attribute^&#x3D;”value”] 选择器用于选取指定属性以指定值开头的元素 值不必是完整单词</p>
</li>
<li><p>[attribute$&#x3D;”value”] 选择器用于选取指定属性以指定值结尾的元素 值不必是完整单词</p>
</li>
<li><p>[attribute*&#x3D;”value”] 选择器选取属性值包含指定词的元素 值不必是完整单词</p>
</li>
</ul>
<h1 id="position"><a href="#position" class="headerlink" title="position"></a>position</h1><p><a class="link"   href="https://www.w3school.com.cn/css/css_positioning.asp" >链接<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li><p>static                                              top、bottom、left 和 right不起作用</p>
</li>
<li><p>relative                                          相对于其正常位置进行定位</p>
</li>
<li><p>fixed                                               固定某个元素不动   top、bottom、left 和 right进行调整位置在哪固定</p>
</li>
<li><p>absolute                                        相对于最近的定位祖先元素（除了static都算定位元素）进行定位（而不是相对于视口定位，如          fixed）如果绝对定位的元素没有祖先，它将使用文档主体（body），并随页面滚动一起移动</p>
</li>
<li><p>sticky                                              起先它会被相对定位，直到在视口中遇到给定的偏移位置为止 - 然后将其“粘贴”在适当的位置（比如  </p>
<p>​                                                        position:fixed）</p>
</li>
</ul>
<p>absolute和fixed会脱离文档流</p>
<h1 id="margin塌陷"><a href="#margin塌陷" class="headerlink" title="margin塌陷"></a>margin塌陷</h1><p><a class="link"   href="https://juejin.cn/post/6976272394247897101" >https://juejin.cn/post/6976272394247897101<i class="fas fa-external-link-alt"></i></a></p>
<p>父子嵌套的元素垂直方向的<code>margin</code>取最大值</p>
<p>解决margin塌陷方法</p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240105224715948.png"  alt="image-20240105224715948"></p>
<p>margin合并</p>
<p>两个上下相邻元素的外边距取最大值</p>
<h1 id="rem和em区别"><a href="#rem和em区别" class="headerlink" title="rem和em区别"></a>rem和em区别</h1><p>rem与em都是相对单位，我们使用它们的目的就是为了适应各种不同的移动端和pc端的屏幕。 <strong>rem是根据html根节点来计算的，而em是根据父级元素的字体计算的</strong>。 简单概括就是: rem相对于根元素,   em相对于父元素字体</p>
<h1 id="预处理器-后处理器"><a href="#预处理器-后处理器" class="headerlink" title="预处理器&amp;后处理器"></a>预处理器&amp;后处理器</h1><p>less sass cssnext</p>
<p>autoprefixer</p>
<h1 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h1><p>box-shadow: h-shadow v-shadow blur spread color inset;</p>
<h3 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h3><table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
<th align="left">测试</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>h-shadow</em></td>
<td align="left">必需。水平阴影的位置。允许负值。</td>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/tiy/c.asp?f=css_box-shadow" >测试<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td align="left"><em>v-shadow</em></td>
<td align="left">必需。垂直阴影的位置。允许负值。</td>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/tiy/c.asp?f=css_box-shadow" >测试<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td align="left"><em>blur</em></td>
<td align="left">可选。模糊距离。</td>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/tiy/c.asp?f=css_box-shadow&p=3" >测试<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td align="left"><em>spread</em></td>
<td align="left">可选。阴影的尺寸。</td>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/tiy/c.asp?f=css_box-shadow&p=7" >测试<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td align="left"><em>color</em></td>
<td align="left">可选。阴影的颜色。请参阅 CSS 颜色值。</td>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/tiy/c.asp?f=css_box-shadow&p=10" >测试<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td align="left">inset</td>
<td align="left">可选。将外部阴影 (outset) 改为内部阴影。</td>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/tiy/c.asp?f=css_box-shadow&p=15" >测试<i class="fas fa-external-link-alt"></i></a></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>默认值：</th>
<th>none</th>
</tr>
</thead>
</table>
<h1 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h1><ul>
<li><a class="link"   href="https://www.w3school.com.cn/cssref/pr_grid-template-rows.asp" >grid-template-rows<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.w3school.com.cn/cssref/pr_grid-template-columns.asp" >grid-template-columns<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.w3school.com.cn/cssref/pr_grid-template-areas.asp" >grid-template-areas<i class="fas fa-external-link-alt"></i></a> 要设置grid-area属性</li>
<li><a class="link"   href="https://www.w3school.com.cn/cssref/pr_grid-auto-rows.asp" >grid-auto-rows<i class="fas fa-external-link-alt"></i></a>  grid-template-rows 属性覆盖此属性</li>
<li><a class="link"   href="https://www.w3school.com.cn/cssref/pr_grid-auto-columns.asp" >grid-auto-columns<i class="fas fa-external-link-alt"></i></a>  grid-template-columns 属性会覆盖此属性</li>
<li><a class="link"   href="https://www.w3school.com.cn/cssref/pr_grid-auto-flow.asp" >grid-auto-flow<i class="fas fa-external-link-alt"></i></a>  两个属性 row column</li>
</ul>
<p>grid-area: 语法是 grid-row-start &#x2F; grid-column-start &#x2F; grid-row-end &#x2F; grid-column-end<br>默认值 auto &#x2F; auto &#x2F; auto &#x2F; auto	</p>
<p>grid: none|grid-template-rows &#x2F; grid-template-columns|grid-template-areas|grid-template-rows &#x2F; [grid-auto-flow] grid-auto-columns|[grid-auto-flow] grid-auto-rows &#x2F; grid-template-columns|initial|inherit;</p>
<h2 id="属性值-1"><a href="#属性值-1" class="headerlink" title="属性值"></a>属性值</h2><table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">默认值。不定义行或列的尺寸。</td>
</tr>
<tr>
<td align="left"><em>grid-template-rows</em> &#x2F; <em>grid-template-columns</em></td>
<td align="left">规定列和行的尺寸。</td>
</tr>
<tr>
<td align="left"><em>grid-template-areas</em></td>
<td align="left">规定使用命名项目的网格布局。</td>
</tr>
<tr>
<td align="left"><em>grid-template-rows</em> &#x2F; <em>grid-auto-columns</em></td>
<td align="left">规定行的尺寸（高度），以及列的自动尺寸。</td>
</tr>
<tr>
<td align="left"><em>grid-auto-rows</em> &#x2F; <em>grid-template-columns</em></td>
<td align="left">规定行的自动尺寸，并设置 grid-template-columns 属性。</td>
</tr>
<tr>
<td align="left"><em>grid-template-rows</em> &#x2F; <em>grid-auto-flow</em> <em>grid-auto-columns</em></td>
<td align="left">规定行的尺寸（高度），以及如何放置自动就位的项目，和列的自动尺寸。</td>
</tr>
<tr>
<td align="left"><em>grid-auto-flow</em> <em>grid-auto-rows</em> &#x2F; <em>grid-template-columns</em></td>
<td align="left">规定如何放置自动就位的项目，和行的自动尺寸，以及设置 grid-template-columns 属性。</td>
</tr>
<tr>
<td align="left">initial</td>
<td align="left">将此属性设置为其默认值。参阅 <a class="link"   href="https://www.w3school.com.cn/cssref/css_initial.asp" >initial<i class="fas fa-external-link-alt"></i></a>。</td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">从其父元素继承此属性。参阅 <a class="link"   href="https://www.w3school.com.cn/cssref/css_inherit.asp" >inherit<i class="fas fa-external-link-alt"></i></a>。</td>
</tr>
</tbody></table>
<h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><table>
<thead>
<tr>
<th>默认值：</th>
<th>none none none auto auto row</th>
</tr>
</thead>
</table>
<h1 id="实现图片文字居中"><a href="#实现图片文字居中" class="headerlink" title="实现图片文字居中"></a>实现图片文字居中</h1><p>vertical-align</p>
<h1 id="如何实现盒子内容水平居中"><a href="#如何实现盒子内容水平居中" class="headerlink" title="如何实现盒子内容水平居中"></a>如何实现盒子内容水平居中</h1><ul>
<li><p>行内元素或者内联元素 使用父元素的 <code>text-align</code> 属性来实现文本水平居中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>块级元素 使用<code>margin: auto;</code> 来使元素水平居中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 flex 布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 grid 布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  place-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用transform</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="如何实现两栏分开布局"><a href="#如何实现两栏分开布局" class="headerlink" title="如何实现两栏分开布局"></a>如何实现两栏分开布局</h1><h4 id="1-流式布局（使用-float）："><a href="#1-流式布局（使用-float）：" class="headerlink" title="1. 流式布局（使用 float）："></a>1. 流式布局（使用 <code>float</code>）：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left-column</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right-column</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Flex-布局："><a href="#2-Flex-布局：" class="headerlink" title="2. Flex 布局："></a>2. Flex 布局：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left-column</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">70%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right-column</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Grid-布局："><a href="#3-Grid-布局：" class="headerlink" title="3. Grid 布局："></a>3. Grid 布局：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">70%</span> <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何实现三栏布局"><a href="#如何实现三栏布局" class="headerlink" title="如何实现三栏布局"></a>如何实现三栏布局</h1><h3 id="1-流式布局（使用-float）：-1"><a href="#1-流式布局（使用-float）：-1" class="headerlink" title="1. 流式布局（使用 float）："></a>1. 流式布局（使用 <code>float</code>）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left-column &#123;</span><br><span class="line">  width: 30%;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.center-column &#123;</span><br><span class="line">  width: 40%;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right-column &#123;</span><br><span class="line">  width: 30%;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Flex-布局：-1"><a href="#2-Flex-布局：-1" class="headerlink" title="2. Flex 布局："></a>2. Flex 布局：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left-column &#123;</span><br><span class="line">  flex: 30%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.center-column &#123;</span><br><span class="line">  flex: 40%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right-column &#123;</span><br><span class="line">  flex: 30%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Grid-布局：-1"><a href="#3-Grid-布局：-1" class="headerlink" title="3. Grid 布局："></a>3. Grid 布局：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 30% 40% 30%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-圣杯布局（使用-flex-和负边距）："><a href="#4-圣杯布局（使用-flex-和负边距）：" class="headerlink" title="4. 圣杯布局（使用 flex 和负边距）："></a>4. 圣杯布局（使用 <code>flex</code> 和负边距）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left-column,</span><br><span class="line">.right-column,</span><br><span class="line">.center-column &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.center-column &#123;</span><br><span class="line">  order: 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left-column &#123;</span><br><span class="line">  order: 1;</span><br><span class="line">  margin-right: -100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right-column &#123;</span><br><span class="line">  order: 3;</span><br><span class="line">  margin-left: -100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-双飞翼布局（使用-float-和-margin）："><a href="#5-双飞翼布局（使用-float-和-margin）：" class="headerlink" title="5. 双飞翼布局（使用 float 和 margin）："></a>5. 双飞翼布局（使用 <code>float</code> 和 <code>margin</code>）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.column &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left-column &#123;</span><br><span class="line">  width: 30%;</span><br><span class="line">  margin-left: -100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.center-column &#123;</span><br><span class="line">  width: 40%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right-column &#123;</span><br><span class="line">  width: 30%;</span><br><span class="line">  margin-left: -30%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="块级格式化上下文"><a href="#块级格式化上下文" class="headerlink" title="块级格式化上下文"></a>块级格式化上下文</h1><p>BFC 主要用于处理布局和浮动等问题，它规定了块级盒子如何堆叠、定位和清除浮动</p>
<p>创建 BFC 的方式有多种，其中一些包括：</p>
<ul>
<li><strong>根元素：</strong> HTML 文档的根元素（html）就是一个 BFC。</li>
<li><strong>浮动元素：</strong> 元素的 float 属性不是 none。</li>
<li><strong>绝对定位元素：</strong> 元素的 position 属性为 absolute 或 fixed。</li>
<li><strong>display 属性值不为 block、inline-block、flex、inline-flex 之一的元素：</strong> 例如，table 元素会生成一个 BFC。</li>
<li><strong>overflow 属性不为 visible 的元素：</strong> 设置了 overflow 属性值为 auto、scroll、hidden 的元素会生成 BFC。</li>
</ul>
<h1 id="尺寸的百分比"><a href="#尺寸的百分比" class="headerlink" title="尺寸的百分比"></a>尺寸的百分比</h1><p>普通元素相对于父元素的内容区域  （没有定位的元素称为普通元素）</p>
<p>绝对 (固定) 定位元素的参考系为父元素中 第一个定位元素的padding区域</p>
<h1 id="隐藏元素的三种方式"><a href="#隐藏元素的三种方式" class="headerlink" title="隐藏元素的三种方式"></a>隐藏元素的三种方式</h1><p>如果需要彻底隐藏元素且不占据页面空间，可以使用 <code>display: none;</code>；</p>
<p>如果需要隐藏元素但仍然占据页面空间，可以使用 <code>visibility: hidden;</code>；</p>
<p>如果需要隐藏元素但仍然保留占据的空间且可能需要进行过渡效果，可以使用 <code>opacity: 0;</code></p>
<h1 id="css-loader-style-loader-less-loader-sass-loader"><a href="#css-loader-style-loader-less-loader-sass-loader" class="headerlink" title="css-loader&amp;style-loader&amp;less-loader&amp;sass-loader"></a>css-loader&amp;style-loader&amp;less-loader&amp;sass-loader</h1><p>由于css-loader仅提供了将css转换为字符串导出的能力</p>
<p>style-loader可以将css-loader转换后的代码进一步处理，将css-loader导出的字符串加入到页面的style元素中</p>
<p>BEM  &amp;  CSS in js  &amp; CSS module</p>
<p>BEM全称是：<strong>B</strong>lock <strong>E</strong>lement <strong>M</strong>odifier</p>
<p>BEM是一套针对css类样式的命名方法</p>
<p>三个部分的具体含义为：</p>
<ul>
<li><strong>Block</strong>：页面中的大区域，表示最顶级的划分，例如：轮播图(<code>banner</code>)、布局(<code>layout</code>)、文章(<code>article</code>)等等</li>
<li><strong>element</strong>：区域中的组成部分，例如：轮播图中的横幅图片(<code>banner__img</code>)、轮播图中的容器（<code>banner__container</code>）、布局中的头部(<code>layout__header</code>)、文章中的标题(<code>article_title</code>)</li>
<li><strong>modifier</strong>：可选。通常表示状态，例如：处于展开状态的布局左边栏（<code>layout__left_expand</code>）、处于选中状态的轮播图小圆点(<code>banner__dot_selected</code>)</li>
</ul>
<p>css in js 的核心思想是：用一个JS对象来描述样式，而不是css样式表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> styles = &#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>: <span class="string">&quot;#f40&quot;</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;#fff&quot;</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="string">&quot;400px&quot;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="string">&quot;500px&quot;</span>,</span><br><span class="line">    <span class="attr">margin</span>: <span class="string">&quot;0 auto&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="postcss"><a href="#postcss" class="headerlink" title="postcss"></a>postcss</h1><p>真正起作用的是里面的插件<code>postcss-preset-env</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: &#123;</span><br><span class="line">        <span class="string">&quot;postcss-preset-env&quot;</span>: &#123;&#125; <span class="comment">// &#123;&#125; 中可以填写插件的配置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="border"><a href="#border" class="headerlink" title="border"></a>border</h1><p><a class="link"   href="https://www.w3school.com.cn/css/css_border_shorthand.asp" >https://www.w3school.com.cn/css/css_border_shorthand.asp<i class="fas fa-external-link-alt"></i></a></p>
<p>border:  三个属性简写</p>
<ul>
<li><code>border-width</code></li>
<li><code>border-style</code>（必需）</li>
<li><code>border-color</code></li>
</ul>
<p>以切角的形式相连  比如做个三角形</p>
<p>在CSS中，样式权重（也称为“优先级”）决定了当多个规则作用于同一个元素时，哪一个规则会被应用。权重的计算是基于选择器的类型和优先级规则来确定的。以下是CSS样式权重的具体计算方法：</p>
<h3 id="1-权重的基本组成"><a href="#1-权重的基本组成" class="headerlink" title="1. 权重的基本组成"></a>1. <strong>权重的基本组成</strong></h3><p>CSS权重由以下几部分组成，从高到低依次为：</p>
<ol>
<li><strong>内联样式（Inline Styles）</strong>：直接写在HTML标签的<code>style</code>属性中的样式。</li>
<li><strong>ID选择器（ID Selectors）</strong>：通过<code>id</code>属性选择元素。</li>
<li><strong>类选择器、属性选择器和伪类选择器（Class, Attribute, Pseudo-class Selectors）</strong>：通过类名、属性或伪类选择元素。</li>
<li><strong>元素选择器和伪元素选择器（Element Selectors and Pseudo-elements）</strong>：通过标签名或伪元素选择元素。</li>
<li><strong>通用选择器（Universal Selector）</strong>：<code>*</code>选择器，权重最低。</li>
</ol>
<h3 id="2-权重的计算方法"><a href="#2-权重的计算方法" class="headerlink" title="2. 权重的计算方法"></a>2. <strong>权重的计算方法</strong></h3><p>权重通常用一个四元组<code>(a, b, c, d)</code>来表示，其中：</p>
<ul>
<li><code>a</code>：内联样式（<code>style</code>属性）的数量。</li>
<li><code>b</code>：ID选择器的数量。</li>
<li><code>c</code>：类选择器、属性选择器和伪类选择器的数量。</li>
<li><code>d</code>：元素选择器和伪元素选择器的数量。</li>
</ul>
<p><strong>规则：</strong></p>
<ul>
<li>如果两个选择器的权重不同，则权重高的优先。</li>
<li>如果权重相同，则后定义的样式优先（CSS的“后定义覆盖先定义”规则）。</li>
<li>如果权重相同且定义顺序也相同，则继承的样式优先级最低。</li>
</ul>
<h3 id="3-权重计算示例"><a href="#3-权重计算示例" class="headerlink" title="3. 权重计算示例"></a>3. <strong>权重计算示例</strong></h3><p>以下是一些权重计算的例子：</p>
<h4 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: blue; &#125; <span class="comment">/* 权重：(0, 0, 0, 1) */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123; <span class="attribute">color</span>: green; &#125; <span class="comment">/* 权重：(0, 0, 1, 0) */</span></span><br><span class="line"><span class="selector-id">#main</span> &#123; <span class="attribute">color</span>: yellow; &#125; <span class="comment">/* 权重：(0, 1, 0, 0) */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.container</span> &#123; <span class="attribute">color</span>: purple; &#125; <span class="comment">/* 权重：(0, 0, 1, 1) */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#main</span> &#123; <span class="attribute">color</span>: orange; &#125; <span class="comment">/* 权重：(0, 1, 0, 1) */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#main</span><span class="selector-class">.container</span> &#123; <span class="attribute">color</span>: pink; &#125; <span class="comment">/* 权重：(0, 1, 1, 1) */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[style]</span> &#123; <span class="attribute">color</span>: black; &#125; <span class="comment">/* 权重：(1, 0, 0, 1) */</span></span><br></pre></td></tr></table></figure>
<p>最终，<code>color: red;</code>（内联样式）会生效，因为它的权重最高：<code>(1, 0, 0, 0)</code>。</p>
<h4 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.container</span> &#123; <span class="attribute">color</span>: purple; &#125; <span class="comment">/* 权重：(0, 0, 1, 1) */</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: green; &#125; <span class="comment">/* 权重：(0, 0, 1, 1) */</span></span><br></pre></td></tr></table></figure>
<p>两个选择器的权重相同，但<code>div.container</code>定义在前，<code>color: purple</code>会生效。</p>
<h4 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: blue; &#125; <span class="comment">/* 权重：(0, 0, 0, 1) */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123; <span class="attribute">color</span>: green; &#125; <span class="comment">/* 权重：(0, 0, 1, 0) */</span></span><br></pre></td></tr></table></figure>
<p><code>color: green;</code>会生效，因为它的权重更高。</p>
<h3 id="4-特殊情况"><a href="#4-特殊情况" class="headerlink" title="4. 特殊情况"></a>4. <strong>特殊情况</strong></h3><ul>
<li><strong><code>!important</code>规则</strong>：如果样式中使用了<code>!important</code>，则该样式会覆盖其他任何权重更高的样式。但<code>!important</code>应谨慎使用，因为它会破坏正常的权重规则。</li>
<li><strong>继承样式</strong>：某些CSS属性（如<code>color</code>和<code>font-size</code>）会从父元素继承，但继承的样式权重最低，可以被其他任何规则覆盖。</li>
</ul>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h3><p>CSS样式的权重计算是基于选择器的类型和数量来决定的。通过合理使用选择器和避免过度依赖<code>!important</code>，可以更好地控制样式的优先级，使CSS代码更加清晰和易于维护。</p>
]]></content>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript学习记录</title>
    <url>/2023/03/09/2023/javascript/</url>
    <content><![CDATA[<h1 id="js核心一点的东西"><a href="#js核心一点的东西" class="headerlink" title="js核心一点的东西"></a>js核心一点的东西</h1><ol>
<li><p>堆栈</p>
</li>
<li><p>事件循环</p>
</li>
<li><p>原型和原型链</p>
</li>
<li><p>执行上下文</p>
<ul>
<li>不会保存匿名函数</li>
</ul>
</li>
<li><p>作用域和作用域链</p>
</li>
<li><p><a class="link"   href="https://juejin.cn/post/6937469222251560990#heading-0" >闭包<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li>函数创建时形成闭包</li>
<li>闭包是指有权访问另一函数作用域中变量的函数</li>
<li>内部的函数存在外部作用域的引用就会导致闭包</li>
</ul>
</li>
</ol>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240317135032288.png"  alt="image-20240317135032288"></p>
<h1 id="基本数据类型，复杂"><a href="#基本数据类型，复杂" class="headerlink" title="基本数据类型，复杂"></a>基本数据类型，复杂</h1><p>string，number, boolean, null, undefined, symbol, bigint<br>object, function, date</p>
<h1 id="事件捕获冒泡"><a href="#事件捕获冒泡" class="headerlink" title="事件捕获冒泡"></a>事件捕获冒泡</h1><p>先捕获 在冒泡</p>
<p>addEventListener（‘click’,cb,false）</p>
<p>false 表示冒泡 （默认） true : 捕获</p>
<p>preventDefault <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault#%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C" >阻止默认的点击事件执行<i class="fas fa-external-link-alt"></i></a></p>
<p>stopPropagation <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event"><code>Event</code></a> 接口的 <strong><code>stopPropagation()</code></strong> 方法阻止捕获和冒泡阶段中当前事件的进一步传播。但是，它不能防止任何默认行为的发生；例如，对链接的点击仍会被处理	总结无用</p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240404140003753.png"  alt="image-20240404140003753"></p>
<h1 id="数组的sort"><a href="#数组的sort" class="headerlink" title="数组的sort"></a>数组的sort</h1><p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240405195816117.png"  alt="image-20240405195816117"></p>
<h1 id="settimeout-知识点"><a href="#settimeout-知识点" class="headerlink" title="settimeout 知识点"></a><a class="link"   href="https://blog.csdn.net/weixin_44179269/article/details/113420767" >settimeout<i class="fas fa-external-link-alt"></i></a> 知识点</h1><p>this关键字将指向全局环境</p>
<p>使用匿名函数在局部作用域作用</p>
<h1 id="闭包-实现数据的私有"><a href="#闭包-实现数据的私有" class="headerlink" title="闭包 实现数据的私有"></a>闭包 实现数据的私有</h1><p>1.return  将局部变量返回 让外部能够使用</p>
<p>2.内存泄漏 （占用内存无法释放）</p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106112237318.png"  alt="image-20240106112237318"></p>
<h1 id="节流与防抖"><a href="#节流与防抖" class="headerlink" title="节流与防抖"></a><a class="link"   href="https://juejin.cn/post/7324522555268366351?searchId=20240317144635AC78650ACECF33156AFD" >节流与防抖<i class="fas fa-external-link-alt"></i></a></h1><p>防抖：<img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106112829283.png"  alt="image-20240106112829283"></p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106113827578.png"  alt="image-20240106113827578"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleDebounce</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Debounced function called&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> debouncedFunction = <span class="title function_">debounce</span>(handleDebounce, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟高频率调用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">debouncedFunction</span>();</span><br><span class="line">    &#125;, i * <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106113417048.png"  alt="image-20240106113417048"></p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106113652153.png"  alt="image-20240106113652153"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleThrottle</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Throttled function called&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> throttledFunction = <span class="title function_">throttle</span>(handleThrottle, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟高频率调用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">throttledFunction</span>();</span><br><span class="line">    &#125;, i * <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106113750195.png"  alt="image-20240106113750195"></p>
<h1 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h1><p>一种 函数对象的 __ proto __ &#x3D;&#x3D;&gt; Function.prototype</p>
<p>一种 原型对象的 __ proto __ &#x3D;&#x3D;&gt; Object.prototype</p>
<p><a class="link"   href="https://juejin.cn/post/7255605810453217335?searchId=20240819224623005400B7CDE5BA5B584B" >下图来源<i class="fas fa-external-link-alt"></i></a></p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240316221910332.png"  alt="image-20240316221910332"></p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240316222709961.png"  alt="image-20240316222709961"></p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106114817353.png"  alt="image-20240106114817353"></p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106114855144.png"  alt="image-20240106114855144"></p>
<h1 id="关于变量提升"><a href="#关于变量提升" class="headerlink" title="关于变量提升"></a>关于变量提升</h1><p>var变量声明提升，函数声明提升，函数内部var声明变量提升</p>
<p>函数表达式不会被提升</p>
<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p><a class="link"   href="https://juejin.cn/post/6844903682283143181" >https://juejin.cn/post/6844903682283143181<i class="fas fa-external-link-alt"></i></a></p>
<p>1.this绑定是在函数运行时发生的   </p>
<p>在全局执行上下文中，<code>this</code> 的值指向全局对象。(在浏览器中，<code>this</code>引用 Window 对象)。 默认</p>
<p>在函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象，否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）  隐式</p>
<p>2.词法环境组件 let const</p>
<ul>
<li>在<strong>全局环境</strong>（全局执行上下文）中，环境记录器是<strong>对象</strong>环境记录器。用来定义出现在<strong>全局上下文</strong>中的变量和函数的关系</li>
<li>在<strong>函数环境</strong>中，环境记录器是<strong>声明式</strong>环境记录器     存储变量、函数和参数 arguments对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong></li>
</ul>
<p>3.变量环境组件  var</p>
<h1 id="this指向四种调用模式判断"><a href="#this指向四种调用模式判断" class="headerlink" title="this指向四种调用模式判断"></a>this指向四种调用模式判断</h1><p><a class="link"   href="https://www.yuque.com/cuggz/interview/vgbphi#e39a6ab8b784fd88bbcf2aeb2ed82b8d" >https://www.yuque.com/cuggz/interview/vgbphi#e39a6ab8b784fd88bbcf2aeb2ed82b8d<i class="fas fa-external-link-alt"></i></a></p>
<p>优先级：构造器（new）–&gt; call apply bind  –&gt; 方法 –&gt;  函数        new  显式 隐式  默认</p>
<p>1.this绑定是在函数运行时发生的   </p>
<p>在全局执行上下文中，<code>this</code> 的值指向全局对象。(在浏览器中，<code>this</code>引用 Window 对象)。 默认</p>
<p>在函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象，否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）  隐式</p>
<p>1、fn.call (newThis,params) call函数的第一个参数是this的新指向，后面依次传入函数fn要用到的参数。会立即执行fn函数。<br>2、fn.apply (newThis,paramsArr) apply函数的第一个参数是this的新指向,第二个参数是fn要用到的参数数组，会立即执行fn函数。<br>3、fn.bind (newThis,params) bind函数的第一个参数是this的新指向，后面的参数可以直接传递，也可以按数组的形式传入。  不会立即执行fn函数，且只能改变一次fn函数的指向，后续再用bind更改无效。返回的是已经更改this指向的新fn</p>
<p>箭头函数.它的this由定义它的结构代码时父级执行上下文决定的</p>
<ul>
<li>如果是在全局环境,或者是<strong>在一个对象里</strong>,它的父级执行上下文就是全局环境,它的this就指向了window</li>
<li>如果它的外部是一个函数,那么它的this就指向了函数的执行上下文.而函数的执行上下文就是活的.取决于调用时的情况.也就上面列举的四种情况</li>
</ul>
<h1 id="执行上下文中包含的东西："><a href="#执行上下文中包含的东西：" class="headerlink" title="执行上下文中包含的东西："></a>执行上下文中包含的东西：</h1><p>1.this指向</p>
<ol>
<li><p>. 直接调用函数，this指向全局对象  eg:  fn();</p>
</li>
<li><p>. 在函数外，this指向全局对象</p>
</li>
<li><p>.通过<strong>对象调用或new一个函数</strong>，this指向<strong>调用的对象</strong>或<strong>新对象</strong></p>
</li>
</ol>
<p>2.VO 变量对象<br>Variable object: VO中记录了该环境中所有声明的<strong>参数、变量和函数</strong><br>Global object: GO，全局执行上下文中的vO</p>
<p>1).确定所有形参值以及特殊变量arguments</p>
<p>2).确定函数中通过var声明的变量，将它们的值设置为undefined （ 变量名重复 忽略）</p>
<p>3).确定函数中通过字面量声明的函数，将它们的值设置为指向函数对象 （函数名重复 覆盖） 函数还优于变量</p>
<p>当一个上下文中的代码执行的时候，如果上下文中不存在某个属性，则会从之前的上下文寻找。</p>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><ol>
<li>VO中包含一个额外的属性，该属性指向创建该VO的函数本身</li>
<li>每个函数在创建时，会有一个隐藏属性<code>[[scope]]</code>，它指向创建该函数时的AO</li>
<li>当访问一个变量时，会先查找自身VO中是否存在，如果不存在，则依次查找<code>[[scope]]</code>属性。</li>
<li><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240510114429132.png"  alt="image-20240510114429132"></li>
</ol>
<h1 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var let const"></a>var let const</h1><p>var 和 func都会存在变量提升</p>
<p>在全局声明var a b  在函数内部写成 var a &#x3D; b &#x3D; 3  a就成了局部变量了？！ 不写var 全局</p>
<h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><p><a class="link"   href="https://juejin.cn/post/7007224479218663455?searchId=20240316163826AD692671C0071193C544" >https://juejin.cn/post/7007224479218663455?searchId=20240316163826AD692671C0071193C544<i class="fas fa-external-link-alt"></i></a></p>
<p>1.在全局作用域中</p>
<ul>
<li><p>var 和 func 会在同一级都有变量提升 并且函数优先级比变量高</p>
</li>
<li><p>除了变量提升，函数实际上也是存在提升的。JavaScript中具名的函数的声明形式有两种：</p>
</li>
</ul>
<p>当使用<strong>变量形式声明</strong>函数时，和普通的变量一样会存在提升的现象，而函数声明式会提升到作用域最前边，并且将声明内容一起提升到最上边</p>
<p>2.在函数作用域中</p>
<p>函数作用域中也存在变量提升</p>
<h1 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h1><p>在这运行流程进入作用域创建变量，到变量可以被访问之间的这段时间，就称之为暂时死区。</p>
<h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><p>静态方法: then catch finally all allsettled race any</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise封装Ajax请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">method, url, data</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(xhr.<span class="property">statusText</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line">        xhr.<span class="title function_">send</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="指定回调与改变状态先后顺序问题"><a href="#指定回调与改变状态先后顺序问题" class="headerlink" title="指定回调与改变状态先后顺序问题"></a>指定回调与改变状态先后顺序问题</h2><p>正常情况下是先指定回调再改变状态，但也可以先改变状态在指定回调</p>
<p>Promise本身是同步的立即执行函数，当在executor中执行resolve或者reject的时候,此时是异步操作，会先执行then&#x2F;catch等，当主栈完成后，才会去调用resolve&#x2F;reiect中存放的方法执行<br>await 表达式的运算结果取决于它等的是什么。<br>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西<br>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阳塞后面的代码，等着 Promise 对象 resolve然后得到 resolve 的值，作为 await 表达式的运算结果</p>
<h1 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h1><p>1.工厂</p>
<p>2.构造函数</p>
<p>3.原型</p>
<p>4.组合使用2，3</p>
<p>5.动态原型</p>
<p>6.寄生构造函数</p>
<h1 id="js中filter-map-foreach的区别"><a href="#js中filter-map-foreach的区别" class="headerlink" title="js中filter map foreach的区别"></a>js中filter map foreach的区别</h1><p><strong>forEach</strong>方法：遍历数组的每一个元素，默认没有返回值。 </p>
<p><strong>filter</strong>方法：对数组元素进行条件筛选。 返回一个数组，将原数组符合条件的元素放入数组<strong>中</strong>。 (<strong>filter</strong>方法不改变原数组) </p>
<p><strong>map</strong>方法：返回一个数组，这个新数组的每一个元素都是原数组元素执行了回调函数之后的返回值。</p>
<h1 id="为什么0-1-0-2-0-3在js中"><a href="#为什么0-1-0-2-0-3在js中" class="headerlink" title="为什么0.1+0.2!&#x3D;&#x3D;0.3在js中"></a>为什么0.1+0.2!&#x3D;&#x3D;0.3在js中</h1><p>由于浮点数的精度问题</p>
<p>在js中 浮点数是以二进制表示的 但是十进制无法精确转为二进制</p>
<p>0.1 和 0.2 在二进制中是无限循环的小数</p>
<p>使用toFixed方法</p>
<h1 id="如何理解-JS的异步"><a href="#如何理解-JS的异步" class="headerlink" title="如何理解 JS的异步?"></a>如何理解 JS的异步?</h1><p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个而渲染主线程承担着诸多的工作，渲染页面、执行 JS都在其中运行。如果使用<strong>同步</strong>的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。<br>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如<strong>计时器、网络、事件监听</strong>，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，<strong>将事先传递的回调函数包装成任务</strong>，加入到消息队列的末尾排队，等待主线程调度执行。在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240124205355652.png"  alt="image-20240124205355652"></p>
<h1 id="js阻碍渲染"><a href="#js阻碍渲染" class="headerlink" title="js阻碍渲染"></a>js阻碍渲染</h1><p>因为渲染主线程在执行某个js代码时用时过长 导致渲染任务一直在队列 无法执行     react fiber机制</p>
<h1 id="js事件循环机制"><a href="#js事件循环机制" class="headerlink" title="js事件循环机制"></a>js事件循环机制</h1><p>事件循环又叫做消息循环，是浏览器染主线程的工作方式。在 Chrome 的源码中，它<strong>开启一个不会结束的 for 循环</strong>，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。<br>根据 W3C官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p>
<h1 id="JS-中的计时器能做到精确计时吗-为什么"><a href="#JS-中的计时器能做到精确计时吗-为什么" class="headerlink" title="JS 中的计时器能做到精确计时吗? 为什么?"></a>JS 中的计时器能做到精确计时吗? 为什么?</h1><p>1.受事件循环机制，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</p>
<p>2.定时器的最小延迟时间4ms</p>
<h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><p>递归  flat()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">      result = result.<span class="title function_">concat</span>(<span class="title function_">flattenArray</span>(item));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> flattenedArray = <span class="title function_">flattenArray</span>(nestedArray);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flattenedArray);  <span class="comment">// 输出：[1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h1 id="实现发布订阅"><a href="#实现发布订阅" class="headerlink" title="实现发布订阅"></a>实现发布订阅</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="params">eventName, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName].<span class="title function_">push</span>(callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">publish</span>(<span class="params">eventName, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName].<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="params">eventName, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName] = <span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName].<span class="title function_">filter</span>(<span class="function"><span class="params">cb</span> =&gt;</span> cb !== callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback1</span> = data =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Callback 1 received data: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback2</span> = data =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Callback 2 received data: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">subscribe</span>(<span class="string">&quot;event1&quot;</span>, callback1);</span><br><span class="line">eventBus.<span class="title function_">subscribe</span>(<span class="string">&quot;event1&quot;</span>, callback2);</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">publish</span>(<span class="string">&quot;event1&quot;</span>, <span class="string">&quot;Hello, subscribers!&quot;</span>);</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">unsubscribe</span>(<span class="string">&quot;event1&quot;</span>, callback1);</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">publish</span>(<span class="string">&quot;event1&quot;</span>, <span class="string">&quot;After unsubscribing callback1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="OPTIONS请求方法的主要用途有两个"><a href="#OPTIONS请求方法的主要用途有两个" class="headerlink" title="OPTIONS请求方法的主要用途有两个:"></a>OPTIONS请求方法的主要用途有两个:</h1><ol>
<li>获取服务器支持的所有HTTP请求方法，</li>
<li>用来检查访问权限。例如: 在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送<strong>嗅探请求</strong>，以判断是否有对指定资源的访问权限</li>
</ol>
<h1 id="babel的安装和使用"><a href="#babel的安装和使用" class="headerlink" title="babel的安装和使用"></a>babel的安装和使用</h1><h2 id="babel的安装"><a href="#babel的安装" class="headerlink" title="babel的安装"></a>babel的安装</h2><p>babel可以和构建工具联合使用，也可以独立使用</p>
<p>如果要独立的使用babel，需要安装下面两个库：</p>
<ul>
<li>@babel&#x2F;core：babel核心库，提供了编译所需的所有api</li>
<li>@babel&#x2F;cli：提供一个命令行工具，调用核心库的api完成编译</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D @babel/core @babel/cli</span><br></pre></td></tr></table></figure>

<h2 id="babel的使用"><a href="#babel的使用" class="headerlink" title="babel的使用"></a>babel的使用</h2><p>@babel&#x2F;cli的使用极其简单</p>
<p>它提供了一个命令<code>babel</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按文件编译</span></span><br><span class="line">babel 要编译的文件 -o 编辑结果文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按目录编译</span></span><br><span class="line">babel 要编译的整个目录 -d 编译结果放置的目录</span><br></pre></td></tr></table></figure>

<h2 id="babel的配置"><a href="#babel的配置" class="headerlink" title="babel的配置"></a>babel的配置</h2><p>可以看到，babel本身没有做任何事情，真正的编译要依托于<strong>babel插件</strong>和<strong>babel预设</strong>来完成</p>
<blockquote>
<p>babel预设和postcss预设含义一样，是多个插件的集合体，用于解决一系列常见的兼容问题</p>
</blockquote>
<p>如何告诉babel要使用哪些插件或预设呢？需要通过一个配置文件<code>.babelrc</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h1><p>它是一个工具，<strong>预先配置好各种规则</strong>，通过这些规则来自动化的验证代码，甚至自动修复</p>
<ul>
<li><p>如何让所有员工书写高质量的代码？</p>
<p>比如使用<code>===</code>替代<code>==</code></p>
</li>
<li><p>如何让所有员工书写的代码风格保持统一？</p>
<p>比如字符串统一使用单引号</p>
</li>
</ul>
<p>上面两个问题，一个代表着代码的质量，一个代表着代码的风格</p>
<ul>
<li>eslint-config-airbnb</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h4 id="类型检测-快速区分"><a href="#类型检测-快速区分" class="headerlink" title="类型检测 &amp; 快速区分"></a>类型检测 &amp; 快速区分</h4><ol>
<li>JS有几种基础数据类型?几种新增?*<br>JS 8种基础数据类型:  <strong>undefined null boolean number string object   l    symbol bigInt</strong><br>Symbol 独一无二 且 不可变 &#x3D;&gt;全局变量冲突、内部变量覆盖<br>bigInt 任意精度正数 安全地存储和操作大数据，即便超出了number的安全整数范围</li>
</ol>
<h1 id="事件捕获和事件冒泡机制"><a href="#事件捕获和事件冒泡机制" class="headerlink" title="事件捕获和事件冒泡机制"></a>事件捕获和事件冒泡机制</h1><p>事件捕获和事件冒泡是指在页面中触发某个元素上的事件时，事件传播的两种不同方式。</p>
<p>在事件捕获阶段，事件从最外层的元素开始向内部元素传播，直到达到触发事件的最具体的元素。</p>
<p>而在事件冒泡阶段，事件则从触发事件的元素开始向外传播，直到达到最外层的元素</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是指一个函数可以访问其外部函数的作用域中的变量，即使该外部函数已经执行完毕，这些变量仍然保存在内存中，不会被销毁。闭包可以用来模拟私有方法，提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p>
<p>闭包的好处是可以使外部函数的局部变量在函数执行完毕后仍然存在于内存中，可以被内部函数访问和修改，从而实现一些特殊的功能。闭包的坏处是因为闭包的调用最终是赋给了一个全局变量，所以导致它会一直存在于内存中，不会被 JavaScript 的垃圾回收机制回收，从而会影响计算机的性能，更严重点可能会导致内存泄露。闭包的适用场景包括防抖、节流等<a class="link"   href="https://juejin.cn/post/7040647854448197662" >1<i class="fas fa-external-link-alt"></i></a><a class="link"   href="https://blog.csdn.net/lizhengxv/article/details/105936925" >3<i class="fas fa-external-link-alt"></i></a><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" >4<i class="fas fa-external-link-alt"></i></a>。闭包的实现方式有多种，包括返回值、函数赋值、函数参数、IIFE、循环赋值、getter 和 setter、迭代器、区分是否首次的场景、缓存等<a class="link"   href="https://blog.csdn.net/lizhengxv/article/details/105936925" >3<i class="fas fa-external-link-alt"></i></a>。</p>
<h1 id="map-foreach"><a href="#map-foreach" class="headerlink" title="map&amp;foreach"></a>map&amp;foreach</h1><p>数组的map和forEach迭代有什么区别？哪个遍历更快？为什么更快？这两种迭代能不能中断</p>
<p><code>map</code> 和 <code>forEach</code> 是 JavaScript 中用于迭代数组的两种方法。它们之间有以下区别：</p>
<ol>
<li>返回值：<code>map</code> 方法返回一个新数组，该数组包含对原始数组中的每个元素应用回调函数后的结果。而 <code>forEach</code> 方法没有返回值，它只是对数组中的每个元素执行指定的回调函数，用于遍历数组并进行操作。</li>
<li>可变性：<code>map</code> 不会改变原始数组，并且会返回一个新的数组，而 <code>forEach</code> 会改变原始数组，返回值为 <code>undefined</code>。</li>
<li>速度：关于性能速度，它们有所不同，但具体取决于各种因素，例如计算机、处理的数据量等。一些测试显示 <code>map</code> 更快，而另一些测试显示 <code>forEach</code> 更快。在现代 Web 开发中，不必过分纠结这一点速度，因为它们都比传统的 <code>for</code> 循环慢。</li>
<li>中断：<code>forEach</code> 不能中断或跳出循环，而 <code>map</code> 可以通过 <code>return</code> 来提前结束循环。</li>
</ol>
<p>综上所述，<code>map</code> 和 <code>forEach</code> 各有各的优势，主要取决于你想要做什么。如果你想基于一个原数组返回一个新数组，可以选择 <code>map</code>；如果你只是想遍历数据而不需要考虑返回，可以选择 <code>forEach</code>。</p>
<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><p>浅拷贝：1.直接赋值  2.const copied &#x3D; { …original }  3.Object.assign() -&gt; const copied &#x3D; Object.assign({}, original);</p>
<p>​				4.slice  5.concat  6.jQuery中的 $.extend </p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240117193528704.png"  alt="image-20240117193528704"></p>
<p>深拷贝：1.JSON.parse(JSON.stringify(obj))  缺陷：会丢失原对象的方法 </p>
<p>​				2.jQuery中的$.extend</p>
<p>​				3.递归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Json-stringfy有什么弊端"><a href="#Json-stringfy有什么弊端" class="headerlink" title="Json.stringfy有什么弊端"></a>Json.stringfy有什么弊端</h3><ul>
<li>无法处理循环引用</li>
<li>不支持特定的数据类型</li>
<li>丢失对象的原型链和方法</li>
<li>性能问题：在处理大量对象或者深层嵌套对象的时候，可能会消耗大量的时间和内存</li>
</ul>
<h1 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h1><ol>
<li><p>Let和Const关键字；</p>
</li>
<li><p>解构表达式</p>
<ul>
<li>数组解构</li>
<li>对象解构</li>
</ul>
</li>
<li><p>字符串扩展</p>
<ul>
<li><p>新的API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">includes</span>()：返回布尔值，表示是否找到了参数字符串。</span><br><span class="line"><span class="title function_">startsWith</span>()：返回布尔值，表示参数字符串是否在原字符串的头部。</span><br><span class="line"><span class="title function_">endsWith</span>()：返回布尔值，表示参数字符串是否在原字符串的尾部。</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串模板</p>
</li>
</ul>
</li>
<li><p>函数优化</p>
<ul>
<li><p>函数参数默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//现在可以这么写：直接给参数写上默认值，没传就会自动使用默认值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add2</span>(<span class="params">a , b = <span class="number">1</span></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传一个参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add2</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>不定参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">...values</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(values.<span class="property">length</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">//2</span></span><br><span class="line"><span class="title function_">fun</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数</p>
</li>
</ul>
</li>
<li><p>对象优化</p>
<ul>
<li><p>新增API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ES6</span> 给 <span class="title class_">Object</span> 拓展了许多新的方法，如：</span><br><span class="line">- <span class="title function_">keys</span>(obj)：获取对象的所有 key 形成的数组</span><br><span class="line">- <span class="title function_">values</span>(obj)：获取对象的所有 value 形成的数组</span><br><span class="line">- <span class="title function_">entries</span>(obj)：获取对象的所有 key 和 value 形成的二维数组。格式：<span class="string">`[[k1,v1],[k2,v2],...]`</span> - <span class="title function_">assign</span>(dest, ...src) ：将多个 src 对象的值 拷贝到 dest 中。（第一层为深拷贝，第二层为浅</span><br><span class="line">拷贝）</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line"><span class="attr">language</span>: [<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;css&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(person));<span class="comment">//[&quot;name&quot;, &quot;age&quot;, &quot;language&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(person));<span class="comment">//[&quot;jack&quot;, 21, Array(3)]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(person));<span class="comment">//[Array(2), Array(2), Arra</span></span><br><span class="line"><span class="title function_">y</span>(<span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="comment">//Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target)<span class="comment">//&#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明对象简写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">23</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="comment">// 传统</span></span><br><span class="line"><span class="keyword">const</span> person1 = &#123; <span class="attr">age</span>: age, <span class="attr">name</span>: name &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1)</span><br><span class="line"><span class="comment">// ES6：属性名和属性值变量名一样，可以省略</span></span><br><span class="line"><span class="keyword">const</span> person2 = &#123; age, name &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2) <span class="comment">//&#123;age: 23, name: &quot;张三&quot;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的函数属性简写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line"><span class="comment">// 以前：</span></span><br><span class="line"><span class="attr">eat</span>: <span class="keyword">function</span> (<span class="params">food</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;在吃&quot;</span> + food);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 箭头函数版：这里拿不到 this</span></span><br><span class="line"><span class="attr">eat2</span>: <span class="function"><span class="params">food</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span> + <span class="string">&quot;在吃&quot;</span> + food),</span><br><span class="line"><span class="comment">// 简写版：</span></span><br><span class="line"><span class="title function_">eat3</span>(<span class="params">food</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;在吃&quot;</span> + food);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">eat</span>(<span class="string">&quot;apple&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象拓展运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">拓展运算符（...）用于取出参数对象所有可遍历属性然后拷贝到当前对象。</span><br><span class="line"><span class="comment">// 1、拷贝对象（深拷贝）</span></span><br><span class="line"><span class="keyword">let</span> person1 = &#123; <span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>, <span class="attr">age</span>: <span class="number">15</span> &#125;</span><br><span class="line"><span class="keyword">let</span> someone = &#123; ...person1 &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(someone) <span class="comment">//&#123;name: &quot;Amy&quot;, age: 15&#125;</span></span><br><span class="line"><span class="comment">// 2、合并对象</span></span><br><span class="line"><span class="keyword">let</span> age = &#123; <span class="attr">age</span>: <span class="number">15</span> &#125;</span><br><span class="line"><span class="keyword">let</span> name = &#123; <span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> person2 = &#123; ...age, ...name &#125; <span class="comment">//如果两个对象的字段名重复，后面对象字段值会覆盖前面对象的字段值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2) <span class="comment">//&#123;age: 15, name: &quot;Amy&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>map&amp;reduce</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">map</span>()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;-5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">arr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">s</span> =&gt;</span> <span class="built_in">parseInt</span>(s));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">reduce</span>(callback,[initialValue])</span><br><span class="line">reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元</span><br><span class="line">素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调</span><br><span class="line">用 reduce 的数组。</span><br><span class="line">callback （执行数组中每个值的函数，包含四个参数）</span><br><span class="line"><span class="number">1</span>、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））</span><br><span class="line"><span class="number">2</span>、currentValue （数组中当前被处理的元素）</span><br><span class="line"><span class="number">3</span>、index （当前元素在数组中的索引）</span><br><span class="line"><span class="number">4</span>、array （调用 reduce 的数组）</span><br><span class="line">initialValue （作为第一次调用 callback 的第一个参数。）</span><br><span class="line">示例：</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">20</span>,-<span class="number">5</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//没有初始值：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b));<span class="comment">//19</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a*b));<span class="comment">//-300</span></span><br><span class="line"><span class="comment">//指定初始值：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b,<span class="number">1</span>));<span class="comment">//20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a*b,<span class="number">0</span>));<span class="comment">//-0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise</p>
<p>Promise是JavaScript中的一个对象，它代表了一个异步操作的最终完成或者失败<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" >4<i class="fas fa-external-link-alt"></i></a>。Promise可以用于解决回调地狱的问题，通过Promise对象可以将异步操作以链式调用的方式组织起来，使得代码更加可读性更高<a class="link"   href="https://juejin.cn/post/7063628439864999944" >2<i class="fas fa-external-link-alt"></i></a>。Promise对象有三种状态：pending（等待中）、fulfilled（已成功）和rejected（已失败）<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" >4<i class="fas fa-external-link-alt"></i></a>。当Promise对象的状态从pending变为fulfilled或rejected时，会触发then()方法中对应的回调函数</p>
<ul>
<li><a class="link"   href="https://juejin.cn/post/7063628439864999944" >https://juejin.cn/post/7063628439864999944<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
<li><p>模块化</p>
</li>
</ol>
<p>​		import export</p>
<p>​	9.ES6新特性：</p>
<ol>
<li><strong>let 和 const</strong>: 提供块级作用域绑定，<code>let</code>用于声明变量，<code>const</code>用于声明常量。</li>
<li><strong>箭头函数</strong> (<code>=&gt;</code>): 提供了一种更简洁的函数编写方式，并且解决了<code>this</code>关键字的一些常见问题。</li>
<li><strong>模板字符串</strong>: 使用反引号（&#96;&#96;&#96;）标示，它可以定义多行字符串和嵌入变量。</li>
<li><strong>默认参数值</strong>: 在函数中直接给参数赋予默认值。</li>
<li><strong>解构赋值</strong>: 对象和数组解构让批量赋值更简单。</li>
<li><strong>扩展运算符</strong> (<code>...</code>): 允许数组和对象字面量在无需循环的情况下扩展或合并。</li>
<li><strong>类</strong> (<code>class</code>): 引入了面向对象编程中类的概念，更容易实现对象的继承和复用。</li>
<li><strong>模块化</strong> (<code>import</code> &#x2F; <code>export</code>): 原生的模块化支持，可以导出和导入函数、变量等。</li>
<li><strong>Promises</strong>: 为JavaScript提供了原生的异步编程解决方案。</li>
<li><strong>迭代器</strong> (<code>Iterator</code>) 和 <strong>for…of</strong> 循环: 提供了遍历所有数据结构的统一方式。</li>
<li><strong>生成器</strong> (<code>function*</code>): 生成器函数可以通过<code>yield</code>关键字暂停执行，有助于处理异步操作和迭代器。</li>
<li><strong>集合</strong> (<code>Set</code>) 和 <strong>映射</strong> (<code>Map</code>): 新的数据结构用于存储唯一值的集合和键值对集合。</li>
<li><strong>新的内置方法</strong>: 如数组的<code>Array.from</code>、<code>Array.of</code>、<code>find</code>、<code>findIndex</code>等方法，对象的<code>Object.assign</code>等。</li>
<li><strong>Proxy 和 Reflect</strong>: 新的元编程特性，用于创建对象的代理以控制对象的行为，Reflect对象提供了一套用于操作对象的API。</li>
<li><strong>Symbols</strong>: 新的原始数据类型用于创建唯一的标识符。</li>
<li><strong>尾调用优化</strong>: 对尾递归函数进行优化，节省内存。</li>
</ol>
<h1 id="call-apply-bind区别"><a href="#call-apply-bind区别" class="headerlink" title="call apply bind区别"></a>call apply bind区别</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">call 和 apply 立即调用函数，而 bind 返回一个新的函数。</span><br><span class="line">call 和 apply 的参数列表不同，call 是逐个列举参数，而 apply 使用数组传递参数。</span><br><span class="line">bind 不会立即调用函数，而是返回一个新的函数，可以稍后调用</span><br></pre></td></tr></table></figure>

<h1 id="原型链的作用"><a href="#原型链的作用" class="headerlink" title="原型链的作用"></a>原型链的作用</h1><ol>
<li><strong>实现继承：</strong> 在JavaScript中，继承主要依赖于原型和原型链。子构造函数的实例可以继承父构造函数原型上的方法和属性。这意味着我们可以定义一个通用方法或属性在一个对象的原型上，让所有通过该构造函数创建的实例都可以访问它们，而不必在每个实例上重复定义。</li>
<li><strong>属性查找机制（属性解析）：</strong> 当访问对象上的一个属性或方法时，JavaScript首先会在对象自身上寻找这个属性。如果没有找到，它会沿着原型链向上查找，一直到<code>Object.prototype</code>，这是原型链的顶端。如果在原型链上仍然没有找到该属性，则返回<code>undefined</code>。</li>
<li><strong>共享方法：</strong> 利用原型链，多个实例可以共享原型对象上的方法，而不是在每个实例上都创建一个新的方法副本。这有助于减少内存的使用。</li>
<li><strong>创建动态方法：</strong> 如果你在程序运行时向一个构造函数的原型添加方法或属性，那么所有通过这个构造函数创建的实例——无论是在添加之前还是之后创建的——都将可以访问那个新增的方法或属性</li>
</ol>
<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><ol>
<li>创建对象</li>
<li>设置函数原型prototype对象</li>
<li>执行构造函数 为这个新对象添加属性</li>
<li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</li>
</ol>
<h1 id="异步场景解决方案"><a href="#异步场景解决方案" class="headerlink" title="异步场景解决方案"></a>异步场景解决方案</h1><p>io流操作都是异步的 异步场景 </p>
<p>1.返回一个promise</p>
<p>2.提供回调事件</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2023/03/09/2023/promise/</url>
    <content><![CDATA[<h1 id="100行实现promise"><a href="#100行实现promise" class="headerlink" title="100行实现promise"></a>100行实现promise</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isFunction</span> = (<span class="params">obj</span>) =&gt; <span class="keyword">typeof</span> obj === <span class="string">&quot;function&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isObject</span> = (<span class="params">obj</span>) =&gt; !!(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isThenable</span> = (<span class="params">obj</span>) =&gt; (<span class="title function_">isFunction</span>(obj) || <span class="title function_">isObject</span>(obj)) &amp;&amp; <span class="string">&quot;then&quot;</span> <span class="keyword">in</span> obj;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isPromise</span> = (<span class="params">promise</span>) =&gt; promise <span class="keyword">instanceof</span> <span class="title class_">Promise</span>;</span><br><span class="line"><span class="keyword">const</span> nextTick = queueMicrotask || <span class="built_in">setTimeout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  result = <span class="literal">null</span>;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span>;</span><br><span class="line">  callbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">onFulfilled</span> = (<span class="params">value</span>) =&gt; <span class="variable language_">this</span>.#<span class="title function_">transition</span>(<span class="variable constant_">FULFILLED</span>, value);</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">onRejected</span> = (<span class="params">reason</span>) =&gt; <span class="variable language_">this</span>.#<span class="title function_">transition</span>(<span class="variable constant_">REJECTED</span>, reason);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ignore = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (ignore) <span class="keyword">return</span>;</span><br><span class="line">      ignore = <span class="literal">true</span>;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">resolvePromise</span>(value, onFulfilled, onRejected);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (ignore) <span class="keyword">return</span>;</span><br><span class="line">      ignore = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">onRejected</span>(reason);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> callback = &#123; onFulfilled, onRejected, resolve, reject &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(callback);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="title function_">handleCallback</span>(callback, <span class="variable language_">this</span>.<span class="property">state</span>, <span class="variable language_">this</span>.<span class="property">result</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">transition</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result;</span><br><span class="line">    <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="property">length</span>)</span><br><span class="line">        <span class="title function_">handleCallback</span>(<span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">shift</span>(), state, result);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">resolvePromise</span>(<span class="params">result, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result === <span class="variable language_">this</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Can not fulfill promise with itself&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isPromise</span>(result)) &#123;</span><br><span class="line">      <span class="keyword">return</span> result.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isThenable</span>(result)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> then = result.<span class="property">then</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isFunction</span>(then)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(then.<span class="title function_">bind</span>(result)).<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">resolve</span>(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleCallback</span> = (<span class="params">callback, state, result</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; onFulfilled, onRejected, resolve, reject &#125; = callback;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="title function_">isFunction</span>(onFulfilled) ? <span class="title function_">resolve</span>(<span class="title function_">onFulfilled</span>(result)) : <span class="title function_">resolve</span>(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="title function_">isFunction</span>(onRejected) ? <span class="title function_">resolve</span>(<span class="title function_">onRejected</span>(result)) : <span class="title function_">reject</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resolved</span> = (<span class="params">value</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(value));</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">rejected</span> = (<span class="params">reason</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">_, reject</span>) =&gt;</span> <span class="title function_">reject</span>(reason));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">deferred</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> promise, resolve, reject;</span><br><span class="line">  promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">$resolve, $reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve = $resolve;</span><br><span class="line">    reject = $reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123; promise, resolve, reject &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; resolved, rejected, deferred &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a class="link"   href="https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g" >https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://github.com/Lucifier129/promise-aplus-impl/blob/master/src/naive.js" >https://github.com/Lucifier129/promise-aplus-impl/blob/master/src/naive.js<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="用promise封装ajax请求"><a href="#用promise封装ajax请求" class="headerlink" title="用promise封装ajax请求"></a>用promise封装ajax请求</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url, method, data</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line">        xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="title class_">XMLHttpRequest</span>.<span class="property">DONE</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Request failed with status <span class="subst">$&#123;xhr.status&#125;</span>`</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Request failed&#x27;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>, &#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Success:&#x27;</span>, response);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>executor函数:  执行器  (resolve, reject) &#x3D;&gt; {}</p>
<p>resolve函数: 内部定义成功时我们调用的函数 value &#x3D;&gt; {}</p>
<p>reject函数: 内部定义失败时我们调用的函数 reason &#x3D;&gt; {}</p>
<p>executor会在Promise内部立即同步调用,异步操作在执行器中执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将主要的代码执行功能的直接放在这里</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//成功就调resolve</span></span><br><span class="line">    <span class="comment">//失败就调reject</span></span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">log</span>(value);</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">log</span>(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>静态方法: then catch finally all allsettled race any</p>
<h1 id="面试题考点"><a href="#面试题考点" class="headerlink" title="面试题考点"></a>面试题考点</h1><h2 id="Promise的基本概念"><a href="#Promise的基本概念" class="headerlink" title="Promise的基本概念"></a>Promise的基本概念</h2><p><img   src="/../images/promise/20210618161125.png"  alt="image-20210618161125894"></p>
<h2 id="链式调用规则"><a href="#链式调用规则" class="headerlink" title="链式调用规则"></a>链式调用规则</h2><p><img   src="/../images/propmise/20210621103501.png"  alt="image-20210621103501094"></p>
<p><img   src="/../images/propmise/20210621103501.png"  alt="image-20210621103501094"></p>
<ol>
<li><p>then方法必定会返回一个新的Promise</p>
<p>可理解为<code>后续处理也是一个任务</code></p>
</li>
<li><p>新任务的状态取决于后续处理：</p>
<ul>
<li><p>若没有相关的后续处理，新任务的状态和前任务一致，数据为前任务的数据</p>
</li>
<li><p>若有后续处理但还未执行，新任务挂起。</p>
</li>
<li><p>若后续处理执行了，则根据后续处理的情况确定新任务的状态</p>
<ul>
<li>后续处理执行无错，新任务的状态为完成，数据为后续处理的返回值</li>
<li>后续处理执行有错，新任务的状态为失败，数据为异常对象</li>
<li>后续执行后返回的是一个任务对象，新任务的状态和数据与该任务对象一致</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Promise的静态方法"><a href="#Promise的静态方法" class="headerlink" title="Promise的静态方法"></a>Promise的静态方法</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Promise.resolve(data)</td>
<td>直接返回一个完成状态的任务</td>
</tr>
<tr>
<td>Promise.reject(reason)</td>
<td>直接返回一个拒绝状态的任务</td>
</tr>
<tr>
<td>Promise.all(任务数组)</td>
<td>返回一个任务<br />任务数组全部成功则成功<br />任何一个失败则失败</td>
</tr>
<tr>
<td>Promise.any(任务数组)</td>
<td>返回一个任务<br />任务数组任一成功则成功<br />任务全部失败则失败</td>
</tr>
<tr>
<td>Promise.allSettled(任务数组)</td>
<td>返回一个任务<br />任务数组全部已决则成功<br />该任务不会失败</td>
</tr>
<tr>
<td>Promise.race(任务数组)</td>
<td>返回一个任务<br />任务数组任一已决则已决，状态和其一致</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><p>有了Promise，异步任务就有了一种统一的处理方式</p>
<p>有了统一的处理方式，ES官方就可以对其进一步优化</p>
<p>ES7推出了两个关键字<code>async</code>和<code>await</code>，用于更加优雅的表达Promise</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async关键字用于修饰函数，被它修饰的函数，一定返回Promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">method1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 该函数的返回值是Promise完成后的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">method1</span>(); <span class="comment">// Promise &#123; 1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">method2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>); <span class="comment">// 若返回的是Promise，则method得到的Promise状态和其一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">method2</span>(); <span class="comment">// Promise &#123; 1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">method3</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="number">1</span>); <span class="comment">// 若执行过程报错，则任务是rejected</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">method3</span>(); <span class="comment">// Promise &#123; &lt;rejected&gt; Error(1) &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p><code>await</code>关键字表示等待某个Promise完成，<strong>它必须用于<code>async</code>函数中</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">method</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的函数等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">method</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>await</code>也可以等待其他数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">method</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="number">1</span>; <span class="comment">// 等同于 await Promise.resolve(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要针对失败的任务进行处理，可以使用<code>try-catch</code>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">method</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">123</span>); <span class="comment">// 这句代码将抛出异常</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>, n)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">method</span>(); <span class="comment">// 输出： 失败 123</span></span><br></pre></td></tr></table></figure>

<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>根据目前所学，进入事件队列的函数有以下几种：</p>
<ul>
<li><code>setTimeout</code>的回调，宏任务（macro task）</li>
<li><code>setInterval</code>的回调，宏任务（macro task）</li>
<li>Promise的<code>then</code>函数回调，<strong>微任务</strong>（micro task）</li>
<li><code>requestAnimationFrame</code>的回调，宏任务（macro task）</li>
<li>事件处理函数，宏任务(macro task)</li>
</ul>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ol>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); </span><br><span class="line">    <span class="title function_">resolve</span>(); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">      <span class="title function_">resolve</span>(); </span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2) </span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1) </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2) </span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">m</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//2 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="title function_">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">m</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//3 1 2</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="title function_">m1</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m3</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="title function_">m2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">//返回得是上一步得promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">m3</span>().<span class="title function_">then</span>(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">m3</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关键看有没有await关键字 如果有await后面得代码不执行 没有就会运行后面得</span></span><br><span class="line"><span class="comment">//promise&#123;pending&#125;</span></span><br><span class="line"><span class="comment">//promise&#123;pending&#125;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240310202316466.png"  alt="image-20240310202316466"></p>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="number">2</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//then里面只能传函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise3&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise4&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title function_">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">await</span> b;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after1&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> a;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line"></span><br><span class="line">promise1</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">end</span><br><span class="line">promise2</span><br><span class="line">promise3</span><br><span class="line">promise4</span><br><span class="line"><span class="title class_">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line">after1</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();   <span class="comment">//await 后面得代码会执行 别忘了</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">p1</span>: fulfilled</span><br><span class="line"></span><br><span class="line">微队列: </span><br><span class="line">宏队列: set1</span><br><span class="line"></span><br><span class="line">ss</span><br><span class="line">ay1 st</span><br><span class="line">a2</span><br><span class="line">p1</span><br><span class="line">se</span><br><span class="line">ae</span><br><span class="line">p2</span><br><span class="line">set</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>typora破解方法</title>
    <url>/2023/04/09/2023/typora/</url>
    <content><![CDATA[<h1 id="window"><a href="#window" class="headerlink" title="window"></a>window</h1><p>todo</p>
<h1 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h1><h2 id="下载-安装"><a href="#下载-安装" class="headerlink" title="下载&amp;安装"></a>下载&amp;安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.typoraio.cn/</span><br></pre></td></tr></table></figure>

<h2 id="修改文件内容"><a href="#修改文件内容" class="headerlink" title="修改文件内容"></a>修改文件内容</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Applications/Typora.app/Contents/Resources/TypeMark/page-dist/static/js/LicenseIndex.180dd4c7.6d698c41.chunk.js</span><br><span class="line"></span><br><span class="line">打开查找替换ctrl + shift + f ，查找hasActivated=&quot;true&quot;==e.hasActivated替换为hasActivated=&quot;true&quot;==&quot;true&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>实用软件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>设置在控制台快速用webstorm启动项目</title>
    <url>/2023/05/23/2023/webstorm/</url>
    <content><![CDATA[<h1 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim .zshrc</span><br><span class="line"></span><br><span class="line">alias ws=&quot;/Applications/WebStorm.app/Contents/MacOS/webstorm&quot;</span><br><span class="line"></span><br><span class="line">source .zshrc || . .zshrc</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>实用软件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>正则学习记录</title>
    <url>/2023/11/09/2023/%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<p><strong>?</strong> 问号代表前面的字符最多只可以出现一次（0次或1次）</p>
<p><strong>+</strong> 号代表前面的字符必须至少出现一次（1次或多次）</p>
<p>***** 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次)</p>
<p>[abc] </p>
<p>[^abc]</p>
<p>[a-z]</p>
<p><strong>.</strong> 匹配除换行符的所有字符</p>
<p><strong>\w</strong>  匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</p>
<p><strong>\d</strong>  匹配任意一个阿拉伯数字（0 到 9）等价于 <strong>[0-9]</strong></p>
<p>( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )</p>
<p>贪婪：.*</p>
<p>非贪婪：.*?</p>
<p>限定符</p>
<p>有 ***** 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p>
<p>定位符</p>
<p>^ :  匹配输入字符串开始的位置。</p>
<p>**$**： 匹配一行文本的结束处的文本</p>
<p>&#x2F;&#x2F;i 忽略大小写</p>
<p>&#x2F;&#x2F;g匹配全局 多次</p>
<p><code>replace()</code> 替换多次的唯一情况是传入带有 <code>g</code> 标志的正则表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;get-element-by-id&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/-([a-z])/g</span>, <span class="keyword">function</span> (<span class="params">match, letter</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(letter)</span><br><span class="line">        <span class="keyword">return</span> letter.<span class="title function_">toUpperCase</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240219110951011.png"  alt="image-20240219110951011"></p>
<p>split</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abc12de&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">splitAndCapitalize</span>(<span class="params">str</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> parts = str.<span class="title function_">split</span>(<span class="regexp">/(\d+)/</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(parts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">splitAndCapitalize</span>(str)</span><br></pre></td></tr></table></figure>

<p>match</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string  split   match 如果使用 g 标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组</span></span><br><span class="line"><span class="comment">// Array   join   splice替换   slice截取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;The quick brown\&#x27;s fox jumps over the lazy dog.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findLongestWord</span>(<span class="params">str</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> match = str.<span class="title function_">match</span>(<span class="regexp">/\w+[&#x27;-]?\w*!/g</span>);x</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; match.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(match[i].<span class="property">length</span> &gt; res.<span class="property">length</span>)&#123;</span><br><span class="line">            res = match[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// console.log(match)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="title function_">findLongestWord</span>(str)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br></pre></td></tr></table></figure>

<p>repeat函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String.prototype.getRepeat = function (count) &#123;</span></span><br><span class="line"><span class="comment">//     if (count &lt; 0) &#123;</span></span><br><span class="line"><span class="comment">//         throw new RangeError(&#x27;error&#x27;)</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return new Array(count + 1).join(this)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>js 编译过程</title>
    <url>/2024/08/20/2024/ast/</url>
    <content><![CDATA[<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>词法分析的原因很简单，需要先把字符串分割成<code>token</code>数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>关键字<code>const</code>。</li>
<li>自定义的变量名<code>a</code>。</li>
<li>变量的值<code>1</code>。</li>
<li>符号，<code>=</code>和<code>;</code>。</li>
<li>处理空格换行字符<code>&#39; &#39;, \t , \n , \r</code></li>
</ol>
<h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>语法分析的目的是遍历词法分析的<code>Token</code>数组，根据语言的语法规则，将<code>Token</code>组合成各类语法节点。</p>
<p>因为不同的语法节点需要不同的处理方式，所以需要进行分类，一般可以分为：</p>
<ol>
<li>Literal字面量，表示值</li>
<li>Identifier标识符，其中变量名，属性名，参数名等都属于标识符</li>
<li>Statement语句，表示可以独立执行的最小单元，比如reture,break,if(){},for(const item of list){}等</li>
<li>Declaration声明语句，语句的一种特殊类型，在作用域内声明一个变量，比如class a{},let a &#x3D; 1,function a(){}</li>
<li>Expression表达式，也是一种特殊的语句，特点是执行完后有返回值</li>
</ol>
<p>比如我们可以通过分析声明语句(Declaration)和表达式(Expression)，判断变量是否被使用过，从而实现tree shaking。</p>
<p>所以语法分析的关键是：</p>
<p>根据语言的规则，定义合适的语法节点<br>将Token数组转化成语法节点</p>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>在对AST节点进行操作中使用到</p>
<p>最直接的修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ast.<span class="property">body</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">node</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">type</span> === <span class="string">&#x27;VariableDeclaration&#x27;</span> &amp;&amp; node.<span class="property">kind</span> !== <span class="string">&#x27;var&#x27;</span>)&#123;</span><br><span class="line">        node.<span class="property">kind</span> = <span class="string">&#x27;var&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正常的做法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">walk</span>(<span class="params"></span></span><br><span class="line"><span class="params">  ast: Statement,</span></span><br><span class="line"><span class="params">  &#123; enter, leave &#125;: &#123; enter: WalkOperate; leave: WalkOperate &#125;,</span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="title function_">visit</span>(ast, <span class="literal">undefined</span>, enter, leave)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a class="link"   href="https://juejin.cn/post/7230257136702111800#heading-0" >https://juejin.cn/post/7230257136702111800#heading-0<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack</title>
    <url>/2023/05/09/2023/webpack/</url>
    <content><![CDATA[<h1 id="webpack核心功能和性能优化"><a href="#webpack核心功能和性能优化" class="headerlink" title="webpack核心功能和性能优化"></a><a class="link"   href="https://webpack.docschina.org/guides" >webpack<i class="fas fa-external-link-alt"></i></a>核心功能和性能优化</h1><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p><img   src="/../images/webpack/1741094588163.png" ><br><img   src="/../images/webpack/1741094704691.png" ></p>
<h2 id="编译结果分析"><a href="#编译结果分析" class="headerlink" title="编译结果分析"></a>编译结果分析</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并两个模块</span></span><br><span class="line"><span class="comment">//  ./src/a.js</span></span><br><span class="line"><span class="comment">//  ./src/index.js</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">modules</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> moduleExports = &#123;&#125;; <span class="comment">//用于缓存模块的导出结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//require函数相当于是运行一个模块，得到模块导出结果</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">__webpack_require</span>(<span class="params">moduleId</span>) &#123; <span class="comment">//moduleId就是模块的路径</span></span><br><span class="line">        <span class="keyword">if</span> (moduleExports[moduleId]) &#123;</span><br><span class="line">            <span class="comment">//检查是否有缓存</span></span><br><span class="line">            <span class="keyword">return</span> moduleExports[moduleId];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> func = modules[moduleId]; <span class="comment">//得到该模块对应的函数</span></span><br><span class="line">        <span class="keyword">var</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">            <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">func</span>(<span class="variable language_">module</span>, <span class="variable language_">module</span>.<span class="property">exports</span>, __webpack_require); <span class="comment">//运行模块</span></span><br><span class="line">        <span class="keyword">var</span> result = <span class="variable language_">module</span>.<span class="property">exports</span>; <span class="comment">//得到模块导出的结果</span></span><br><span class="line">        moduleExports[moduleId] = result; <span class="comment">//缓存起来</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行入口模块</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">__webpack_require</span>(<span class="string">&quot;./src/index.js&quot;</span>); <span class="comment">//require函数相当于是运行一个模块，得到模块导出结果</span></span><br><span class="line">&#125;)(&#123; <span class="comment">//该对象保存了所有的模块，以及模块对应的代码</span></span><br><span class="line">    <span class="string">&quot;./src/a.js&quot;</span>: <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span>, <span class="built_in">exports</span></span>) &#123;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">&quot;console.log(\&quot;module a\&quot;)\nmodule.exports = \&quot;a\&quot;;\n //# sourceURL=webpack:///./src/a.js&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;./src/index.js&quot;</span>: <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span>, <span class="built_in">exports</span>, __webpack_require</span>) &#123;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">&quot;console.log(\&quot;index module\&quot;)\nvar a = __webpack_require(\&quot;./src/a.js\&quot;)\na.abc();\nconsole.log(a)\n //# sourceURL=webpack:///./src/index.js&quot;</span>)</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader本质上是一个函数，它的作用是将某个源码字符串转换成另一个源码字符串返回。</p>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>plugin的<strong>本质</strong>是一个带有apply方法的对象    监听事件 事件触发做指定的事情</p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>加快了应用的初始加载速度，减轻了它的总体体积</p>
<h1 id="webpack打包优化"><a href="#webpack打包优化" class="headerlink" title="webpack打包优化"></a>webpack打包优化</h1><ol>
<li>优化loader</li>
<li>happypack 并行打包</li>
<li>dllplugin 提前打包</li>
<li>scope hoisting 合并代码</li>
<li>tree shaking 删除代码</li>
</ol>
<h1 id="vite热更新怎么实现的"><a href="#vite热更新怎么实现的" class="headerlink" title="vite热更新怎么实现的"></a>vite热更新怎么实现的</h1><p>Vite是一个现代化的前端开发与打包工具，它通过利用原生ES模块的特性实现了极快的服务器启动和热模块替换（Hot Module Replacement, HMR）。Vite的HMR实现依赖于以下几个关键点：</p>
<ol>
<li><strong>原生ES模块导入</strong>：Vite使用原生ES模块（ESM）来加载模块，这意味着它不需要对代码进行预打包，各个模块都是按需加载的。这使得启动速度非常快。</li>
<li><strong>WebSocket连接</strong>：Vite在开发服务器和客户端之间建立WebSocket连接，用于实时通信。服务器监测文件的变化，并且通过WebSocket通知客户端进行更新。</li>
<li><strong>文件系统监听</strong>：Vite使用文件系统监听工具（例如<code>chokidar</code>）来监视工作目录下所有文件的变化。一旦检测到文件变化，Vite将重新加载被修改的模块和依赖该模块的链路。</li>
<li><strong>模块热替换</strong>：Vite会发送一个HMR更新到客户端，客户端收到更新后，会清除相关模块的缓存并重新请求该模块。因为使用了ESM，浏览器会重新获取更新的模块并执行代码。</li>
<li><strong>状态保持</strong>：对于支持HMR API的模块（即在其代码中处理了<code>module.hot</code>接口的模块），Vite不仅会重新加载代码，还会尝试保持应用状态，例如组件的状态。这个过程需要开发者的配合，通过编写HMR接口的处理代码来实现。</li>
<li><strong>插件支持</strong>：Vite允许通过插件来扩展HMR功能。开发者可以自行编写HMR兼容的代码，或者使用第三方插件，实现特定框架或库的HMR集成</li>
</ol>
<h1 id="vite-webpack区别"><a href="#vite-webpack区别" class="headerlink" title="vite webpack区别"></a>vite webpack区别</h1><p>Vite 和 Webpack 是现代前端开发中常用的两个构建工具，它们在设计理念、实现方式以及性能表现上存在一些区别：</p>
<ol>
<li><p><strong>构建速度</strong>：</p>
<ul>
<li>Vite 在开发环境下提供了极快的服务器启动和热更新速度，因为它利用了浏览器的原生 ES 模块导入（ESM）能力，不需要打包整个项目，而是按需编译[^34^][^37^]。</li>
<li>Webpack 在启动时需要分析项目所有依赖并打包，因此启动速度相对较慢，随着项目规模的增长，这个时间可能会显著增加[^36^][^37^]。</li>
</ul>
</li>
<li><p><strong>打包原理</strong>：</p>
<ul>
<li>Vite 在开发环境中不生成捆绑包，而是提供一个开发服务器，当请求模块时，动态地构建并服务于浏览器[^37^]。</li>
<li>Webpack 通过 loader 和 plugin 系统处理项目资源，将它们打包成一个或多个 bundle，适用于生产环境[^36^][^43^]。</li>
</ul>
</li>
<li><p><strong>生产环境</strong>：</p>
<ul>
<li>Vite 在生产环境中使用 Rollup 进行打包，因为 Rollup 生成的文件更小，且插件生态更为完善[^34^]。</li>
<li>Webpack 同样适用于生产环境，提供了丰富的优化选项，如代码分割、压缩等[^43^]。</li>
</ul>
</li>
<li><p><strong>生态系统和插件</strong>：</p>
<ul>
<li>Webpack 拥有一个庞大的生态系统，有大量的 loader 和 plugin 可用于扩展功能[^36^][^43^]。</li>
<li>Vite 作为一个较新的工具，其生态系统正在迅速增长，提供了一些内置功能，同时也支持第三方插件[^34^]。</li>
</ul>
</li>
<li><p><strong>配置复杂度</strong>：</p>
<ul>
<li>Webpack 的配置相对复杂，需要手动配置许多选项来满足项目需求[^36^][^43^]。</li>
<li>Vite 旨在降低配置的复杂度，提供了许多开箱即用的功能，使得项目配置更为简洁[^34^][^36^]。</li>
</ul>
</li>
<li><p><strong>性能优化</strong>：</p>
<ul>
<li>Vite 利用 ESbuild 进行预构建依赖，ESbuild 用 Go 语言编写，性能优于基于 Node.js 的 Webpack[^37^]。</li>
<li>Webpack 5 开始引入持久化缓存等优化措施，提高构建性能[^40^]。</li>
</ul>
</li>
<li><p><strong>热更新（HMR）</strong>：</p>
<ul>
<li>Vite 的热更新非常快速，因为它只更新变更的部分，不需要重新编译整个项目[^34^]。</li>
<li>Webpack 也支持热更新，但在大型项目中，热更新的性能可能不如 Vite[^36^]。</li>
</ul>
</li>
<li><p><strong>浏览器支持</strong>：</p>
<ul>
<li>Vite 需要现代浏览器支持 ESM，且不能识别 CommonJS 语法[^37^]。</li>
<li>Webpack 支持多种模块类型，包括 ESM 和 CommonJS，兼容性更广[^43^]。</li>
</ul>
</li>
</ol>
<p>综上所述，Vite 和 Webpack 各有优势，选择哪个工具取决于项目需求、团队熟悉度以及对开发体验和生产环境性能的考量。</p>
]]></content>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>babel</title>
    <url>/2025/01/03/2024/babel/</url>
    <content><![CDATA[<p>babel 学习记录</p>
<p>babel-plugin-transform-runtime插件的能力：为了方便使用 babel-runtime，解决手动 require 的苦恼 </p>
<p>@babel&#x2F;preset-env也是一个预设，包含很多插件</p>
<p>babel-runtime 是 @babel&#x2F;polyfill 的后者 是垫片，是各种插件集合，主要为了能转换新的 API 例如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象<br>babel-runtime 更像是一种按需加载的实现</p>
<p>工作原理：解析，转换，生成</p>
<p>babel中有很多插件，也有预设，包含一系列插件，即presets,还有 core 包，parser 包，traverse,generator</p>
<p>eslint 也依赖 babel</p>
<p>参考文章</p>
<p><a class="link"   href="https://cloud.tencent.com/developer/article/2100524" >https://cloud.tencent.com/developer/article/2100524<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://blog.csdn.net/weixin_44019380/article/details/132684899" >https://blog.csdn.net/weixin_44019380/article/details/132684899<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://juejin.cn/post/6844903956905197576" >https://juejin.cn/post/6844903956905197576<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>engineer</title>
    <url>/2024/08/16/2024/engineer/</url>
    <content><![CDATA[<h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p>标准字段<br>package.json中原有的</p>
<p>非标字段<br>types module exports</p>
<p>如果不设置 main 字段，那么入口文件就是根目录下的 index.js。<br>main：代码入口。<br>这个十分重要，特别是对于组件库。<br>当你想在node_modules中修改你使用的某个组件库的代码时，<br>首先在node_modules中找到这个组件库，<br>第一眼就是要看这个main，找到组件库的入口文件。<br>在这个入口文件中再去修改代码吧。</p>
<p>项目在进行 npm 发布时，可以通过 files 指定需要跟随一起发布的内容来控制 npm 包的大小<br>files：数组。表示代码包下载安装完成时包括的所有文件</p>
<p>dependencies: 不要把测试工具、代码转换器或者打包工具等放在这里</p>
<p>peerDependencies: 指定当前组件的依赖以其版本。如果组件使用者在项目中安装了其他版本的同一依赖，会提示报错</p>
<p>private：如果设为true，无法通过npm publish发布代码</p>
<p>module: 项目也可以指定 ES 模块的入口文件，这就是 module 字段的作用。</p>
<p>exports: 是module更加细化的操作 exports 字段可以配置不同环境对应的模块入口文件，并且当它存在时，它的优先级最高</p>
<h1 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h1><p>files:<br>包含特定文件：当你想要确保某些文件被包含在编译过程中，即使它们没有被其他 TypeScript 文件引用。<br>包含文件夹：指定一个文件夹，让 TypeScript 编译器处理该文件夹下的所有 .ts 文件。<br>排除文件和文件夹：虽然 tsconfig.json 提供了 exclude 选项来排除文件和文件夹，但使用 files 选项可以更明确地指定哪些文件和文件夹是包含的，其余的将被排除。<br>控制编译顺序：在某些情况下，你可能需要控制编译的顺序，通过在 files 中指定文件，可以确保它们按照特定的顺序被编译。<br>避免自动包含：TypeScript 编译器会自动包含所有在 include 选项中指定的 .ts 文件，使用 files 选项可以覆盖这一行为，只包含你明确列出的文件。</p>
<h1 id="node的模块查找策略"><a href="#node的模块查找策略" class="headerlink" title="node的模块查找策略"></a>node的模块查找策略</h1><p>文件查找<br>以相对或绝对路径进行 require,没有后缀的时候支持自动匹配 js,json</p>
<p>文件夹查找<br>如果没有找到文件，先找到文件中的 package.json 文件中的 main 字段文件，如果没有package.json文件或者main字段（指向一个不存在的文件），会找默认的 index 文件</p>
<p>内置模块<br>直接以名称导入</p>
<p>第三方<br>直接以名称导入，但是没找到内置，就会进入第三方模块查找node_modules,没找到的话会重复 1,2 步骤</p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a class="link"   href="https://juejin.cn/post/7161392772665540644#heading-10" >https://juejin.cn/post/7161392772665540644#heading-10<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>engineer</tag>
      </tags>
  </entry>
  <entry>
    <title>deepClone</title>
    <url>/2024/11/09/2024/deepClone/</url>
    <content><![CDATA[<h3 id="深拷贝实现（避免循环引用版本）"><a href="#深拷贝实现（避免循环引用版本）" class="headerlink" title="深拷贝实现（避免循环引用版本）"></a>深拷贝实现（避免循环引用版本）</h3><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepclone</span>(<span class="params">obj, objs = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (objs.<span class="title function_">has</span>(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> objs.<span class="title function_">get</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> cloneObj;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Set</span>) &#123;</span><br><span class="line">        cloneObj = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        objs.<span class="title function_">set</span>(obj, cloneObj);</span><br><span class="line">        obj.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            cloneObj.<span class="title function_">add</span>(<span class="title function_">deepclone</span>(item, objs));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Map</span>) &#123;</span><br><span class="line">        cloneObj = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        objs.<span class="title function_">set</span>(obj, cloneObj);</span><br><span class="line">        obj.<span class="title function_">forEach</span>(<span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">            cloneObj.<span class="title function_">set</span>(key, <span class="title function_">deepclone</span>(value, objs));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">        cloneObj = <span class="keyword">new</span> <span class="title class_">Date</span>(obj.<span class="title function_">getTime</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pbj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">        cloneObj = <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj.<span class="title function_">toString</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cloneObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">                cloneObj[key] = <span class="title function_">deepclone</span>(obj[key], objs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]],</span><br><span class="line">    <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">    <span class="attr">c</span>: &#123;</span><br><span class="line">        <span class="attr">d</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">f</span>: <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;g&#x27;</span>]),</span><br><span class="line">    <span class="attr">g</span>: <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>]])</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">deepclone</span>(obj));</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>手写题</tag>
      </tags>
  </entry>
  <entry>
    <title>html_css</title>
    <url>/2024/12/06/2024/html-css/</url>
    <content><![CDATA[<p>如果父元素是body，且没有给body和html写特殊样式。width的100%就相当于100vw了。因为html和body默认的width是auto（且是block，所以相当于width是fill），body默认会有宽度。所以100%就相当于100vw。<br>但是如果父元素是body，且没有给body和html写特殊样式。设置height 100%就不行。因为html和body的height默认值都是auto，具体高度是由子元素决定的。所以如果你需要设置高度，建议用100vh。</p>
<p><a class="link"   href="https://juejin.cn/post/7113190608071557157" >https://juejin.cn/post/7113190608071557157<i class="fas fa-external-link-alt"></i></a></p>
<p>body,<br>html,<br>#app {<br>  height: 100%;<br>  width: 100%;<br>}</p>
]]></content>
  </entry>
  <entry>
    <title>网络知识学习</title>
    <url>/2024/07/09/2024/http/</url>
    <content><![CDATA[<h1 id="http-版本区别-（阻塞-连接快慢）"><a href="#http-版本区别-（阻塞-连接快慢）" class="headerlink" title="http 版本区别 （阻塞 连接快慢）"></a>http 版本区别 （阻塞 连接快慢）</h1><p>1.1比较 1.0：</p>
<ol>
<li><p>长连接</p>
</li>
<li><p>缓存处理</p>
<ol>
<li><p>协商缓存</p>
<ol>
<li><p>Last_modified    if-modified-since</p>
</li>
<li><p>etag  if-none-match</p>
</li>
<li><p>强缓存</p>
</li>
<li><p>expires</p>
</li>
<li><p>Cache-control  max-age</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>2.0 比较 1.1</p>
<ol>
<li><p>头部压缩</p>
<ol>
<li>Hpack 算法<ol>
<li>静态字典；</li>
<li>动态字典；</li>
<li>Huffman 编码（压缩算法）</li>
</ol>
</li>
</ol>
</li>
<li><p>二进制帧</p>
</li>
<li><p>多路复用</p>
</li>
<li><p>服务端主动推送</p>
</li>
</ol>
<p>3.0 比较 2.0</p>
<ol>
<li>基于udp，给每个 stream 加一个滑动窗口的 quic 协议</li>
</ol>
<p>怎么保证数据包内容一致</p>
<ol>
<li>引入 frame header 这一层 <strong>通过 Stream ID + Offset 字段信息实现数据的有序性</strong></li>
<li>QUIC使用的Packet Number单调递增的设计，可以让数据包不再像TCP那样必须有序确认，QUIC支持乱序确认，当数据包Packet N丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动</li>
</ol>
<h1 id="tcp协议是如何实现稳定传输的"><a href="#tcp协议是如何实现稳定传输的" class="headerlink" title="tcp协议是如何实现稳定传输的"></a>tcp协议是如何实现稳定传输的</h1><p>1.确认和重传机制  要接受方的确认消息、</p>
<p>2.序号和确认号  排序确认、</p>
<p>3.流量控制、 TCP 使用流量控制机制来避免发送方发送过多的数据，导致接收方缓冲区溢出</p>
<p>4.拥塞机制   拥塞控制算法包括慢启动、拥塞避免和快速重传等</p>
<ol>
<li><strong>可靠性的确认和重传机制</strong>：<ul>
<li>TCP 使用确认和重传机制来确保数据的可靠传输。发送方在发送数据后会等待接收方发送的确认消息，如果在一定时间内没有收到确认消息，发送方会重新发送数据。</li>
<li>接收方在收到数据后会发送确认消息给发送方，以告知发送方数据已经接收。如果接收方检测到数据包丢失，它会要求发送方重传丢失的数据。</li>
</ul>
</li>
<li><strong>序号和确认号</strong>：<ul>
<li>TCP 使用序号和确认号来对数据包进行排序和确认。每个 TCP 报文段都有一个序号字段和一个确认号字段，用来标识数据包的顺序和确认已收到的数据。</li>
<li>接收方会使用确认号来告知发送方已成功接收到哪些数据，发送方根据确认号来决定是否重传丢失的数据。</li>
</ul>
</li>
<li><strong>流量控制</strong>：<ul>
<li>TCP 使用流量控制机制来避免发送方发送过多的数据，导致接收方缓冲区溢出。接收方可以通过窗口字段来告知发送方自己的可接受窗口大小，发送方根据接收方的窗口大小来调整发送的数据量。</li>
</ul>
</li>
<li><strong>拥塞控制</strong>：<ul>
<li>TCP 使用拥塞控制机制来避免网络拥塞。发送方根据网络拥塞的情况来调整发送速率，以避免发送过多的数据导致网络拥塞。常见的拥塞控制算法包括慢启动、拥塞避免和快速重传等。</li>
</ul>
</li>
<li><strong>超时重传机制</strong>：<ul>
<li>TCP 使用超时重传机制来处理丢失的数据包。如果发送方在一定时间内没有收到确认消息，它会假设数据包丢失，并触发重传机制重新发送数据。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>eslint</title>
    <url>/2024/08/11/2024/eslint/</url>
    <content><![CDATA[<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li>【eslint英文文档】<a class="link"   href="https://eslint.org/docs/user-guide/configuring" >https://eslint.org/docs/user-guide/configuring<i class="fas fa-external-link-alt"></i></a></li>
<li>【eslint中文文档】<a class="link"   href="http://eslint.cn/docs/rules/" >http://eslint.cn/docs/rules/<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h1 id="eslint有三种使用方式"><a href="#eslint有三种使用方式" class="headerlink" title="eslint有三种使用方式"></a>eslint有三种使用方式</h1><ul>
<li><p>【1】js代码中通过注释的方式使用</p>
</li>
<li><p>【2】通过webpack的eslintConfig字段设置，eslint会自动搜索项目的package.json文件中的配置</p>
</li>
<li><p>【3】通过配置文件的方式使用，配置文件有多种文件方式，如JavaScript、JSON 或者 YAML等</p>
</li>
</ul>
<h1 id="文件忽略"><a href="#文件忽略" class="headerlink" title="文件忽略"></a>文件忽略</h1><ul>
<li>【】让eslint跳过特定文件的检测</li>
<li>【】通过当前工作目录下 「.eslintignore」 文件进行设置</li>
<li>其使用的是Glob路径书写方式，与「.gitignore」的使用方法相同</li>
<li>【】也可以在 package.json 文件中，通过 eslintIgnore 参数进行设置<br>*&#x2F;</li>
</ul>
<p>&#x2F;**</p>
<ul>
<li>文件内局部设置</li>
<li>【】eslint可以具体文件中设置特定代码的规则，常用于跳过某条语句的检测。</li>
<li>【】注销全部规则，在代码前新建一行，添加注销 &#x2F;* eslint-disable */   。如果没有恢复设置的语句，则下列全部代码都会跳过检测。</li>
<li>【】恢复eslint，在代码前新建一行，添加注销 &#x2F;* eslint-enable */</li>
<li>【】指定忽略的规则，&#x2F;* eslint-disable no-alert, no-console */</li>
<li>【】在特定行禁用，&#x2F;&#x2F; eslint-disable-line</li>
<li>【】在下一行禁用，&#x2F;&#x2F; eslint-disable-next-line<br>*&#x2F;</li>
</ul>
<p>module.exports &#x3D; {</p>
<p>&#x2F;**</p>
<ul>
<li>根目录标识</li>
<li><a class="link"   href="http://eslint.cn/docs/user-guide/configuring#using-configuration-files" >http://eslint.cn/docs/user-guide/configuring#using-configuration-files<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="http://eslint.cn/docs/user-guide/configuring#configuration-cascading-and-hierarchy" >http://eslint.cn/docs/user-guide/configuring#configuration-cascading-and-hierarchy<i class="fas fa-external-link-alt"></i></a></li>
<li>【】标识当前配置文件为最底层的文件，无需往更上一级的文件目录中进行搜索</li>
<li>【】默认eslint的配置文件搜索方式是，从目标文件夹进行搜索，遍历内部每一个文件夹，找到配置文件并层叠使用。再跳出本项目，往祖先文件夹进行遍历</li>
<li>【】注意「<del>&#x2F;.eslintrc」的意义，「</del>」是指linux上的家目录，「~&#x2F;.eslintrc」是指家目录下的eslint配置文件，用于私人开发者，用于整个电脑全局约束的。这个配置通过本配置项root去设置，设置了root,eslint检测时将不会再往上搜索</li>
<li>【】eslint的生效规则是就近使用，越近的配置项优先级越高，覆盖其他配置项。如一个项目中，可以在不同文件夹中都添加配置文件，这些规则将重叠组合生效<br>*&#x2F;<br>root: true, &#x2F;&#x2F; 标识当前配置文件为eslint的根配置文件，让其停止在父级目录中继续寻找。</li>
</ul>
<p>&#x2F;**</p>
<ul>
<li>解析器</li>
<li><a class="link"   href="http://eslint.cn/docs/user-guide/configuring#specifying-parser" >http://eslint.cn/docs/user-guide/configuring#specifying-parser<i class="fas fa-external-link-alt"></i></a></li>
<li>【】ESLint 默认使用Espree作为其解析器</li>
<li>【】解析器必须是本地安装的一个 npm 模块。即必须按照在本地的node_module中</li>
<li>【】解析器是用于解析js代码的，怎么去理解每一个表达式，有点C++中编译器的概念，会对js进行一些语法分析，语义分析什么的，才能判断语句符不符合规范。而不是通过简单的字符串对比。</li>
<li>【】解析器有很多，但兼容eslint的解析器有以下几个</li>
<li>Espree：默认解析器，一个从Esprima中分离出来的解析器，做了一些优化</li>
<li>Esprima：js标准解析器</li>
<li>Babel-ESLint： 一个对Babel解析器的包装，babel本身也是js解析器的一种（不然怎么能转化为兼容性代码呢？首先需要进行js解析，才能转化）。如果我们的代码需要经过babel转化，则对应使用这个解析器</li>
<li>typescript-eslint-parser(实验) - 一个把 TypeScript 转换为 ESTree 兼容格式的解析器</li>
<li>【】但是通常在vue项目中，并不会写在 parser 字段中，而是写在 parserOptions -&gt; parser。具体原因在 parserOptions 一栏中介绍<br>*&#x2F;<br>&#x2F;&#x2F; parser: ‘babel-eslint’,</li>
</ul>
<p>&#x2F;**</p>
<ul>
<li>解析器配置项</li>
<li><a class="link"   href="http://eslint.cn/docs/user-guide/configuring#specifying-parser-options" >http://eslint.cn/docs/user-guide/configuring#specifying-parser-options<i class="fas fa-external-link-alt"></i></a></li>
<li>【】这里设置的配置项将会传递到解析器中，被解析器获取到，进行一定的处理。具体被利用到，要看解析器的源码有没有对其进行利用。这里仅仅做了参数定义，做了规定，告诉解析器的开发者可能有这些参数</li>
<li>【】配置项目有：</li>
<li>“sourceType”: “module”,    &#x2F;&#x2F; 指定JS代码来源的类型，script(script标签引入？) | module（es6的module模块），默认为script。为什么vue的会使用script呢？因为vue是通过babel-loader编译的，而babel编译后的代码就是script方式</li>
<li>“ecmaVersion”: 6,          &#x2F;&#x2F; 支持的ES语法版本，默认为5。注意只是语法，不包括ES的全局变量。全局变量需要在env选项中进行定义</li>
<li>“ecmaFeatures”: {          &#x2F;&#x2F; Features是特征的意思，这里用于指定要使用其他那些语言对象<br>“experimentalObjectRestSpread”: true,  &#x2F;&#x2F;启用对对象的扩展<br>“jsx”: true,                           &#x2F;&#x2F;启用jsx语法<br>“globalReturn”:true,                   &#x2F;&#x2F;允许return在全局使用<br>“impliedStrict”:true                   &#x2F;&#x2F;启用严格校验模式<br>}<br><em>&#x2F;<br>parserOptions: {<br>&#x2F;</em>*<ul>
<li>这里出现 parser 的原因</li>
<li>【】首先明确一点，官方说明中，parserOptions的配置参数是不包括 parser 的</li>
<li>【】这里的写 parser 是 eslint-plugin-vue 的要求，是 eslint-plugin-vue 的自定义参数</li>
<li>【】根据官方文档，eslint-plugin-vue 插件依赖 「vue-eslint-parser」解析器。「vue-eslint-parser」解析器，只解析 .vue 中html部分的内容，不会检测<script>中的JS内容。</li>
<li>【】由于解析器只有一个，用了「vue-eslint-parser」就不能用「babel-eslint」。所以「vue-eslint-parser」的做法是，在解析器选项中，再传入一个解析器选项parser。从而在内部处理「babel-eslint」，检测<script>中的js代码</li>
<li>【】所以这里出现了 parser</li>
<li>【】相关文档地址，<a class="link"   href="https://vuejs.github.io/eslint-plugin-vue/user-guide/#usage" >https://vuejs.github.io/eslint-plugin-vue/user-guide/#usage<i class="fas fa-external-link-alt"></i></a><br>*/<br>parser: 'babel-eslint',<br>},</li>
</ul>
</li>
</ul>
<p>/**</p>
<ul>
<li>运行环境</li>
<li><a class="link"   href="http://eslint.cn/docs/user-guide/configuring#specifying-environments" >http://eslint.cn/docs/user-guide/configuring#specifying-environments<i class="fas fa-external-link-alt"></i></a></li>
<li>【】一个环境定义了一组预定义的全局变量</li>
<li>【】获得了特定环境的全局定义，就不会认为是开发定义的，跳过对其的定义检测。否则会被认为改变量未定义</li>
<li>【】常见的运行环境有以下这些，更多的可查看官网</li>
<li>browser - 浏览器环境中的全局变量。</li>
<li>node - Node.js 全局变量和 Node.js 作用域。</li>
<li>es6 - 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 ecmaVersion 解析器选项为 6）。</li>
<li>amd - 将 require() 和 define() 定义为像 amd 一样的全局变量。</li>
<li>commonjs - CommonJS 全局变量和 CommonJS 作用域 (用于 Browserify/WebPack 打包的只在浏览器中运行的代码)。</li>
<li>jquery - jQuery 全局变量。</li>
<li>mongo - MongoDB 全局变量。</li>
<li>worker - Web Workers 全局变量。</li>
<li>serviceworker - Service Worker 全局变量。<br>*/<br>env: {<br>browser: true, // 浏览器环境<br>},</li>
</ul>
<p>/**</p>
<ul>
<li>全局变量</li>
<li><a class="link"   href="http://eslint.cn/docs/user-guide/configuring#specifying-globals" >http://eslint.cn/docs/user-guide/configuring#specifying-globals<i class="fas fa-external-link-alt"></i></a></li>
<li>【】定义额外的全局，开发者自定义的全局变量，让其跳过no-undef 规则</li>
<li>【】key值就是额外添加的全局变量</li>
<li>【】value值用于标识该变量能否被重写，类似于const的作用。true为允许变量被重写</li>
<li>【】注意：要启用no-global-assign规则来禁止对只读的全局变量进行修改。<br>*/<br>globals: {<br>// gTool: true, // 例如定义gTool这个全局变量，且这个变量可以被重写<br>},</li>
</ul>
<p>/**</p>
<ul>
<li>插件</li>
<li><a class="link"   href="http://eslint.cn/docs/user-guide/configuring#configuring-plugins" >http://eslint.cn/docs/user-guide/configuring#configuring-plugins<i class="fas fa-external-link-alt"></i></a></li>
<li>【】插件同样需要在node_module中下载</li>
<li>【】注意插件名忽略了「eslint-plugin-」前缀，所以在package.json中，对应的项目名是「eslint-plugin-vue」</li>
<li>【】插件的作用类似于解析器，用以扩展解析器的功能，用于检测非常规的js代码。也可能会新增一些特定的规则。</li>
<li>【】如 eslint-plugin-vue，是为了帮助我们检测.vue文件中 <template> 和 <script> 中的js代码<br>*/<br>plugins: ['vue'],</li>
</ul>
<p>/**</p>
<ul>
<li>规则继承</li>
<li><a class="link"   href="http://eslint.cn/docs/user-guide/configuring#extending-configuration-files" >http://eslint.cn/docs/user-guide/configuring#extending-configuration-files<i class="fas fa-external-link-alt"></i></a><br>*【】可继承的方式有以下几种<br>*【】eslint内置推荐规则，就只有一个，即「eslint:recommended」<br>*【】可共享的配置， 是一个 npm 包，它输出一个配置对象。即通过npm安装到node_module中</li>
<li>可共享的配置可以省略包名的前缀 eslint-config-，即实际设置安装的包名是 eslint-config-airbnb-base<br><em>【】从插件中获取的规则，书写规则为 「plugin:插件包名/配置名」，其中插件报名也是可以忽略「eslint-plugin-」前缀。如'plugin:vue/essential'<br><em>【】从配置文件中继承，即继承另外的一个配置文件，如'./node_modules/coding-standard/eslintDefaults.js'<br><em>/<br>extends: [<br>/</em></em><br> * vue 的额外添加的规则是 v-if, v-else 等指令检测<br><em>/<br>'plugin:vue/essential', // 额外添加的规则可查看 <a class="link"   href="https://vuejs.github.io/eslint-plugin-vue/rules/" >https://vuejs.github.io/eslint-plugin-vue/rules/<i class="fas fa-external-link-alt"></i></a><br>/</em></em><br> * 「airbnb，爱彼迎」<br> * 【】有两种eslint规范，一种是自带了react插件的「eslint-config-airbnb」，一种是基础款「eslint-config-airbnb-base」，<br> * 【】airbnb-base 包括了ES6的语法检测，需要依赖 「eslint-plugin-import」<br> * 【】所以在使用airbnb-base时，需要用npm额外下载 eslint-plugin-import<br> * 【】所以eslint实际上已经因为 airbnb-base 基础配置项目，添加上了 eslint-plugin-import 插件配置<br> * 【】所以在setting和rules里，都有 'import/xxx' 项目，这里修改的就是 eslint-plugin-import 配置<br>*/<br>// 'airbnb-base',<br>],</li>
</ul>
<p>/**</p>
<ul>
<li>规则共享参数</li>
<li><a class="link"   href="http://eslint.cn/docs/user-guide/configuring#adding-shared-settings" >http://eslint.cn/docs/user-guide/configuring#adding-shared-settings<i class="fas fa-external-link-alt"></i></a></li>
<li>【】提供给具体规则项，每个参数值，每个规则项都会被注入该变量，但对应规则而言，有没有用，就看各个规则的设置了，就好比 parserOptions，解析器用不用它就不知道了。这里只是提供这个方法</li>
<li>【】不用怀疑，经源码验证，这就是传递给每个规则项的，会当做参数传递过去，但用不用，就是具体规则的事情<br><em>/<br>settings: {<br>/</em>*<ul>
<li></li>
<li>注意，「import/resolver」并不是eslint规则项，与rules中的「import/extensions」不同。它不是规则项</li>
<li>这里只是一个参数名，叫「import/resolver」，会传递给每个规则项。</li>
<li>settings并没有具体的书写规则，「import/」只是import模块自己起的名字，原则上，它直接命名为「resolver」也可以，加上「import」只是为了更好地区分。不是强制设置的。</li>
<li>因为「import」插件很多规则项都用的这个配置项，所以并没有通过rules设置，而是通过settings共享</li>
<li>具体使用方法可参考<a class="link"   href="https://github.com/benmosher/eslint-plugin-import" >https://github.com/benmosher/eslint-plugin-import<i class="fas fa-external-link-alt"></i></a><br><em>/<br>'import/resolver': {<br>/</em>*<ul>
<li>这里传入webpack并不是import插件能识别webpack，而且通过npm安装了「eslint-import-resolver-webpack」，</li>
<li>「import」插件通过「eslint-import-resolver-」+「webpack」找到该插件并使用，就能解析webpack配置项。使用里面的参数。</li>
<li>主要是使用以下这些参数，共享给import规则，让其正确识别import路径</li>
<li>extensions: ['.js', '.vue', '.json'],</li>
<li>alias: {</li>
<li>'vue$': 'vue/dist/vue.esm.js',</li>
<li>'@': resolve('src'),</li>
<li>'static': resolve('static')</li>
<li>}<br>*/<br>webpack: {<br>config: 'build/webpack.base.conf.js'<br>}<br>}<br>},</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>/**</p>
<ul>
<li>针对特定文件的配置</li>
<li>【】可以通过overrides对特定文件进行特定的eslint检测</li>
<li>【】特定文件的路径书写使用Glob格式，一个类似正则的路径规则，可以匹配不同的文件</li>
<li>【】配置几乎与 ESLint 的其他配置相同。覆盖块可以包含常规配置中的除了 extends、overrides 和 root 之外的其他任何有效配置选项，<br><em>/<br>// overrides: [<br>//   {<br>//     'files': ['bin/</em>.js', 'lib/<em>.js'],<br>//     'excludedFiles': '</em>.test.js',<br>//     'rules': {<br>//       'quotes': [2, 'single']<br>//     }<br>//   }<br>// ],</li>
</ul>
<p>/**</p>
<ul>
<li>自定义规则</li>
<li><a class="link"   href="http://eslint.cn/docs/user-guide/configuring#configuring-rules" >http://eslint.cn/docs/user-guide/configuring#configuring-rules<i class="fas fa-external-link-alt"></i></a></li>
<li>【】基本使用方式</li>
<li>"off" 或者0 关闭规则</li>
<li>"warn" 或者1 将规则打开为警告（不影响退出代码）</li>
<li>"error" 或者2 将规则打开为错误（触发时退出代码为1）</li>
<li>如：'no-restricted-syntax': 0, // 表示关闭该规则</li>
<li>【】如果某项规则，有额外的选项，可以通过数组进行传递，而数组的第一位必须是错误级别。如0,1,2</li>
<li>如 'semi': ['error', 'never'], never就是额外的配置项<br><em>/<br>rules: {<br>/</em>*<ul>
<li>具体规则</li>
<li>【】具体的规则太多，就不做介绍了，有兴趣的同学可以上eslint官网查</li>
<li>【】注意 xxx/aaa 这些规则是 xxx 插件自定的规则，在eslint官网是查不到的。需要到相应的插件官网中查阅</li>
<li>【】如 import/extensions，这是「eslint-plugin-import」自定义的规则，需要到其官网查看 <a class="link"   href="https://github.com/benmosher/eslint-plugin-import" >https://github.com/benmosher/eslint-plugin-import<i class="fas fa-external-link-alt"></i></a><br><em>/<br>/</em>*</li>
<li>逻辑错误及最佳实践的规则<br><em>/<br>'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, // 打包时禁止debugger<br>'no-console': process.env.NODE_ENV === 'production' ? 2 : 0, // 打包时禁止console<br>'no-alert': process.env.NODE_ENV === 'production' ? 2 : 0, // 打包时禁止console<br>"for-direction": 2, // 禁止for无限循环<br>"no-compare-neg-zero": 2, // 禁止与-0进行比较<br>'no-cond-assign': 2, // 禁止条件语句中出现赋值语句<br>"no-control-regex": 2, // 在 ASCII 中，0-31 范围内的控制字符是特殊的、不可见的字符。这些字符很少被用在 JavaScript 字符串中，所以一个正则表达式如果包含这些字符的，很有可能一个错误。<br>"no-dupe-args": 2, // 禁止在函数定义或表达中出现重名参数<br>"no-dupe-keys": 2, // 禁止在对象字面量中出现重复的键<br>"no-duplicate-case": 2, // 禁止重复 case 标签<br>"no-empty": 2, // 禁止空块语句<br>"no-empty-character-class": 2, // 禁止在正则表达式中出现空字符集<br>"no-ex-assign": 2, // 禁止对 catch 子句中的异常重新赋值。因为catch出来的都是错误信息，不需要重新赋值<br>"no-extra-boolean-cast": 2, // 禁止不必要的布尔类型转换，如 !!true<br>"no-extra-semi": 2, // 禁用不必要的分号<br>"no-inner-declarations": 2, // ??? 禁止在嵌套的语句块中出现变量<br>"no-regex-spaces": 2, // 禁止正则表达式字面量中出现多个空格<br>"no-obj-calls": 2, // 禁止将全局对象当作函数进行调用<br>"no-prototype-builtins": 2, // ??? 禁止直接在对象实例上调用 Object.prototype 的一些方法。<br>"no-template-curly-in-string": 2, // 禁止在常规字符串中出现模板字面量占位符语法<br>"semi": [2, 'never'], // ??? 强制是否使用分号。<br>"no-unexpected-multiline": 2, // 禁止使用令人困惑的多行表达式<br>"no-unreachable": 2, // 禁止在 return、throw、continue 和 break 语句后出现不可达代码<br>"use-isnan": 2, // 要求调用 isNaN()检查 NaN<br>"no-unsafe-negation": 2, // 禁止对关系运算符的左操作数使用否定操作符<br>"valid-jsdoc": 2, // 强制使用有效的 JSDoc 注释<br>"valid-typeof": 2, // 强制 typeof 表达式与有效的字符串进行比较<br>"array-callback-return": 2, // 强制数组方法的回调函数中有 return 语句<br>"block-scoped-var": 2, // 把 var 语句看作是在块级作用域范围之内<br>"complexity": [1, 6], // 添加复杂度<br>"curly": 2, // ??? 要求遵循大括号约定<br>"default-case": 1, // 要求 Switch 语句中有 Default 分支<br>"dot-location": [2, 'property'], // 强制在点号之前换行<br>"dot-notation": 2, // 点号和字面量，优先使用点号<br>"eqeqeq": [2, 'smart'], // ??? 要求使用 === 和 !==<br>"guard-for-in": 2, // ??? 需要约束 for-in<br>"no-caller": 2, // 禁用 caller 或 callee<br>"no-empty-function": 2, // 禁止出现空函数<br>"no-empty-pattern": 2, // 禁止使用空解构模式<br>"no-eval": 2, // 禁用 eval()<br>"no-global-assign": 2, // 禁止对原生对象或只读的全局对象进行赋值<br>"no-floating-decimal": 2, // ?? 禁止浮点小数<br>"no-fallthrough": 2, // 禁止 case 语句落空<br>"no-labels": 2, // 禁用标签语句<br>"no-extra-label": 2, // 禁用不必要的标签<br>"no-extra-bind": 2, // 禁止不必要的函数绑定<br>"no-iterator": 2, // 禁用迭代器<br>"no-lone-blocks": 2, // 禁用不必要的嵌套块<br>"no-loop-func": 2, // 禁止循环中存在函数<br>"no-magic-numbers": [2, {<br>ignoreArrayIndexes: true,<br>ignore: [-1, 0, 1, 2],<br>}], // 禁止使用魔术数字，魔术数字是在代码中多次出现的没有明确含义的数字。它最好由命名常量取代。<br>"no-multi-spaces": 2, // 禁止出现多个空格<br>"no-multi-str": 2, // 禁止多行字符串<br>"no-new": 2, // 禁止在不保存实例的情况下使用new<br>"no-new-func": 2, // 禁用Function构造函数<br>"no-new-wrappers": 2, // 禁止原始包装实例<br>"no-octal": 2, // 禁用八进制字面量<br>"no-octal-escape": 2, // 禁止在字符串字面量中使用八进制转义序列<br>"no-param-reassign": 2, // ??? 禁止对函数参数再赋值<br>"no-proto": 2, // 禁用__proto__，改用 getPrototypeOf 方法替代 __proto__。<br>"no-redeclare": 2, // 禁止重新声明变量<br>"no-return-assign": 2, // 禁止在返回语句中赋值<br>"no-return-await": 2, // 禁用不必要的 return await<br>"no-script-url": 2, // 禁用 Script URL<br>"no-self-assign": 2, // 禁止自身赋值<br>"no-sequences": 2, // ??? 不允许使用逗号操作符<br>"no-throw-literal": 2, // 限制可以被抛出的异常<br>"no-unmodified-loop-condition": 2, // 禁用一成不变的循环条件<br>"no-useless-call": 2, // 禁用不必要的 .call() 和 .apply()<br>"no-useless-concat": 2, // 禁止没有必要的字符拼接<br>"no-useless-escape": 2, // 禁用不必要的转义<br>"no-useless-return": 2, // 禁止多余的 return 语句<br>"no-void": 2, // 禁止使用void操作符<br>"no-with": 2, // 禁用 with 语句<br>"prefer-promise-reject-errors": 1, // ??? 要求使用 Error 对象作为 Promise 拒绝的原因<br>"radix": 1, // 要求必须有基数<br>"require-await": 2, // 禁止使用不带 await 表达式的 async 函数<br>"vars-on-top": 2, // 要求将变量声明放在它们作用域的顶部<br>"wrap-iife": [2, 'inside'], // 需要把立即执行的函数包裹起来<br>"strict": [2, 'global'], // 要求或禁止使用严格模式指令<br>/</em>*</li>
<li>变量相关的规则<br><em>/<br>"init-declarations": 2, // ??? 强制或禁止变量声明语句中初始化<br>"no-delete-var": 2, // 禁止删除变量<br>"no-shadow": 2, // 禁止变量声明覆盖外层作用域的变量<br>"no-shadow-restricted-names": 2, // 关键字不能被遮蔽<br>"no-undef": 2, // 禁用未声明的变量<br>"no-unused-vars": 1, // ??? 禁止未使用过的变量<br>"no-use-before-define": 2, // 禁止定义前使用<br>// 代码风格<br>"array-bracket-newline": [2, 'consistent'], // 在数组开括号后和闭括号前强制换行<br>"array-bracket-spacing": 2, // 强制在括号内前后使用空格<br>"array-element-newline": [2, { multiline: true }], // ??? 强制数组元素间出现换行<br>"block-spacing": 2, // 强制在代码块中开括号前和闭括号后有空格<br>"brace-style": 2, // 大括号风格要求<br>"camelcase": 2, // 要求使用骆驼拼写法<br>"comma-dangle": [2, 'always-multiline'], // 要求或禁止使用拖尾逗号<br>"comma-spacing": 2, // 强制在逗号周围使用空格<br>"comma-style": 2, // 逗号风格<br>"computed-property-spacing": 2, // 禁止或强制在计算属性中使用空格<br>"consistent-this": [2, 'self'], // ??? 要求一致的 This<br>"eol-last": [1, 'always'], // ??? 要求或禁止文件末尾保留一行空行<br>"func-call-spacing": 2, // 要求或禁止在函数标识符和其调用之间有空格<br>"func-style": [2, 'declaration'], // ??? 强制 function 声明或表达式的一致性<br>"function-paren-newline": [1, 'multiline'], // 强制在函数括号内使用一致的换行<br>"indent": [2, 2], // 强制使用一致的缩进<br>"jsx-quotes": 2, // 强制在 JSX 属性中一致地使用双引号或单引号<br>"key-spacing": 2, // 强制在对象字面量的键和值之间使用一致的空格<br>"keyword-spacing": 2, // 强制关键字周围空格的一致性<br>"linebreak-style": 2, // 强制使用一致的换行符风格，用\n，不用\r\n<br>"lines-around-comment": 2, // 强制注释周围有空行<br>"lines-between-class-members": 2, // 要求在类成员之间出现空行<br>"max-depth": 2, // 强制块语句的最大可嵌套深度<br>"max-len": [2, { // 强制行的最大长度<br>"code": 100,<br>"tabWidth": 4,<br>"ignoreUrls": true,<br>"ignoreTrailingComments": true,<br>"ignoreTemplateLiterals": true,<br>}], //<br>"max-lines": [2, 1000], // ??? 强制文件的最大行数<br>"max-nested-callbacks": [2, 5], // 强制回调函数最大嵌套深度<br>"max-statements-per-line": 2, // 强制每一行中所允许的最大语句数量<br>"multiline-comment-style": 1, // 强制对多行注释使用特定风格<br>"new-cap": 2, // 要求构造函数首字母大写<br>"new-parens": 2, // 要求调用无参构造函数时带括号<br>"newline-per-chained-call": 2, // 要求方法链中每个调用都有一个换行符<br>"no-bitwise": 2, // 禁止使用按位操作符<br>"no-inline-comments": 0, // ??? 禁止使用内联注释<br>"no-lonely-if": 2, // 禁止 if 语句作为唯一语句出现在 else 语句块中<br>"no-mixed-spaces-and-tabs": 2, // 禁止使用 空格 和 tab 混合缩进<br>"no-multiple-empty-lines": 1, // ??? 不允许多个空行<br>"no-negated-condition": 2, // 禁用否定表达式<br>"no-nested-ternary": 2, // 禁止使用嵌套的三元表达式<br>"no-new-object": 2, // 禁止使用 Object 构造函数<br>"no-trailing-spaces": 2, // 禁用行尾空白<br>"no-underscore-dangle": 2, // 禁止标识符中有悬空下划线<br>"quotes": [2, 'single'], // 强制使用一致的单引号<br>"quote-props": [2, 'as-needed'], // ??? 要求对象字面量属性名称使用引号<br>"operator-linebreak": [2, 'before'], // 强制操作符使用一致的换行符风格<br>"one-var": [2, 'never'], // ??? 强制函数中的变量在一起声明或分开声明<br>"object-property-newline": 1, // ??? 强制将对象的属性放在不同的行上<br>"object-curly-spacing": [2, 'always'], // 强制在花括号中使用一致的空格<br>"object-curly-newline": [1, { // ??? 对象属性换行<br>multiline: true,<br>}], //<br>"no-whitespace-before-property": 2, // 禁止属性前有空白<br>"no-unneeded-ternary": 2, // 禁止可以表达为更简单结构的三元操作符<br>"semi-spacing": 2, // 强制分号前后有空格<br>"semi-style": 2, // 分号风格<br>"space-before-blocks": [2, 'always'], // 禁止语句块之前的空格<br>"space-before-function-paren": [2, 'never'], // 禁止函数圆括号之前有一个空格<br>"space-in-parens": 2, // 禁止或强制圆括号内的空格<br>"space-infix-ops": 2, // 要求中缀操作符周围有空格<br>"space-unary-ops": 2, // 禁止在一元操作符之前或之后存在空格<br>"spaced-comment": 2, // 要求在注释前有空白<br>"switch-colon-spacing": 2, // 强制在 switch 的冒号左右有空格<br>"template-tag-spacing": 2, // 要求在模板标记和它们的字面量之间有空格<br>/</em>*</li>
<li>ES6相关规则<br>*/<br>"arrow-parens": [2, 'as-needed'], // 要求箭头函数的参数使用圆括号<br>"arrow-body-style": 2, // 要求箭头函数体使用大括号<br>"arrow-spacing": 2, // 要求箭头函数的箭头之前或之后有空格<br>"generator-star-spacing": 2, // ??? 强制 generator 函数中 * 号周围有空格<br>"no-class-assign": 2, // 不允许修改类声明的变量<br>"no-confusing-arrow": 2, // 禁止在可能与比较操作符相混淆的地方使用箭头函数<br>"no-const-assign": 2, // 不允许改变用const声明的变量<br>"no-dupe-class-members": 2, // 不允许类成员中有重复的名称<br>"no-duplicate-imports": 2, // 禁止重复导入<br>"no-new-symbol": 0, // 禁止 Symbol 操作符和 new 一起使用lines-between<br>"no-useless-computed-key": 2, // 禁止在对象中使用不必要的计算属性<br>"no-useless-constructor": 2, // 禁用不必要的构造函数<br>"no-useless-rename": 2, // 禁止在 import 和 export 和解构赋值时将引用重命名为相同的名字<br>"no-var": 2, // 要求使用 let 或 const 而不是 var<br>"object-shorthand": 2, // 要求对象字面量简写语法<br>"prefer-arrow-callback": 2, // 要求使用箭头函数作为回调<br>"prefer-const": 1, // ??? 建议使用const<br>"prefer-destructuring": [2, { // 优先使用数组和对象解构<br>"array": false,<br>"object": true<br>}],<br>"prefer-rest-params": 2, // 使用剩余参数代替 arguments<br>"prefer-spread": 2, // 建议使用扩展运算符而非.apply()<br>"prefer-template": 2, // 建议使用模板而非字符串连接<br>"require-yield": 2, // 禁用函数内没有yield的 generator 函数<br>"rest-spread-spacing": 2, // 强制剩余和扩展运算符及其表达式之间有空格<br>"template-curly-spacing": 2, // 强制模板字符串中空格的使用<br>"sort-imports": [0, { // ??? import 排序 问题是要以字母排序<br>ignoreCase: true,<br>ignoreMemberSort: true,<br>memberSyntaxSortOrder: ['all', 'single', 'multiple', 'none']<br>}], //<br>}<br>};</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Eslint</tag>
      </tags>
  </entry>
  <entry>
    <title>npm换淘宝最新源</title>
    <url>/2024/01/09/2024/npm_raw/</url>
    <content><![CDATA[<h1 id="新版淘宝镜像源"><a href="#新版淘宝镜像源" class="headerlink" title="新版淘宝镜像源"></a>新版淘宝镜像源</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://registry.npmmirror.com </span><br></pre></td></tr></table></figure>

<h1 id="获取当前使用的源"><a href="#获取当前使用的源" class="headerlink" title="获取当前使用的源"></a>获取当前使用的源</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>

<h1 id="设置淘宝源"><a href="#设置淘宝源" class="headerlink" title="设置淘宝源"></a>设置淘宝源</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>实用软件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>nvm快速安装</title>
    <url>/2024/01/09/2024/nvm/</url>
    <content><![CDATA[<h1 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install file</span></span><br><span class="line">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This loads nvm</span></span><br><span class="line">export NVM_DIR=&quot;$([ -z &quot;$&#123;XDG_CONFIG_HOME-&#125;&quot; ] &amp;&amp; printf %s &quot;$&#123;HOME&#125;/.nvm&quot; || printf %s &quot;$&#123;XDG_CONFIG_HOME&#125;/nvm&quot;)&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; </span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/nvm-sh/nvm?tab=readme-ov-file#install--update-script</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>实用软件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh主题p10k快速安装</title>
    <url>/2024/03/09/2024/p10k/</url>
    <content><![CDATA[<p>zsh主题p10k快速安装命令集合</p>
<span id="more"></span>

<h1 id="install"><a href="#install" class="headerlink" title="install"></a>install</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zsh</span></span><br><span class="line">sudo apt install zsh</span><br><span class="line">chsh -s $(which zsh)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ohmyzsh</span></span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">p10k</span></span><br><span class="line">git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k</span><br><span class="line">sed -i &#x27;s#robbyrussell#powerlevel10k/powerlevel10k#&#x27; ~/.zshrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">plugin</span></span><br><span class="line">sed -i &#x27;s/plugins=(git)/\</span><br><span class="line">plugins=( \</span><br><span class="line">  git \</span><br><span class="line">  command-not-found \</span><br><span class="line">  colored-man-pages \</span><br><span class="line">  vi-mode \</span><br><span class="line">  zsh-autosuggestions \</span><br><span class="line">  zsh-syntax-highlighting \</span><br><span class="line">)/&#x27; ~/.zshrc</span><br><span class="line"></span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">z.lua</span></span><br><span class="line">sudo apt install -y lua5.2</span><br><span class="line">git clone https://github.com/skywind3000/z.lua.git ~/.z.lua</span><br><span class="line">echo &#x27;eval &quot;$(lua ~/.z.lua/z.lua  --init zsh once enhanced)&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 zsh 并配置 p10k</span></span><br><span class="line">exec zsh</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>实用软件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>plimit</title>
    <url>/2024/06/09/2024/plimit/</url>
    <content><![CDATA[<h3 id="两种实现-plimit-的方式"><a href="#两种实现-plimit-的方式" class="headerlink" title="两种实现 plimit 的方式"></a>两种实现 plimit 的方式</h3><span id="more"></span>

<h1 id="第一种实现"><a href="#第一种实现" class="headerlink" title="第一种实现"></a>第一种实现</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">request1</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">request2</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">request3</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">        &#125;, <span class="number">300</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">request4</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">        &#125;, <span class="number">400</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addRequest = <span class="title function_">scheduler</span>(<span class="number">2</span>);</span><br><span class="line"><span class="title function_">addRequest</span>(request1).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">addRequest</span>(request2).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">addRequest</span>(request3).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">addRequest</span>(request4).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withResolvers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> promise, resolve, reject;</span><br><span class="line">    promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve = res;</span><br><span class="line">        reject = rej;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        promise,</span><br><span class="line">        resolve,</span><br><span class="line">        reject</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduler</span>(<span class="params">concurrent</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">process</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= concurrent) <span class="keyword">return</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">const</span> &#123;request, promise, resolve, reject&#125; = queue.<span class="title function_">shift</span>() || &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!request) <span class="keyword">return</span>;</span><br><span class="line">        <span class="title function_">request</span>().<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(val);</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="title function_">process</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">request</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;promise, resolve, reject&#125; = <span class="title function_">withResolvers</span>();</span><br><span class="line">        queue.<span class="title function_">push</span>(&#123;request, promise, resolve, reject&#125;);</span><br><span class="line">        <span class="title function_">process</span>();</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二种实现"><a href="#第二种实现" class="headerlink" title="第二种实现"></a>第二种实现</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (url % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">val</span>: url &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(&#123; <span class="attr">status</span>: <span class="number">2</span>, <span class="attr">val</span>: url &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">conCurrency</span>(<span class="params">urls, maxCon</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line">        <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">process</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt === urls.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> url = urls[index];</span><br><span class="line">            <span class="keyword">let</span> i = index;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fn</span>(url)</span><br><span class="line">                result[i] = res;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                result[i] = err;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (cnt === urls.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">process</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxCon; i++) &#123;</span><br><span class="line">            <span class="title function_">process</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> urls = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="title function_">conCurrency</span>(urls, <span class="number">3</span>).<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>手写题</tag>
      </tags>
  </entry>
  <entry>
    <title>react学习记录</title>
    <url>/2024/01/09/2024/react/</url>
    <content><![CDATA[<h1 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h1><p>useState<br>useEffect<br>useMemo<br>useCallback</p>
<hr>
<p><em>useState</em> 和 <em>useEffect</em></p>
<p>useEffect</p>
<p>1.常见的副作用有发送网络请求、添加一些监听的注册和取消注册，手动修改 <em>DOM</em>，以前我们是将这些副作用写在生命周期钩子函数里面，现在就可以书写在 <em>useEffect</em> 这个 <em>Hook</em> 里面</p>
<p>2.执行清理工作</p>
<p>3.副作用的依赖</p>
<p>在 <code>useEffect</code> 钩子中，第二个参数 <code>[location]</code> 是一个依赖数组，它指定了在什么情况下 <code>useEffect</code> 中的回调函数应该被执行。</p>
<p>目前，我们的副作用函数，每次重新渲染后，都会重新执行，有些时候我们是需要设置依赖项，传递第二个参数，第二个参数为一个依赖数组  如果想要副作用只执行一次，传递第二个参数为一个空数组   </p>
<h2 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 <em>Hook</em></h2><p>除了使用官方内置的 <em>Hook</em>，我们还可以自定义 <em>Hook</em>，自定义 <em>Hook</em> 的本质其实就是函数，但是和普通函数还是有一些区别，主要体现在以下两个点：</p>
<ul>
<li>自定义 <em>Hook</em> 能够调用诸如 <em>useState</em>、<em>useRef</em> 等，普通函数则不能。由此可以通过内置的 <em>Hooks</em> 获得 <em>Fiber</em> 的访问方式，可以实现在组件级别存储数据的方案等。</li>
<li>自定义 <em>Hooks</em> 需要以 <em>use</em> 开头，普通函数则没有这个限制。使用 <em>use</em> 开头并不是一个语法或者一个强制性的方案，更像是一个约定。</li>
</ul>
<p><em>App.jsx</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">import useMyBook from &quot;./useMyBook&quot;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line"></span><br><span class="line">  const &#123;bookName, setBookName&#125; = useMyBook();</span><br><span class="line">  const [value, setValue] = useState(&quot;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  function changeHandle(e)&#123;</span><br><span class="line">    setValue(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function clickHandle()&#123;</span><br><span class="line">    setBookName(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;&#123;bookName&#125;&lt;/div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;changeHandle&#125;/&gt;</span><br><span class="line">      &lt;button onClick=&#123;clickHandle&#125;&gt;确定&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p><em>useMyBook</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">function useMyBook()&#123;</span><br><span class="line">    const [bookName, setBookName] = useState(&quot;React 学习&quot;);</span><br><span class="line">    return &#123;</span><br><span class="line">        bookName, setBookName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default useMyBook;</span><br></pre></td></tr></table></figure>



<h1 id="常用的生命周期钩子函数"><a href="#常用的生命周期钩子函数" class="headerlink" title="常用的生命周期钩子函数"></a>常用的生命周期钩子函数</h1><p>有关生命周期钩子函数的介绍，可以参阅官网：<em><a class="link"   href="https://zh-hans.reactjs.org/docs/react-component.html" >https://zh-hans.reactjs.org/docs/react-component.html<i class="fas fa-external-link-alt"></i></a></em></p>
<p>官网中在介绍这些钩子函数时，也是分为了<strong>常用</strong>和<strong>不常用</strong>两大块来介绍的。</p>
<p>常用的生命周期钩子函数如下：</p>
<ul>
<li><p><em>constructor</em></p>
<ul>
<li>同一个组件对象只会创建一次</li>
<li>不能在第一次挂载到页面之前，调用 <em>setState</em>，为了避免问题，构造函数中严禁使用 <em>setState</em></li>
</ul>
</li>
<li><p><em>render</em></p>
<ul>
<li><em>render</em> 是整个类组件中必须要书写的生命周期方法</li>
<li>返回一个虚拟 <em>DOM</em>，会被挂载到虚拟 <em>DOM</em> 树中，最终渲染到页面的真实 <em>DOM</em> 中</li>
<li><em>render</em> 可能不只运行一次，只要需要重新渲染，就会重新运行</li>
<li>严禁使用 <em>setState</em>，因为可能会导致无限递归渲染</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">// 类组件</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    // 主要做一些初始化操作，例如该组件的状态</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      value : 1</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;constructor&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  clickHandle=()=&gt;&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      value : this.state.value + 1</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&quot;render&quot;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;this.state.value&#125;&lt;/div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.clickHandle&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><em>componentDidMount</em><ul>
<li>类似于 <em>Vue</em> 里面的 <em>mounted</em></li>
<li>只会执行一次</li>
<li>可以使用 <em>setState</em></li>
<li>通常情况下，会将网络请求、启动计时器等一开始需要的操作，书写到该函数中</li>
</ul>
</li>
<li><em>componentWillUnmount</em><ul>
<li>通常在该函数中销毁一些组件依赖的资源，比如计时器</li>
</ul>
</li>
</ul>
<h1 id="react大概的一些东西"><a href="#react大概的一些东西" class="headerlink" title="react大概的一些东西"></a>react大概的一些东西</h1><p>状态(redux)    路由(react-router)   组件(通信， 类&amp;函数)<br>hooks vdom 生命周期</p>
<p>类组件：继承class 生命周期 this state</p>
<p>函数组件：hooks支撑补全功能</p>
<p>vue使用<code>key</code> v-if 标识一个独立的元素 v-for 高效更新渲染虚拟dom  vnode的唯一标识，通过key diff操作更简单，准确</p>
<p>React使用 <code>key</code> 来确定组件是否需要被重新创建或更新</p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>pnpm</title>
    <url>/2025/01/02/2024/pnpm/</url>
    <content><![CDATA[<p>软硬链接区别</p>
<p>在 node_modules 下出现的包是软链接到.pnpm下的，.pnpm 下的是硬连接，也可能包含软链接，具体看列出的文件信息</p>
<p>ls -liah 可以看到当前文件是软链接还是硬连接</p>
<p><a class="link"   href="https://juejin.cn/post/6844903438560526343?searchId=2025010211401736AE6E98B68076288E45" >https://juejin.cn/post/6844903438560526343?searchId=2025010211401736AE6E98B68076288E45<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>scss的学习记录</title>
    <url>/2024/03/19/2024/scss/</url>
    <content><![CDATA[<p>@use : 用于将另一个文件导入进来 使用里面的东西 （模块）</p>
<p>@mixin — @include</p>
<p>% — @extend </p>
<p>@each $var in (primary, success) {}</p>
<p>@for $i from 1 through 9 {}</p>
<p>@if @else</p>
<p>@at-root 这对于在嵌套规则中编写样式时希望某些规则能够跳出嵌套作用域</p>
<p>@content</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@function</span><br><span class="line">@return</span><br><span class="line">#&#123;&#125;</span><br></pre></td></tr></table></figure>





<p>变量$  </p>
<p>嵌套</p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>面试总结</title>
    <url>/2024/05/09/2024/interview/</url>
    <content><![CDATA[<h1 id="请阐述JWT的令牌格式"><a href="#请阐述JWT的令牌格式" class="headerlink" title="请阐述JWT的令牌格式"></a>请阐述JWT的令牌格式</h1><p>token 分为三段，分别是 header、payload、signdture<br>其中，header标识签名算法和令牌类型;payload 标识主体信息，包含令牌过期时间发布时间、发行者、主体内容等;signature 是使用特定的算法对前面两部分进行加密得到的加密结果。<br>token 有防篡改的特点，如果攻击者改动了前面两个部分，就会导致和第三部分对应不上.<br>使得 token 失效。而攻击者不知道加密秘钥，因此又无法修改第三部分的值。<br>所以，在秘钥不被泄露的前提下，一个验证通过的 token 是值得被信任的。</p>
<h1 id="前端跨域方案"><a href="#前端跨域方案" class="headerlink" title="前端跨域方案"></a>前端跨域方案</h1><p><a class="link"   href="https://juejin.cn/post/6844903882083024910" >https://juejin.cn/post/6844903882083024910<i class="fas fa-external-link-alt"></i></a></p>
<p>代理   配置devserver  vue.config.js文件<br>CORS 规定了三种不同的交互模式      简单 预检 身份凭证<br>jsonp   script标签，函数 服务端客户端  get请求</p>
<p>JSONP的做法是：<strong>当需要跨域请求时，不使用AJAX，转而生成一个script元素去请求服务器，由于浏览器并不阻止script元素的请求，这样请求可以到达服务器。服务器拿到请求后，响应一段JS代码，这段代码实际上是一个函数调用，调用的是客户端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端</strong></p>
<p><strong>同源策略</strong>：同源策略是一种约定，限制某些操作只能在同源（协议、域名、端口）的情况下执行。这是浏览器安全性能的一部分，防止恶意代码从不同来源访问本地资源</p>
<h5 id="1-代理"><a href="#1-代理" class="headerlink" title="1.代理"></a>1.代理</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue 的开发服务器代理配置</span></span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123; <span class="comment">// 配置开发服务器</span></span><br><span class="line">    <span class="attr">proxy</span>: &#123; <span class="comment">// 配置代理</span></span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123; <span class="comment">// 若请求路径以 /api 开头</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://dev.taobao.com&quot;</span>, <span class="comment">// 将其转发到 http://dev.taobao.com</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>CORS（跨源资源共享）</strong>：CORS 是一种 W3C 标准，允许网页从不同的域访问资源，而不会受到同源策略的限制。CORS 提供了一种灵活的跨域访问控制方式，通过添加特定的 HTTP 头部信息来控制请求和响应<a class="link"   href="https://zhuanlan.zhihu.com/p/142984955?utm_id=0" >1<i class="fas fa-external-link-alt"></i></a>.</p>
<p>通过后端设置响应头来允许特定的源进行访问。比如，<code>Access-Control-Allow-Origin:</code></p>
<p><strong><code>Access-Control-Allow-Credentials</code> HTTP头</strong>：该响应头告诉浏览器，当web应用设置了xhr的withCredential属性时，是否允许浏览器发送Cookie，如果后端设置该选项为true，且前端的 xhr也设置了 withCredentials &#x3D; true。则请求会携带Cookie信息</p>
<p><strong>JSONP（JSON with Padding）</strong>：JSONP 是一种在现代网络应用中广泛使用的方法，允许通过在脚本标签的 <code>src</code> 属性中指定一个 JavaScript 或 JSON 文件来实现跨域请求。JSONP 的主要优点是可以绕过同源策略限制，实现跨域数据交换<a class="link"   href="https://zhuanlan.zhihu.com/p/142984955?utm_id=0" >1<i class="fas fa-external-link-alt"></i></a>.</p>
<p><strong>WebSocket</strong>：WebSocket 是一种实时通信协议，允许客户端与服务器建立持久连接，实现跨域通信。WebSocket 可以在同源和跨源之间建立连接，因此不受同源策略的限制<a class="link"   href="https://zhuanlan.zhihu.com/p/142984955?utm_id=0" >1<i class="fas fa-external-link-alt"></i></a>.</p>
<p><strong>postMessage</strong>：postMessage 是一种在不同源的 iframe 之间进行通信的方法，允许 iframe 中的文档与其容器文档进行通信。虽然 postMessage 不受同源策略限制，但在使用时仍需注意安全问题<a class="link"   href="https://zhuanlan.zhihu.com/p/142984955?utm_id=0" >1<i class="fas fa-external-link-alt"></i></a>.</p>
<p><strong>图像（image）请求</strong>：图像请求是一种实现跨域数据交换的方法，通过向服务器发送一个图像请求，从服务器返回图像数据，而实际上这个图像数据可以包含任意类型的数据。这种方法可以绕过同源策略限制，但可能会导致一些安全问题</p>
<hr>
<p>JSONP（JSON with Padding）是一种解决跨域问题的方法，它的工作原理如下：</p>
<ol>
<li>利用 <code>script</code> 标签的 <code>src</code> 属性实现跨域请求。通过将 <code>src</code> 属性设置为一个跨域 URL，可以实现从不同域访问资源<a class="link"   href="https://github.com/YvetteLau/Step-By-Step/issues/30" >2<i class="fas fa-external-link-alt"></i></a>.</li>
<li>前端将回调函数作为参数传给服务器，服务器注入参数后再返回。这样，通过在 <code>script</code> 标签的 <code>src</code> 属性中添加回调函数，可以实现跨域数据交换<a class="link"   href="https://github.com/YvetteLau/Step-By-Step/issues/30" >2<i class="fas fa-external-link-alt"></i></a>.</li>
</ol>
<p>具体实现步骤如下：</p>
<ol>
<li>在前端代码中，定义一个回调函数，例如 <code>jsonhandle</code>，用于处理返回的数据<a class="link"   href="https://juejin.cn/post/6969526457009700877" >5<i class="fas fa-external-link-alt"></i></a>.</li>
<li>创建一个 <code>script</code> 标签，并设置 <code>src</code> 属性为需要访问的跨域 URL，例如 <code>http://www.practice-zhao.com/remote.js</code><a class="link"   href="https://juejin.cn/post/6969526457009700877" >5<i class="fas fa-external-link-alt"></i></a>.</li>
<li>当 <code>script</code> 标签加载完成后，服务器会调用回调函数并传递返回的数据<a class="link"   href="https://juejin.cn/post/6969526457009700877" >5<i class="fas fa-external-link-alt"></i></a>.</li>
<li>在回调函数中处理返回的数据，例如弹出提示框<a class="link"   href="https://juejin.cn/post/6969526457009700877" >5<i class="fas fa-external-link-alt"></i></a>.</li>
</ol>
<p>总之，JSONP 的工作原理是利用 <code>script</code> 标签的 <code>src</code> 属性实现跨域请求，通过在 <code>script</code> 标签的 <code>src</code> 属性中添加回调函数，实现跨域数据交换。这种方法可以绕过同源策略限制，实现跨域通信。</p>
<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><p>用户只需在一个应用程序中进行一次身份验证，然后可以在其他应用程序中自动登录。这种方式的优点包括<strong>提高安全性、提高用户体验和降低维护成本</strong></p>
<p>单点登录的工作原理如下：</p>
<p>用户首次访问某个应用程序，并进行身份验证。在验证通过后，该应用程序会生成一个 Token，并将其保存在数据库中，例如数据库中。同时，将 Token 写入到 Cookie 中，以便在其他应用程序中使用<a class="link"   href="https://zhuanlan.zhihu.com/p/66037342?utm_id=0" >5<i class="fas fa-external-link-alt"></i></a>.</p>
<p>用户在其他应用程序中需要登录时，这些应用程序会检查 Cookie，并从数据库中获取用户的 Token。如果 Token 验证通过，则认为用户已登录<a class="link"   href="https://zhuanlan.zhihu.com/p/66037342?utm_id=0" >5<i class="fas fa-external-link-alt"></i></a>.</p>
<p>在某些情况下，可以使用第三方身份验证服务（如 Google、Facebook 等）进行单点登录。用户在这些服务上进行身份验证后，可以在其他应用程序中自动登录。这种方式的优点是减少了用户需要记住多个密码的麻烦</p>
<h1 id="XSS-攻击场景-Cross-Site-Scripting"><a href="#XSS-攻击场景-Cross-Site-Scripting" class="headerlink" title="XSS 攻击场景 Cross-Site Scripting"></a>XSS 攻击场景 Cross-Site Scripting</h1><p>XSS（跨站脚本攻击）是一种利用网页开发中的漏洞，<strong>通过表单 向页面注入恶意脚本</strong>的攻击方式。以下是一些 XSS 攻击的场景：</p>
<ol>
<li><strong>存储型 XSS 攻击</strong>：攻击者将恶意脚本存储在服务器端，当用户访问包含这些恶意脚本的页面时，恶意脚本会被执行，从而导致攻击成功。</li>
<li><strong>反射型 XSS 攻击</strong>：攻击者构造包含恶意脚本的 URL，诱使用户点击该 URL，恶意脚本随 URL 一起发送到服务器，服务器将恶意脚本反射给用户的浏览器执行，从而实施攻击。</li>
<li><strong>DOM 型 XSS 攻击</strong>：攻击者构造包含恶意脚本的 URL，当用户访问包含这些恶意脚本的页面时，恶意脚本会被执行，从而导致攻击成功。与存储型和反射型 XSS 不同，DOM 型 XSS 攻击不涉及服务器端的代码。</li>
</ol>
<h1 id="CSRF-攻击场景-Cross-Site-Request-Forgery"><a href="#CSRF-攻击场景-Cross-Site-Request-Forgery" class="headerlink" title="CSRF 攻击场景 Cross-Site Request Forgery"></a>CSRF 攻击场景 Cross-Site Request Forgery</h1><p>CSRF（跨站请求伪造）是一种利用用户在已认证的情况下对应用程序发起的非预期请求的攻击方式。以下是一些 CSRF 攻击的场景：</p>
<p>本质是<strong>利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充</strong></p>
<p>常见的 CSRF 攻击有三种：</p>
<ul>
<li>GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li>
<li>POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li>
<li>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li>
</ul>
<p>CSRF 攻击的工作原理如下：</p>
<ol>
<li>攻击者构造一个恶意网页，诱使用户在已认证的情况下访问该网页，从而触发用户在目标网站上执行转账等操作，实施攻击。</li>
<li>当用户访问恶意网页时，攻击者的脚本会将用户的请求头修改，使其看起来像是来自攻击者的服务器的请求。因为请求来自已认证的用户，服务器会认为这是一个真实的请求，并执行请求中所描述的命令。</li>
<li>攻击者的服务器会接收到请求，执行请求中的操作，例如转发请求到其他服务器，然后将响应返回给用户的浏览器。</li>
<li>用户的浏览器接收到响应，并显示请求所执行的操作的结果。</li>
</ol>
<p>为了防范 CSRF 攻击，开发人员可以采取以下措施：</p>
<p>将请求头中的 CSRF 令牌添加到每个请求中，以便服务器能够验证请求的真实性</p>
<p>在服务器端检查请求中的 CSRF 令牌，并确保请求是来自真实的用户</p>
<p>使用 CSRF 过滤器，对出going requests 和 incoming requests 进行检测，以确保请求的真实性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSRF是跨站请求伪造，是一种挟制用户在当前已登录的Web应用上执行非本意的操作的攻击方法</span><br><span class="line">它首先引导用户访问一个危险网站，当用户访问网站后，网站会发送请求到被攻击的站点，这次请求会携带用户的cookie发送，因此就利用了用户的身份信息完成攻击</span><br><span class="line"></span><br><span class="line">防御CSRF攻击有多种手段</span><br><span class="line">不使用cookie</span><br><span class="line">为表单添加校验的 token 校验 scrf token</span><br><span class="line">cookie中使用sameSite字段</span><br><span class="line">服务器检查 referer字段</span><br></pre></td></tr></table></figure>





<h1 id="前端性能优化有很多手段，以下是一些常见的方法："><a href="#前端性能优化有很多手段，以下是一些常见的方法：" class="headerlink" title="前端性能优化有很多手段，以下是一些常见的方法："></a>前端性能优化有很多手段，以下是一些常见的方法：</h1><ol>
<li><strong>减少 HTTP 请求数量</strong>：减少页面中的 HTTP 请求数量，减少网络传输次数，提高页面加载速度。可以通过将多个请求合并为一个请求、减少不必要的图片和资源加载等方式实现<a class="link"   href="https://juejin.cn/post/7145732149943992328" >1<i class="fas fa-external-link-alt"></i></a><a class="link"   href="https://www.zhihu.com/question/40505685/answer/1284521344?utm_id=0" >2<i class="fas fa-external-link-alt"></i></a>.</li>
<li><strong>使用 CDN（Content Delivery Network，内容交付网络）</strong>：利用 CDN 可以将静态资源缓存在全球各地的服务器上，减少用户需要向服务器发送请求的距离，提高页面加载速度。</li>
<li><strong>优化图片和媒体加载</strong>：优化图片和媒体的加载方式，如使用 <code>lazy-loading</code> 技术，延迟加载不在视口内的图片和媒体，减少不必要的资源加载。</li>
<li><strong>减少 DNS 请求数量</strong>：减少页面中的 DNS 请求数量，减少 DNS 解析次数，提高页面加载速度。可以通过将多个域名合并为一个域名、减少不必要的域名解析请求等方式实现<a class="link"   href="https://juejin.cn/post/7145732149943992328" >1<i class="fas fa-external-link-alt"></i></a>.</li>
<li><strong>使用浏览器缓存</strong>：利用浏览器缓存存储静态资源，避免在每次页面加载时重新加载静态资源，提高页面加载速度。</li>
<li><strong>压缩和混淆代码</strong>：压缩和混淆代码，减少代码文件的大小，提高代码传输速度。</li>
<li><strong>开启 Keep-Alive 连接</strong>：开启 Keep-Alive 连接，避免在每次请求后立即关闭连接，提高连接复用率，提高页面加载速度。</li>
<li><strong>使用服务器压缩</strong>：利用服务器压缩，减少响应头大小，提高页面加载速度</li>
</ol>
<h1 id="常用的设计模式包括但不限于以下几种："><a href="#常用的设计模式包括但不限于以下几种：" class="headerlink" title="常用的设计模式包括但不限于以下几种："></a>常用的设计模式包括但不限于以下几种：</h1><ol>
<li><p><strong>单例模式（Singleton）</strong>：确保一个类只有一个实例，并提供一个全局访问点。</p>
</li>
<li><p><strong>工厂模式（Factory）</strong>：定义一个用于创建对象的接口，让子类决定实例化哪一个类。</p>
</li>
<li><p><strong>观察者模式（Observer）</strong>：定义对象间的一对多依赖关系，当一个对象改变状态，依赖它的对象会收到通知并自动更新。</p>
</li>
<li><p><strong>策略模式（Strategy）</strong>：定义一系列算法，将每一个算法封装起来，并使它们可以互相替换。</p>
</li>
<li><p><strong>适配器模式（Adapter）</strong>：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p>
</li>
<li><p><strong>模块模式 (Module Pattern)</strong></p>
<ul>
<li><strong>应用场景</strong>：用于封装一组功能有关的代码段，创建私有空间，避免全局作用域污染。JavaScript库和框架中广泛使用，如jQuery的插件系统。</li>
<li><strong>优点</strong>：减少全局变量，提高代码的复用性与可维护性。</li>
<li><strong>示例代码</strong>：使用IIFE（立即调用函数表达式）来创建模块。</li>
</ul>
</li>
<li><p><strong>单例模式 (Singleton Pattern)</strong></p>
<ul>
<li><strong>应用场景</strong>：当系统中需要一个类只有一个实例时使用，如全局缓存、浏览器的窗口对象等。</li>
<li><strong>优点</strong>：确保一个类只有一个实例，并提供全局访问点。</li>
<li><strong>示例代码</strong>：实例化一次后存储起来，后续使用直接返回该实例。</li>
</ul>
</li>
<li><p><strong>观察者模式 (Observer Pattern) &#x2F; 发布-订阅模式 (Pub-Sub Pattern)</strong></p>
<ul>
<li><strong>应用场景</strong>：一个对象的状态变化需要通知其他依赖对象时使用，如用户界面和数据模型之间的绑定，事件处理系统。</li>
<li><strong>优点</strong>：对象之间的耦合度降低，增加了系统的灵活性。</li>
<li><strong>示例代码</strong>：事件监听和事件触发机制。</li>
</ul>
</li>
<li><p><strong>装饰器模式 (Decorator Pattern)</strong></p>
<ul>
<li><strong>应用场景</strong>：在不改变原始对象的基础上，添加新的功能，如React组件的高阶组件（HOC）。</li>
<li><strong>优点</strong>：增强类的职责，可用于扩展功能。</li>
<li><strong>示例代码</strong>：不修改原有对象的基础上进行包装扩展。</li>
</ul>
</li>
<li><p><strong>策略模式 (Strategy Pattern)</strong></p>
<ul>
<li><strong>应用场景</strong>：当存在多种算法或策略，且它们可以互相替换时使用，如表单验证策略。</li>
<li><strong>优点</strong>：定义一系列的算法家族，使他们可以相互替换。</li>
<li><strong>示例代码</strong>：将算法封装成不同的策略类，根据上下文动态选择使用。</li>
</ul>
</li>
<li><p><strong>工厂模式 (Factory Pattern)</strong></p>
<ul>
<li><strong>应用场景</strong>：创建对象时不暴露创建逻辑，且可以引用预先定义的接口，如生成不同类型的视图组件。</li>
<li><strong>优点</strong>：创建对象时，用工厂方法代替new操作的一种模式。</li>
<li><strong>示例代码</strong>：创建一个工厂类，用来生成基于共同接口的实例。</li>
</ul>
</li>
<li><p><strong>外观模式 (Facade Pattern)</strong></p>
<ul>
<li><strong>应用场景</strong>：提供一个统一的接口来访问子系统中的一群接口，简化了客户端与子系统之间的复杂性，如JQuery对DOM操作的简化。</li>
<li><strong>优点</strong>：对客户屏蔽子系统组件的复杂性。</li>
<li><strong>示例代码</strong>：封装复杂的API调用，提供简单的接口。</li>
</ul>
</li>
<li><p><strong>命令模式 (Command Pattern)</strong></p>
<ul>
<li><strong>应用场景</strong>：将请求封装为对象，以便使用不同的请求、队列或日志来参数化其他对象，命令可以支持撤销操作。</li>
<li><strong>优点</strong>：将发起命令的对象与执行命令的对象分离。</li>
<li><strong>示例代码</strong>：把一个或多个命令封装到一个对象中。</li>
</ul>
</li>
<li><p><strong>状态模式 (State Pattern)</strong></p>
<ul>
<li><strong>应用场景</strong>：对象的状态变化很频繁，且依据不同状态改变其行为时，如游戏中的角色状态、UI组件的状态管理。</li>
<li><strong>优点</strong>：封装基于状态的行为，并将行为委托到当前状态。</li>
<li><strong>示例代码</strong>：状态机实现。</li>
</ul>
</li>
</ol>
<p>HTTPS和HTTP的区别在于HTTPS是安全超文本传输协议，它使用SSL&#x2F;TLS协议对数据进行加密，而HTTP传输的数据是未加密的。HTTPS的默认端口是443，而HTTP的默认端口是80。HTTPS可以提高网站的权威性、可信度和搜索引擎排名</p>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>内存泄漏（memory leak）是计算机科学中的一种资源泄漏，主要是由于计算机程序的内存管理失当，导致程序无法释放已申请的内存空间，从而导致内存空间不断累积<a class="link"   href="https://zhuanlan.zhihu.com/p/69151763?utm_id=0" >1<i class="fas fa-external-link-alt"></i></a><a class="link"   href="https://zh.wikipedia.org/zh-cn/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" >4<i class="fas fa-external-link-alt"></i></a>。内存泄漏的危害包括：</p>
<ul>
<li>导致计算机性能下降，严重时可能导致计算机崩溃</li>
<li>导致内存泄漏堆积，可能导致程序崩溃</li>
<li>导致资源不可用，可能导致程序功能出现异常</li>
</ul>
<p>内存泄漏的原因可能包括以下几点：</p>
<ul>
<li>程序在不再需要时仍然保留内存，导致内存泄漏</li>
<li>程序在释放内存时失败，导致内存泄漏</li>
<li>程序在分配内存时失败，导致内存泄漏</li>
</ul>
<p>为了避免内存泄漏，程序员需要注意以下几点：</p>
<ul>
<li>在不再需要时释放内存，以避免内存泄漏</li>
<li>在分配内存时和释放内存时都要进行正确的错误处理，以避免内存泄漏</li>
<li>定期检查程序中的内存使用，以及定期回收不再使用的内存，以避免内存泄漏</li>
</ul>
<p>总之，内存泄漏是计算机科学中的一种资源泄漏，主要是由于计算机程序的内存管理失当。为了避免内存泄漏，程序员需要注意内存分配和释放的错误处理，以及定期检查和回收不再使用的内存。</p>
<p>websocket</p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20231230124213875.png"  alt="image-20231230124213875"></p>
<p>应用在聊天 游戏 低延迟    是一种协议</p>
<p>WebSocket是一种在单个TCP连接上提供全双工通信的网络协议。它允许客户端和服务器之间的实时数据传输，而不需要通过多次HTTP请求-响应交互。WebSocket协议最初由IETF（Internet Engineering Task Force）制定，而后被RFC 6455正式标准化。</p>
<p>以下是WebSocket的一些关键特点和工作原理：</p>
<ol>
<li><strong>全双工通信：</strong> WebSocket允许在同一连接上同时进行双向通信。客户端和服务器都可以通过单个连接发送消息，而无需等待对方的响应。</li>
<li><strong>轻量级：</strong> 与HTTP相比，WebSocket协议的握手过程相对简单，减少了通信的开销。一旦建立连接，数据的传输变得更加高效。</li>
<li><strong>实时性：</strong> 由于WebSocket支持实时通信，它特别适用于需要低延迟和高实时性的应用，如在线游戏、聊天应用和实时协作工具。</li>
<li><strong>持久连接：</strong> WebSocket连接可以保持打开状态，允许持续的数据传输，而不必在每个消息之间重新建立连接。</li>
<li><strong>安全性：</strong> 与HTTP相同，WebSocket可以通过TLS&#x2F;SSL（Secure Sockets Layer&#x2F;Transport Layer Security）提供安全的加密通信，形成WSS（WebSocket Secure）。</li>
<li><strong>适用范围：</strong> WebSocket广泛应用于Web开发领域，特别是在需要实时更新的应用中，如在线协作、实时通讯、股票市场报价等。</li>
</ol>
<p>WebSocket的握手过程涉及客户端和服务器之间的协商，以建立连接。一旦连接建立，数据可以在两者之间自由地流动，而无需频繁地重新建立连接。</p>
<p>在Web开发中，常用的WebSocket API包括JavaScript的<code>WebSocket</code>对象，它允许在浏览器中创建WebSocket连接，并通过事件处理程序处理收到的消息。后端服务也需要支持WebSocket协议以处理和响应这些连接。</p>
<p>SSL（Secure Sockets Layer）是一种用于在计算机网络上安全地传输数据的协议。SSL协议最初由网景公司（Netscape）开发，用于保护Web浏览器和服务器之间的通信。然而，由于安全漏洞和其他问题，SSL协议的版本被后来的TLS（Transport Layer Security）协议所取代。因此，现在通常称之为TLS协议，而不是SSL协议。</p>
<p>TLS协议的目标是提供通信的保密性和完整性，确保数据在传输过程中不被篡改或窃取。它使用加密算法、数字证书和其他安全机制来实现这些目标。TLS协议通常在Web浏览器和服务器之间的HTTPS连接中使用，以确保用户与网站之间的安全通信。</p>
<p>主要的TLS协议版本包括：</p>
<ol>
<li><strong>TLS 1.0:</strong> 最早的TLS版本，仍然存在一些安全漏洞，不再被推荐使用。</li>
<li><strong>TLS 1.1:</strong> 针对TLS 1.0的一些漏洞进行改进，但也已经过时，不再被广泛支持。</li>
<li><strong>TLS 1.2:</strong> 当前广泛采用的版本，提供更强大的安全性和性能。大多数现代浏览器和服务器都支持TLS 1.2。</li>
<li><strong>TLS 1.3:</strong> 目前最新的版本，引入了一些新的安全特性，并通过优化提高了握手过程的效率。TLS 1.3的采用逐渐增加，以提高网络通信的安全性。</li>
</ol>
<h1 id="网页加载缓慢解决方案"><a href="#网页加载缓慢解决方案" class="headerlink" title="网页加载缓慢解决方案"></a>网页加载缓慢解决方案</h1><ol>
<li><strong>分析性能：</strong> 使用浏览器的开发者工具，特别是网络面板和性能面板，来分析页面加载过程。这将帮助你找到加载时间长的资源、慢请求或其他性能瓶颈。</li>
<li><strong>压缩和合并资源：</strong> 确保CSS和JavaScript文件被压缩和合并，以减少文件大小和请求次数。这可以通过使用构建工具（如Webpack、Gulp）来实现。</li>
<li><strong>使用CDN：</strong> 将静态资源（如图片、样式表、脚本）托管在内容分发网络（CDN）上，以确保用户从离他们更近的服务器获取资源，从而加快加载速度。</li>
<li><strong>启用浏览器缓存：</strong> 设置合适的缓存头，允许浏览器缓存静态资源，从而减少重复加载。</li>
<li><strong>懒加载：</strong> 对于页面上非必要的资源，使用懒加载技术。这意味着只有在用户需要时才加载这些资源，而不是一开始就全部加载。</li>
<li><strong>异步加载脚本：</strong> 将不影响初始渲染的脚本标记为异步加载，以避免阻塞页面的加载。</li>
<li><strong>优化图片：</strong> 使用适当大小和格式的图片，并考虑使用图像压缩工具。还可以使用图片懒加载，仅当图像出现在用户视口时才加载。</li>
<li><strong>服务端性能优化：</strong> 确保服务器响应时间快，可以考虑使用缓存、CDN、负载均衡等手段来提高服务端性能。</li>
<li><strong>减少HTTP请求：</strong> 减少页面上的资源数量，这将减少HTTP请求的次数。可以通过将CSS和JavaScript内联到HTML中，或者使用雪碧图等技术来减少请求次数。</li>
<li><strong>使用缓存策略：</strong> 利用浏览器缓存策略，确保不必要的资源不会在每次加载页面时都重新下载</li>
</ol>
<h1 id="页面加载的过程"><a href="#页面加载的过程" class="headerlink" title="页面加载的过程"></a>页面加载的过程</h1><ol>
<li><strong>DNS解析：</strong> 当用户在浏览器中输入URL并敲击回车后，浏览器首先会进行DNS解析，将域名解析为对应的IP地址。如果域名的解析结果已经存在于本地缓存中，这个步骤可能会被跳过。</li>
<li><strong>建立TCP连接：</strong> 浏览器使用解析得到的IP地址与服务器建立TCP连接。这包括进行三次握手，确保浏览器和服务器之间建立可靠的连接。</li>
<li><strong>发起HTTP请求：</strong> 浏览器通过已建立的TCP连接向服务器发起HTTP请求。这个请求中包含了用户请求的资源信息，例如页面的HTML、CSS文件、JavaScript文件等。</li>
<li><strong>服务器处理请求：</strong> 服务器接收到浏览器发送的请求后，开始处理请求，获取请求的资源。这可能涉及数据库查询、业务逻辑处理等。</li>
<li><strong>返回HTTP响应：</strong> 服务器将请求的资源封装在HTTP响应中，并通过已建立的TCP连接发送回浏览器。响应包括HTTP状态码、响应头和响应体。</li>
<li><strong>浏览器接收响应：</strong> 浏览器接收到服务器返回的HTTP响应后，开始解析响应。它检查状态码以确定请求是否成功，并根据响应头中的信息决定如何处理响应体。</li>
<li><strong>解析HTML：</strong> 如果响应包含HTML，浏览器开始解析HTML文档。它构建DOM（文档对象模型）树，表示页面的结构。</li>
<li><strong>构建渲染树：</strong> 浏览器将DOM树和CSS样式表结合起来，构建渲染树。渲染树是由浏览器用于绘制页面的一种表示，其中包括了需要显示的元素及其样式信息。</li>
<li><strong>布局（回流）：</strong> 浏览器根据渲染树计算每个元素在视口中的准确位置，这个过程被称为布局或回流。</li>
<li><strong>绘制：</strong> 浏览器使用计算好的样式信息绘制页面，将页面渲染到用户的屏幕上。</li>
<li><strong>JavaScript执行：</strong> 如果页面中包含JavaScript，浏览器会执行JavaScript代码，可能导致对DOM的修改、事件触发等。</li>
<li><strong>完成加载：</strong> 页面所有的资源都被加载和渲染完成后，浏览器触发<code>load</code>事件，表示页面加载完成。</li>
</ol>
<h1 id="回流-重排-—-重绘"><a href="#回流-重排-—-重绘" class="headerlink" title="回流 (重排) —&gt; 重绘"></a>回流 (重排) —&gt; 重绘</h1><h1 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a>LRU缓存机制</h1><p>操作系统中LRU算法</p>
<h1 id="渲染大量数据防止oom"><a href="#渲染大量数据防止oom" class="headerlink" title="渲染大量数据防止oom"></a>渲染大量数据防止oom</h1><p>1.时间分片  2.虚拟列表 动态高度难以计算的问题</p>
<h1 id="实现移动端适配"><a href="#实现移动端适配" class="headerlink" title="实现移动端适配"></a>实现移动端适配</h1><p><a class="link"   href="https://juejin.cn/post/6953091677838344199#heading-1" >https://juejin.cn/post/6953091677838344199#heading-1<i class="fas fa-external-link-alt"></i></a></p>
<p>编写 <code>&lt;meta&gt;</code> 标签设置 <code>viewport</code> 的内容 <code>width=device-width</code>，让网页宽度等于视窗宽度</p>
<p>在 css 中使用 px</p>
<p>在适当的场景使用flex布局，或者配合vw进行自适应</p>
<p>在跨设备类型的时候（pc &lt;-&gt; 手机 &lt;-&gt; 平板）使用媒体查询</p>
<p>在跨设备类型如果交互差异太大的情况，考虑分开项目开发</p>
<h1 id="文件上传下载的原理"><a href="#文件上传下载的原理" class="headerlink" title="文件上传下载的原理"></a>文件上传下载的原理</h1><p>上传</p>
<ul>
<li>HTML 中的 <code>&lt;input type=&quot;file&quot;&gt;</code> </li>
<li>浏览器会将文件包装成一个 FormData 对象，post请求发到服务器</li>
<li>从请求中提取文件数据 express </li>
<li>服务器处理</li>
</ul>
<p>下载</p>
<ul>
<li>浏览器会发送 HTTP GET 请求到服务器。</li>
<li>服务器会设置一些 HTTP 头（如 <code>Content-Disposition</code>）来指示浏览器如何处理响应</li>
<li>浏览器收到响应后，根据 HTTP 头中的信息判断如何处理文件</li>
<li>浏览器开始将文件内容下载到本地文件系统</li>
</ul>
<h1 id="使用虚拟列表"><a href="#使用虚拟列表" class="headerlink" title="使用虚拟列表"></a>使用虚拟列表</h1><p>核心思想是只渲染用户当前可见的部分，而不是整个列表。通过这种方式，可以避免在大型列表中创建大量的DOM元素，减少内存占用和提高渲染效率</p>
<ol>
<li><h5 id="1-确定可见区域"><a href="#1-确定可见区域" class="headerlink" title="1. 确定可见区域"></a>1. 确定可见区域</h5><p>首先，需要确定用户可视区域内可以显示的列表项数量。这个数量取决于列表项的高度和浏览器窗口或滚动容器的高度。</p>
<h5 id="2-计算当前显示的数据范围"><a href="#2-计算当前显示的数据范围" class="headerlink" title="2. 计算当前显示的数据范围"></a>2. 计算当前显示的数据范围</h5><p>根据用户的滚动位置，计算当前需要显示的数据范围。例如，如果列表项固定高度为50px，浏览器窗口高度为500px，那么可以显示10个列表项。当用户滚动到第100个列表项时，需要计算出应该渲染的是第90到第100个列表项。</p>
<h5 id="3-渲染可见数据"><a href="#3-渲染可见数据" class="headerlink" title="3. 渲染可见数据"></a>3. 渲染可见数据</h5><p>只渲染计算出的数据范围内的列表项。使用CSS的<code>transform</code>属性来快速定位列表的当前滚动位置，而不是通过逐个添加或删除DOM元素。</p>
<h5 id="4-监听滚动事件"><a href="#4-监听滚动事件" class="headerlink" title="4. 监听滚动事件"></a>4. 监听滚动事件</h5><p>监听滚动容器的滚动事件，当用户滚动时，实时更新可见区域的列表项。</p>
<h5 id="5-动态更新列表"><a href="#5-动态更新列表" class="headerlink" title="5. 动态更新列表"></a>5. 动态更新列表</h5><p>随着用户的滚动，动态计算并渲染新进入可视区域的列表项。</p>
</li>
</ol>
<p>虚拟列表的优点包括：</p>
<ul>
<li><strong>性能提升：</strong> 通过只渲染可见部分，减少了DOM操作和渲染时间，提高了性能。</li>
<li><strong>资源占用减少：</strong> 在大型列表中，不需要在内存中一次性创建和保留所有的DOM元素，减少了资源占用。</li>
<li><strong>更好的用户体验：</strong> 用户在滚动列表时能够更快速地获取到可见部分的数据，提升了交互体验。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;container&quot;</span> @<span class="attr">scroll</span>=<span class="string">&quot;handleScroll&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;spacer&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; height: spacerHeight + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; height: viewportHeight + &#x27;px&#x27; &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in visibleItems&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;&#123; item &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">totalItems</span>: <span class="number">1000</span>, <span class="comment">// 总条目数量</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">itemHeight</span>: <span class="number">50</span>, <span class="comment">// 单个条目的高度</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">visibleItems</span>: [], <span class="comment">// 可见条目</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">spacerHeight</span>: <span class="number">0</span>, <span class="comment">// 占位元素的高度</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">viewportHeight</span>: <span class="number">500</span>, <span class="comment">// 视口高度</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">scrollTop</span>: <span class="number">0</span>, <span class="comment">// 滚动距离</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 初始化可见条目</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">this</span>.<span class="title function_">updateVisibleItems</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 更新可见条目</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">updateVisibleItems</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> start = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="variable language_">this</span>.<span class="property">scrollTop</span> / <span class="variable language_">this</span>.<span class="property">itemHeight</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> end = <span class="title class_">Math</span>.<span class="title function_">min</span>(</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        start + <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="variable language_">this</span>.<span class="property">viewportHeight</span> / <span class="variable language_">this</span>.<span class="property">itemHeight</span>),</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">totalItems</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      );</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">visibleItems</span> = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: end - start &#125;, <span class="function">(<span class="params">_, index</span>) =&gt;</span> start + index + <span class="number">1</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">spacerHeight</span> = <span class="variable language_">this</span>.<span class="property">totalItems</span> * <span class="variable language_">this</span>.<span class="property">itemHeight</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 处理滚动事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">handleScroll</span>(<span class="params">event</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">scrollTop</span> = event.<span class="property">target</span>.<span class="property">scrollTop</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="title function_">updateVisibleItems</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.container</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">width</span>: <span class="number">300px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">height</span>: <span class="number">500px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">overflow-y</span>: auto;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.viewport</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">position</span>: relative;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">overflow</span>: hidden;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.spacer</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">width</span>: <span class="number">1px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">height</span>: <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">visibility</span>: hidden;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.item</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">height</span>: <span class="number">50px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">text-align</span>: center;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>















<h1 id="如何解决大文件上传"><a href="#如何解决大文件上传" class="headerlink" title="如何解决大文件上传"></a>如何解决大文件上传</h1><p><a class="link"   href="https://juejin.cn/post/7177045936298786872" >https://juejin.cn/post/7177045936298786872<i class="fas fa-external-link-alt"></i></a></p>
<p>在前端开发中，处理大文件上传是一个常见的需求，但由于HTTP协议的限制和浏览器的一些限制，直接上传大文件可能会遇到一些问题。以下是一些解决大文件上传的常见方法：</p>
<ol>
<li><strong>分片上传：</strong> 将大文件切分成小的文件块（chunks），然后分别上传这些小块。服务端接收到这些小块后，再将它们合并成完整的文件。这样可以避免一次性上传整个大文件可能导致的问题，并且在网络中断或上传失败的情况下可以重传特定块。</li>
<li><strong>断点续传：</strong> 结合分片上传，实现断点续传功能。即在上传过程中，如果网络中断或用户关闭页面，可以记录已上传的文件块，下次继续上传剩余的块。</li>
<li><strong>使用专用的文件上传库：</strong> 有一些专门用于处理大文件上传的JavaScript库，例如 <code>resumable.js</code>、<code>plupload</code>、<code>Uppy</code> 等。这些库提供了丰富的功能，包括分片上传、断点续传、文件预览等。</li>
<li><strong>WebSocket 或 WebRTC：</strong> 使用 WebSocket 或 WebRTC 来实现实时的、双向的数据传输，可以更灵活地处理大文件上传。这样可以实现更精确的进度显示，而且可以更容易地处理中途取消上传等操作。</li>
<li><strong>服务端配置：</strong> 调整服务器端的配置，增加对大文件上传的支持。例如，调整服务器的上传文件大小限制，优化服务器端的存储和处理大文件的性能。</li>
<li><strong>使用CDN：</strong> 使用内容分发网络（CDN）来加速文件上传和下载，以提高用户体验。</li>
</ol>
<h1 id="如何实现分片上传"><a href="#如何实现分片上传" class="headerlink" title="如何实现分片上传"></a>如何实现分片上传</h1><p>实现分片上传可以通过以下步骤：</p>
<ol>
<li><p><strong>前端切片：</strong> 将大文件切分为小块，通常每块大小为固定值。可以使用 JavaScript 中的 <code>Blob</code> 和 <code>File</code> API 来实现文件切片。这可以在前端直接进行，也可以通过后端提供的切片接口实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sliceFile</span>(<span class="params">file, chunkSize</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> chunks = [];</span><br><span class="line">  <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (offset &lt; file.<span class="property">size</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> end = <span class="title class_">Math</span>.<span class="title function_">min</span>(offset + chunkSize, file.<span class="property">size</span>);</span><br><span class="line">    <span class="keyword">const</span> chunk = file.<span class="title function_">slice</span>(offset, end);</span><br><span class="line">    chunks.<span class="title function_">push</span>(chunk);</span><br><span class="line">    offset += chunkSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> chunks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>上传切片：</strong> 将切片上传到服务器。你可以使用常规的文件上传接口，将切片通过 POST 请求发送到服务器。每个切片都应该包含一些元数据，例如切片的总数、当前切片的索引等信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uploadChunk</span>(<span class="params">chunk, index, totalChunks</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送切片到服务器</span></span><br><span class="line">  <span class="comment">// 可以使用 XMLHttpRequest 或者现代的 Fetch API</span></span><br><span class="line">  <span class="comment">// 添加额外的元数据，例如索引、总数等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>合并切片：</strong> 在服务器端，接收到所有切片后，将它们合并成完整的文件。可以根据切片的索引来确定它们的顺序。</p>
</li>
<li><p><strong>断点续传：</strong> 实现断点续传功能，以便在上传中断后能够继续上传。可以在服务器端保存已上传的切片信息，以及文件的上传状态。</p>
</li>
</ol>
<h1 id="如何实现断点续传"><a href="#如何实现断点续传" class="headerlink" title="如何实现断点续传"></a>如何实现断点续传</h1><p>断点续传是指在文件上传过程中，如果上传中断了，用户可以在中断的地方继续上传，而不需要重新上传整个文件。实现断点续传通常需要以下步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分片：将大文件分割成较小的文件块（通常是固定大小的块），每个块都有一个唯一的标识符。</span><br><span class="line">上传请求：客户端发起上传请求，并将文件分片按顺序上传到服务器。</span><br><span class="line">上传状态记录：服务器端需要记录上传的状态，包括已接收的分片、分片的顺序和完整文件的大小等信息。</span><br><span class="line">中断处理：如果上传过程中发生中断（例如网络中断、用户主动中止等），客户端可以记录已上传的分片信息，以便在恢复上传时使用。</span><br><span class="line">恢复上传：当上传中断后再次开始上传时，客户端可以发送恢复上传请求，并将已上传的分片信息发送给服务器。</span><br><span class="line">服务器处理：服务器接收到恢复上传请求后，根据已上传的分片信息，判断哪些分片已经上传，然后继续接收剩余的分片。</span><br><span class="line">合并文件：当所有分片都上传完成后，服务器将所有分片按顺序组合成完整的文件。</span><br></pre></td></tr></table></figure>



<ol>
<li><p><strong>切片文件：</strong> 将大文件切分成小块（切片），通常每个切片的大小是固定的。这样做有助于管理上传的进度和实现断点续传。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sliceFile</span>(<span class="params">file, chunkSize</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> chunks = [];</span><br><span class="line">  <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (offset &lt; file.<span class="property">size</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> end = <span class="title class_">Math</span>.<span class="title function_">min</span>(offset + chunkSize, file.<span class="property">size</span>);</span><br><span class="line">    <span class="keyword">const</span> chunk = file.<span class="title function_">slice</span>(offset, end);</span><br><span class="line">    chunks.<span class="title function_">push</span>(chunk);</span><br><span class="line">    offset += chunkSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> chunks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>上传切片：</strong> 将切片上传到服务器，可以使用文件上传的接口，每个切片都需要包含一些元数据，例如切片的索引、总数等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function uploadChunk(chunk, index, totalChunks) &#123;</span><br><span class="line">  // 发送切片到服务器</span><br><span class="line">  // 可以使用 XMLHttpRequest 或者现代的 Fetch API</span><br><span class="line">  // 添加额外的元数据，例如索引、总数等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>断点续传记录：</strong> 在服务器端记录已上传的切片信息，以及文件的上传状态。可以使用数据库或者其他持久化方式来存储这些信息。</p>
</li>
<li><p><strong>上传进度：</strong> 提供上传进度的反馈，这样用户可以清楚地看到上传的状态。可以通过监听上传事件，实时更新上传进度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function trackUploadProgress(event) &#123;</span><br><span class="line">  const progress = (event.loaded / event.total) * 100;</span><br><span class="line">  // 更新上传进度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>前端断点续传恢复：</strong> 如果上传中断，用户可以在中断的地方继续上传。前端需要知道已经上传的切片，可以在上传前检查服务器上已上传的切片信息，并从中断的地方开始上传。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function resumeUpload() &#123;</span><br><span class="line">  // 获取已上传的切片信息</span><br><span class="line">  // 继续上传剩余的切片</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>后端断点续传处理：</strong> 在服务器端，接收到已上传的切片后，根据切片的索引将它们合并成完整的文件。</p>
</li>
</ol>
<h1 id="哪些操作会造成内存泄漏"><a href="#哪些操作会造成内存泄漏" class="headerlink" title="哪些操作会造成内存泄漏"></a>哪些操作会造成内存泄漏</h1><p>循环引用    </p>
<p>使用未声明的变量</p>
<p>获取dom引用</p>
<p>计时器</p>
<p>闭包</p>
<h1 id="手写代码题"><a href="#手写代码题" class="headerlink" title="手写代码题"></a>手写代码题</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将字符串get-element-by-id用js实现变成getElementById</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/-([a-z])/g</span>, <span class="keyword">function</span> (<span class="params">match, letter</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> letter.<span class="title function_">toUpperCase</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何实现js中的repeat方法</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">customRepeat</span> = <span class="keyword">function</span> (<span class="params">count</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&quot;Count must be non-negative&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(count + <span class="number">1</span>).<span class="title function_">join</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> originalString = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> repeatedString = originalString.<span class="title function_">customRepeat</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(repeatedString); <span class="comment">// 输出 &quot;HelloHelloHello&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>













<h1 id="svg-sprite-loader是如何工作的"><a href="#svg-sprite-loader是如何工作的" class="headerlink" title="svg-sprite-loader是如何工作的"></a>svg-sprite-loader是如何工作的</h1><p><code>svg-sprite-loader</code> 是一个 webpack 加载器，用于将多个 SVG 文件打包成一个 SVG 精灵图（sprite），并生成对应的 CSS 文件，方便在项目中使用 SVG 图标。</p>
<p>它的工作原理如下：</p>
<ol>
<li><strong>收集 SVG 文件：</strong> 首先，<code>svg-sprite-loader</code> 会收集项目中的所有 SVG 文件，通常是位于某个特定目录下的多个 SVG 图标文件。</li>
<li><strong>合并 SVG 文件：</strong> 接着，它会将收集到的所有 SVG 文件合并成一个单独的 SVG 精灵图，每个图标都对应一个符号（symbol），并且为每个符号添加一个唯一的 ID。</li>
<li><strong>生成 CSS 文件：</strong> 同时，<code>svg-sprite-loader</code> 会生成一个对应的 CSS 文件，其中包含了每个图标对应的 CSS 类名和对应的位置信息。这个 CSS 文件中，每个图标对应的类名通常会包含对应的符号 ID，以便在页面中使用。</li>
<li><strong>替换引用：</strong> 最后，当需要在页面中使用某个 SVG 图标时，可以直接通过 CSS 类名来引用，webpack 会将对应的 CSS 文件加载到页面中，并根据类名将 SVG 图标渲染到页面上。这样就实现了 SVG 精灵图的效果，减少了 HTTP 请求，提高了页面性能</li>
</ol>
<p>收集</p>
<p>合并 一个精灵图 每个图标对应一个符号 每个符号有一个id</p>
<p>生成css文件 包含每个图标的css类名以及对应的符号id</p>
<p>替换引用 通过类名来引用</p>
<h1 id="讲一讲jwt如何进行鉴权"><a href="#讲一讲jwt如何进行鉴权" class="headerlink" title="讲一讲jwt如何进行鉴权"></a>讲一讲jwt如何进行鉴权</h1><p>JWT（JSON Web Token）是一种用于在网络应用间传递信息的安全方式，通常用于身份验证和在客户端和服务器之间传递用户信息。JWT通常被用于鉴权，即验证用户是否具有访问资源的权限。</p>
<p>JWT鉴权的基本流程如下：</p>
<ol>
<li><strong>用户认证</strong>：用户提供用户名和密码进行认证，服务器验证用户身份后生成JWT并返回给客户端。</li>
<li><strong>JWT生成</strong>：服务器生成JWT，其中包含一些声明（如用户ID、角色等）和有效载荷（Payload），然后使用密钥对JWT进行签名，生成最终的JWT字符串。</li>
<li><strong>客户端存储JWT</strong>：客户端通常会将JWT存储在本地，比如LocalStorage或者SessionStorage中。</li>
<li><strong>客户端请求</strong>：客户端在后续的请求中将JWT放置在请求的Header中（通常是<code>Authorization</code>头），发送给服务器。</li>
<li><strong>服务器验证JWT</strong>：服务器收到请求后，从请求的Header中提取JWT，并验证JWT的签名是否有效。如果验证成功，服务器解析JWT，获取其中的用户信息或权限信息。</li>
<li><strong>鉴权</strong>：根据JWT中的用户信息或权限信息，服务器判断用户是否有权访问请求的资源。如果有权，则返回资源；如果没有权限，则返回相应的错误信息。</li>
</ol>
<p>JWT的优点包括：</p>
<ul>
<li>无状态：服务器不需要存储用户的会话信息，所有的信息都包含在JWT中，因此可以方便地扩展和水平扩展。</li>
<li>跨域：JWT可以在跨域环境下使用，因为JWT可以包含在HTTP请求的Header中发送给服务器。</li>
<li>安全性：JWT使用签名来验证消息的完整性和来源，因此可以防止数据被篡改。</li>
</ul>
<p>header、payload、signature</p>
<h1 id="token能放在哪些地方-对应的缺点"><a href="#token能放在哪些地方-对应的缺点" class="headerlink" title="token能放在哪些地方 对应的缺点"></a>token能放在哪些地方 对应的缺点</h1><p>Token 可以放置在 HTTP 请求的不同部分，每种方式都有其优缺点。常见的地方包括：</p>
<ol>
<li><strong>HTTP Header</strong>：<ul>
<li>将 Token 放置在 HTTP 请求的头部，通常使用 <code>Authorization</code> 头部字段。</li>
<li>优点：安全性较高，不容易被 XSS 攻击获取。</li>
<li>缺点：可能存在 CSRF（跨站请求伪造）攻击的风险，需要使用额外的防护措施。</li>
</ul>
</li>
<li><strong>HTTP Cookie</strong>：<ul>
<li>将 Token 存储在客户端的 Cookie 中。</li>
<li>优点：方便，浏览器会自动在每次请求中发送 Cookie。</li>
<li>缺点：可能会受到 CSRF 攻击，需要使用额外的防护措施；另外，Cookie 也可能被窃取或者篡改。</li>
</ul>
</li>
<li><strong>HTTP 请求体</strong>：<ul>
<li>将 Token 放置在 HTTP 请求体中的某个字段中，比如 JSON 格式的请求体中。</li>
<li>优点：不容易受到 CSRF 攻击。0</li>
<li>缺点：可能会受到 XSS 攻击；另外，可能需要对请求体进行特殊处理。</li>
</ul>
</li>
<li><strong>URL 参数</strong>：<ul>
<li>将 Token 直接作为 URL 的查询参数传递。</li>
<li>优点：简单易用。</li>
<li>缺点：不安全，容易被泄露；会暴露在浏览器的地址栏中，容易被他人窥视到。</li>
</ul>
</li>
</ol>
<p>总的来说，选择哪种方式要根据具体的应用场景和安全需求来决定。通常来说，将 Token 放置在 HTTP Header 中是比较常见和推荐的做法，因为它安全性较高，且不容易受到 CSRF 攻击。如果使用其他方式，需要考虑相应的安全风险并采取相应的防护措施。</p>
<h1 id="登录单token和双token"><a href="#登录单token和双token" class="headerlink" title="登录单token和双token"></a>登录单token和双token</h1><h3 id="单token方案"><a href="#单token方案" class="headerlink" title="单token方案"></a><strong>单token方案</strong></h3><ul>
<li>将 token 过期时间设置为15分钟；</li>
<li>前端发起请求，后端验证 token 是否过期；如果过期，前端发起刷新token请求，后端为前端返回一个新的token；</li>
<li>前端用新的token发起请求，请求成功；</li>
<li>如果要实现每隔72小时，必须重新登录，后端需要记录每次用户的登录时间；用户每次请求时，检查用户最后一次登录日期，如超过72小时，则拒绝刷新token的请求，请求失败，跳转到登录页面。</li>
</ul>
<p>另外后端还可以记录刷新token的次数，比如最多刷新50次，如果达到50次，则不再允许刷新，需要用户重新授权。</p>
<h3 id="双token方案"><a href="#双token方案" class="headerlink" title="双token方案"></a><strong>双token方案</strong></h3><ul>
<li>登录成功以后，后端返回 <code>access_token</code> 和 <code>refresh_token</code>，客户端缓存此两种token;</li>
<li>使用 <code>access_token</code> 请求接口资源，成功则调用成功；如果token超时，客户端携带 <code>refresh_token</code> 调用token刷新接口获取新的 <code>access_token</code>;</li>
<li>后端接受刷新token的请求后，检查 <code>refresh_token</code> 是否过期。如果过期，拒绝刷新，客户端收到该状态后，跳转到登录页；如果未过期，生成新的 <code>access_token</code> 返回给客户端。</li>
<li>客户端携带新的 <code>access_token</code> 重新调用上面的资源接口。</li>
<li>客户端退出登录或修改密码后，注销旧的token，使 <code>access_token</code> 和 <code>refresh_token</code> 失效，同时清空客户端的 <code>access_token</code> 和 <code>refresh_toke</code>。</li>
</ul>
<h1 id="websockt心跳监听机制"><a href="#websockt心跳监听机制" class="headerlink" title="websockt心跳监听机制"></a>websockt心跳监听机制</h1><ol>
<li><strong>服务器端设置心跳间隔：</strong> 服务器端会定期向客户端发送心跳消息以确认连接的活跃状态。心跳间隔通常是在连接建立时协商确定的，并由服务器端控制。</li>
<li><strong>客户端接收心跳消息：</strong> 客户端需要监听来自服务器端的心跳消息，并在接收到心跳消息时发送相应的响应以保持连接活跃。</li>
<li><strong>客户端发送心跳消息：</strong> 除了接收心跳消息外，客户端也需要定期向服务器端发送心跳消息以表明自己的活跃状态。这有助于防止服务器端误判连接已断开。</li>
<li><strong>超时处理：</strong> 如果服务器端在一定时间内没有收到客户端发送的心跳消息，或者客户端在一定时间内没有收到服务器端发送的心跳消息，则可以认为连接已断开。在这种情况下，可以采取相应的重连或错误处理措施。</li>
</ol>
<h1 id="url回车之后"><a href="#url回车之后" class="headerlink" title="url回车之后"></a>url回车之后</h1><ol>
<li><p>url解析</p>
</li>
<li><p>查缓存</p>
</li>
<li><p>dns解析</p>
</li>
<li><p>获取mac地址</p>
</li>
<li><p>tcp三次握手</p>
</li>
<li><p>https握手</p>
</li>
<li><p>返回数据</p>
</li>
<li><p>页面渲染 *</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">网络进程收到html文档 产生一个渲染任务 传给渲染主进程的消息队列 开始渲染流程</span><br><span class="line"></span><br><span class="line">流程：</span><br><span class="line">1.html解析</span><br><span class="line">2.样式计算</span><br><span class="line">3.布局</span><br><span class="line">4.分层</span><br><span class="line">5.绘制</span><br><span class="line">6.分块</span><br><span class="line">7.光栅化</span><br><span class="line">8.画</span><br></pre></td></tr></table></figure>
</li>
<li><p>tcp四次挥手</p>
</li>
</ol>
<h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">eventBus</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subscribes</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">subscribe</span>(<span class="params">eventName, callback</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">subscribes</span>[eventName]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">subscribes</span>[eventName] = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subscribes</span>[eventName].<span class="title function_">push</span>(callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">unSubscribe</span>(<span class="params">eventName, callback</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">subscribes</span>[eventName]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">subscribes</span>[eventName] = <span class="variable language_">this</span>.<span class="property">subscribes</span>[eventName].<span class="title function_">filter</span>(<span class="function"><span class="params">cb</span> =&gt;</span> cb !== callback)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">publish</span>(<span class="params">eventName, data</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">subscribes</span>[eventName]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">subscribes</span>[eventName].<span class="title function_">forEach</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(data))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> events = <span class="keyword">new</span> <span class="title function_">eventBus</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cb1</span> = data =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`cb1:<span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cb2</span> = data =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`cb2:<span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">events.<span class="title function_">subscribe</span>(<span class="string">&#x27;event1&#x27;</span>, cb1)</span><br><span class="line">events.<span class="title function_">subscribe</span>(<span class="string">&#x27;event1&#x27;</span>, cb2)</span><br><span class="line"></span><br><span class="line">events.<span class="title function_">publish</span>(<span class="string">&#x27;event1&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">events.<span class="title function_">unSubscribe</span>(<span class="string">&#x27;event&#x27;</span>, cb1)</span><br><span class="line"></span><br><span class="line">events.<span class="title function_">publish</span>(<span class="string">&#x27;event1&#x27;</span>, <span class="string">&#x27;取消cb1&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h1 id="登录鉴权-路由守卫-token刷新"><a href="#登录鉴权-路由守卫-token刷新" class="headerlink" title="登录鉴权 路由守卫 token刷新"></a>登录鉴权 路由守卫 token刷新</h1><p><a class="link"   href="https://juejin.cn/post/7271139265442021391" >https://juejin.cn/post/7271139265442021391<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/qq_38658567/article/details/107840554" >https://blog.csdn.net/qq_38658567/article/details/107840554<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">PendingTask</span> &#123;</span><br><span class="line">    <span class="attr">config</span>: <span class="title class_">AxiosRequestConfig</span></span><br><span class="line">    <span class="attr">resolve</span>: <span class="title class_">Function</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> refreshing = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">PendingTask</span>[] = [];</span><br><span class="line"></span><br><span class="line">axiosInstance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">async</span> (error) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; data, config &#125; = error.<span class="property">response</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(refreshing) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(&#123;</span><br><span class="line">                    config,</span><br><span class="line">                    resolve</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.<span class="property">statusCode</span> === <span class="number">401</span> &amp;&amp; !config.<span class="property">url</span>.<span class="title function_">includes</span>(<span class="string">&#x27;/refresh&#x27;</span>)) &#123;</span><br><span class="line">            refreshing = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">refreshToken</span>();</span><br><span class="line"></span><br><span class="line">            refreshing = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(res.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line"></span><br><span class="line">                queue.<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123;config, resolve&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="title function_">axiosInstance</span>(config))</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">axiosInstance</span>(config);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">alert</span>(data || <span class="string">&#x27;登录过期，请重新登录&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> error.<span class="property">response</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">axiosInstance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> accessToken = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;access_token&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(accessToken) &#123;</span><br><span class="line">        config.<span class="property">headers</span>.<span class="property">authorization</span> = <span class="string">&#x27;Bearer &#x27;</span> + accessToken;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="webpack-vite打包配置和优化"><a href="#webpack-vite打包配置和优化" class="headerlink" title="webpack&amp;vite打包配置和优化"></a>webpack&amp;vite打包配置和优化</h1><p>vite中  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">手动分包 使打包得结果不会重复打包相同得内容</span><br><span class="line"></span><br><span class="line">build<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    rollupOptions<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        output<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            manualChunks<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                hello<span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;lodash&#x27;<span class="punctuation">,</span> &#x27;vue&#x27;<span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>





<h1 id="首屏加载白屏优化"><a href="#首屏加载白屏优化" class="headerlink" title="首屏加载白屏优化"></a>首屏加载白屏优化</h1><ol>
<li>渲染东西太多  解决方案：在第一帧渲染重要的组件，把不重要的放到后面的帧里</li>
</ol>
<h1 id="前端性能监控方案"><a href="#前端性能监控方案" class="headerlink" title="前端性能监控方案"></a>前端性能监控方案</h1><p>前端<a class="link"   href="http://www.volcengine.com/product/apmplus" >性能监控<i class="fas fa-external-link-alt"></i></a>的原理是通过浏览器发送请求、<a class="link"   href="http://www.volcengine.com/product/trafficroute" >解析<i class="fas fa-external-link-alt"></i></a>响应结果，并将其呈现给用户这一过程中的各个环节进行<a class="link"   href="http://www.volcengine.com/product/cloudmonitor" >监控<i class="fas fa-external-link-alt"></i></a>和提升。常见的前端性能指标包括：</p>
<ul>
<li>页面加载速度：指页面从请求开始到完全加载呈现的时间。</li>
<li>白屏时间：指页面请求成功到页面呈现出第一屏幕内容的时间。</li>
<li>可交互时间：指在页面加载完成后用户能够与页面进行交互的时间。</li>
<li>页面数据大小：指页面所需传输的数据大小，也就是页面所包含的文件（如图片、<a class="link"   href="http://www.volcengine.com/product/speech-audio-music-Intelligence" >音频<i class="fas fa-external-link-alt"></i></a>、视频等）大小。</li>
</ul>
]]></content>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>storybook</title>
    <url>/2024/11/30/2024/storybook/</url>
    <content><![CDATA[<ol>
<li>最上层的文件描述改 *.mdx 文件</li>
<li>每个组件文档修改 *.stores.ts</li>
<li>改组件分类下的doc，组件文件导出组件上面的注释修改</li>
<li>preview.tsx修改 doc文档格式</li>
</ol>
<p>作用：用 storybook 可以轻松的创建组件文档，可以写多个 story，直观的看到组件不同参数时的展示和交互，还可以用来做测试</p>
]]></content>
      <tags>
        <tag>文档建设</tag>
        <tag>组件库</tag>
      </tags>
  </entry>
  <entry>
    <title>tailwindcss</title>
    <url>/2024/11/30/2024/tailwindcss/</url>
    <content><![CDATA[<ol>
<li>tailwind 自动补全插件</li>
</ol>
<p>  <a class="link"   href="https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss" >https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss<i class="fas fa-external-link-alt"></i></a></p>
<p>  Tailwind CSS IntelliSense</p>
<ol start="2">
<li><p>prettier 设置自动 tailwind属性自动排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pnpm install -D prettier-plugin-tailwindcss</span><br><span class="line"></span><br><span class="line">// .prettierrc文件</span><br><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [&quot;prettier-plugin-tailwindcss&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加tailwind.config.js文件</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D tailwindcss</span><br><span class="line">npx tailwindcss init</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>引入样式文件</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// index<span class="selector-class">.css</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@tailwind</span> base;</span><br><span class="line"><span class="keyword">@tailwind</span> components;</span><br><span class="line"><span class="keyword">@tailwind</span> utilities;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>css</tag>
        <tag>tailwind</tag>
      </tags>
  </entry>
  <entry>
    <title>tsconfig 配置分类</title>
    <url>/2024/11/11/2024/tsconfig/</url>
    <content><![CDATA[<h1 id="tsconfig-配置"><a href="#tsconfig-配置" class="headerlink" title="tsconfig 配置"></a>tsconfig 配置</h1><ol>
<li><p>构建相关</p>
<ul>
<li>构建源码相关<ul>
<li>特殊语法相关<ol>
<li>jsx、jsxFactory、jsxFragmentFactory 与 jsxImportSource</li>
<li>target 与 lib、noLib</li>
</ol>
</li>
</ul>
</li>
</ul>
<p> <strong>这部分配置主要控制源码解析，包括从何处开始收集要构建的文件，如何解析别名路径等等</strong></p>
<ul>
<li><p>构建解析相关</p>
<ol>
<li>files、include 与 exclude</li>
<li>baseUrl</li>
<li>rootDir</li>
<li>types 与 typeRoots</li>
<li>moduleResolution</li>
<li>paths</li>
<li>resolveJsonModule &#x2F;&#x2F;对 json 文件类型推导</li>
</ol>
</li>
<li><p>构建产物相关</p>
<ul>
<li><p>构建输出相关</p>
<ol>
<li>outDir 与 outFile</li>
<li>module</li>
<li>noEmit 与 noEmitOnError &#x2F;&#x2F; 主要控制最终是否将构建产物实际写入文件系统</li>
<li>module &#x2F;&#x2F; 控制最终 JavaScript 产物使用的模块标准</li>
</ol>
</li>
<li><p>声明文件相关</p>
<ol>
<li>declaration、declarationDir</li>
</ol>
</li>
<li><p>Source Map 相关</p>
<ol>
<li>sourceMap 与 inlineSourceMap</li>
</ol>
</li>
</ul>
</li>
<li><p>构建产物代码格式化配置</p>
<ol>
<li>removeComments &#x2F;&#x2F; 移除所有 TS 文件的注释，默认启用</li>
</ol>
</li>
</ul>
</li>
<li><p>类型检查相关</p>
<ul>
<li><p>允许类</p>
</li>
<li><p>禁止类</p>
<ul>
<li>类型检查<ol>
<li>noImplicitAny</li>
</ol>
</li>
</ul>
</li>
<li><p>严格检查</p>
<ol>
<li>strict &#x2F;&#x2F;是一组规则的开关，开启 strict 会默认将这些规则全部启用</li>
<li>skipLibCheck 与 skipDefaultLibCheck &#x2F;&#x2F; 跳过对类型声明文件的检查</li>
</ol>
</li>
</ul>
</li>
<li><p>工程相关</p>
<ol>
<li>references</li>
<li>composite</li>
</ol>
<ul>
<li><p>兼容性</p>
<ol>
<li>isolatedModules</li>
</ol>
<ul>
<li>JavaScript 相关<ol>
<li>allowJs</li>
<li>checkJs</li>
</ol>
</li>
<li>模块相关<ol>
<li>esModuleInterop 与 allowSyntheticDefaultImports &#x2F;&#x2F; 为了解决 ES Module 和 CommonJS 之间的兼容性问题</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>ts</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>url</title>
    <url>/2024/10/09/2024/url/</url>
    <content><![CDATA[<h3 id="从浏览器输入url发生了什么"><a href="#从浏览器输入url发生了什么" class="headerlink" title="从浏览器输入url发生了什么"></a>从浏览器输入url发生了什么</h3><span id="more"></span>

<p>（1）解析URL： 当⽤户在地址栏中输⼊⼀个查询关键字时，地址栏会判断输⼊的关键字是搜索内容，还是请求的 URL。如果是搜索内容，地址栏会使⽤浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。如果判断输⼊内容符合 URL 规则，⽐如输⼊的baidu.com，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 <a class="link"   href="http://baidu.com/" >http://baidu.com<i class="fas fa-external-link-alt"></i></a></p>
<p>（2）缓存判断： 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p>
<p>（3）DNS解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p>
<p>（4）TCP三次握手： 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</p>
<p>（5）HTTPS握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p>
<p>（6）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</p>
<p>（7）页面渲染： <a class="link"   href="https://jeff-jayden.github.io/2024/11/09/2024/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/" >详情请看页面渲染流程<i class="fas fa-external-link-alt"></i></a></p>
<p>（8）TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p>
]]></content>
      <tags>
        <tag>浏览器</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-lifecycle</title>
    <url>/2024/12/04/2024/vue-lifecycle/</url>
    <content><![CDATA[<ol>
<li>beforeCreate: 可以拿到 props</li>
<li>created: 可以拿到 data, methods, watch, computed</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>代码格式化</title>
    <url>/2024/12/06/2024/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="前端代码格式化全套配置"><a href="#前端代码格式化全套配置" class="headerlink" title="前端代码格式化全套配置"></a>前端代码格式化全套配置</h1><span id="more"></span>

<h1 id="prettier-快速配置"><a href="#prettier-快速配置" class="headerlink" title="prettier 快速配置"></a>prettier 快速配置</h1><ol>
<li>安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev --save-exact prettier</span><br><span class="line"></span><br><span class="line">// 运行</span><br><span class="line">npx prettier --write index.js</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .prettierrc</span></span><br><span class="line"></span><br><span class="line">echo <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span>&gt; .prettierrc.json</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;trailingComma&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tabWidth&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;semi&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;singleQuote&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="eslint-快速配置"><a href="#eslint-快速配置" class="headerlink" title="eslint 快速配置"></a>eslint 快速配置</h1><ol>
<li>安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 安装一整套</span><br><span class="line">npm i eslint eslint-config-prettier eslint-plugin-prettier eslint-plugin-vue prettier typescript-eslint -D</span><br><span class="line"></span><br><span class="line">// 安装依赖并创建eslint.config.js 文件</span><br><span class="line">npm init @eslint/config@latest</span><br><span class="line"></span><br><span class="line">// 运行</span><br><span class="line">eslint 文件路径 --fix</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">es2021</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;standard&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;airbnb&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:vue/vue3-recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:prettier/recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;prettier&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="number">13</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;vue&#x27;</span>],</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;import/no-unresolved&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;import/no-extraneous-dependencies&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="冲突解决："><a href="#冲突解决：" class="headerlink" title="冲突解决："></a>冲突解决：</h2><p>安装解决冲突的依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//1. 安装 eslint-config-prettier</span><br><span class="line">npm i -D eslint-config-prettier</span><br><span class="line"></span><br><span class="line">//2. 在eslint的配置文件中写入以下内容</span><br><span class="line"> extends: [&#x27;prettier&#x27;], // 避免与 prettier 冲突</span><br><span class="line"></span><br><span class="line">//&quot;extends&quot;: [&quot;plugin:prettier/recommended&quot;]也可以解决冲突</span><br></pre></td></tr></table></figure>

<h2 id="eslint-文件配置文档"><a href="#eslint-文件配置文档" class="headerlink" title="eslint 文件配置文档"></a><a class="link"   href="https://eslint.org/docs/v8.x/use/configure/" >eslint 文件配置文档<i class="fas fa-external-link-alt"></i></a></h2><ol start="4">
<li><h3 id="其他依赖安装说明"><a href="#其他依赖安装说明" class="headerlink" title="其他依赖安装说明"></a>其他依赖安装说明</h3></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//由于ESlint本身只支持识别JavaScript，所以对于vue文件，还需要一个插件：eslint-plugin-vue，假如你的项目也跟我一样用的是typescript，那么还需要另一个解析器：typescript-eslint</span><br><span class="line"></span><br><span class="line">npm add eslint-plugin-vue typescript-eslint -D</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	extends: [&#x27;plugin:vue/vue3-recommended&#x27;,]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  extends: [&#x27;eslint:recommended&#x27;, &#x27;plugin:@typescript-eslint/recommended&#x27;],</span><br><span class="line">  parser: &#x27;@typescript-eslint/parser&#x27;,</span><br><span class="line">  plugins: [&#x27;@typescript-eslint&#x27;],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a class="link"   href="https://eslint.vuejs.org/user-guide/" >eslint-plugin-vue 配置文档<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="如何使用自定义解析器？"><a href="#如何使用自定义解析器？" class="headerlink" title="如何使用自定义解析器？"></a>如何使用自定义解析器？</h3><p>如果您想使用自定义解析器，例如<a class="link"   href="https://www.npmjs.com/package/@babel/eslint-parser" >@babel&#x2F;eslint-parser<i class="fas fa-external-link-alt"></i></a>或<a class="link"   href="https://www.npmjs.com/package/@typescript-eslint/parser" >@typescript-eslint&#x2F;parser<i class="fas fa-external-link-alt"></i></a> ，则必须使用<code>parserOptions.parser</code>选项而不是<code>parser</code>选项。因为这个插件需要<a class="link"   href="https://www.npmjs.com/package/vue-eslint-parser" >vue-eslint-parser<i class="fas fa-external-link-alt"></i></a>来解析<code>.vue</code>文件，所以如果你覆盖<code>parser</code>选项，这个插件将不起作用。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,</span></span><br><span class="line"><span class="addition">+ &quot;parser&quot;: &quot;vue-eslint-parser&quot;,</span></span><br><span class="line">  &quot;parserOptions&quot;: &#123;</span><br><span class="line"><span class="addition">+     &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,</span></span><br><span class="line">      &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h5 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h5><p>配置 eslint-config-prettier,就需要 extends: “prettier”, 才能真的使用到</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;prettier&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>而 plugin:prettier&#x2F;recommended 是插件附带的，主要是启用一些与 Prettier 相关的 ESLint 规则，在 eslint-plugin-prettier 的 readme 中有这个配置，例如，它可能会设置一些规则，使得当代码的引号使用、缩进等不符合 Prettier 的要求时，ESLint 会产生警告或者错误</p>
<p>而<code>eslint - config - prettier</code>的重点是关闭 ESLint 中与 Prettier 相冲突的规则。当它被应用时，它会查找那些可能与 Prettier 规则冲突的 ESLint 规则，并将它们设置为<code>off</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;plugin:prettier/recommended&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>eslint-config-prettier 主要作用是关闭 ESLint 中与 Prettier 相冲突的规则</p>
<p>eslint-plugin-prettier 是一个将 Prettier 作为 ESLint 规则来运行的插件。它允许 ESLint 使用 Prettier 的格式化规则来检查代码的格式问题</p>
<p>使用<code>eslint-plugin-prettier</code>这个插件, 让 eslint 可以使用 prettier</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i eslint-plugin-prettier -D</span><br></pre></td></tr></table></figure>

<p>在<code>.eslintrc.json</code>加入<code>perttier</code>插件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>...<span class="punctuation">,</span> <span class="string">&quot;prettier&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 注册插件</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;prettier/perttier&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span><span class="punctuation">,</span> <span class="comment">// 加入prettier规则</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>而<code>plugin:prettier/recommended</code>帮我们做了如下事情：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;prettier&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 使用eslinst-config-prettier中的配置项</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;prettier&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 注册该prettier插件</span></span><br><span class="line">  <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prettier/prettier&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span><span class="punctuation">,</span> <span class="comment">// 在eslint中运行prettier，并启用该插件提供的规则</span></span><br><span class="line">    <span class="attr">&quot;arrow-body-style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span> <span class="comment">// 关闭规则</span></span><br><span class="line">    <span class="attr">&quot;prefer-arrow-callback&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span> <span class="comment">// 关闭规则</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="husky-配置-前提是先执行-git-init"><a href="#husky-配置-前提是先执行-git-init" class="headerlink" title="husky 配置(前提是先执行 git init)"></a>husky 配置(前提是先执行 git init)</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev husky</span><br><span class="line"></span><br><span class="line">npx husky init</span><br><span class="line"></span><br><span class="line">// 配置 lint-staged</span><br><span class="line">echo &#x27;npm run lint-staged&#x27; &gt; .husky/pre-commit</span><br><span class="line"></span><br><span class="line">// 配置commitlint</span><br><span class="line">echo &quot;npx --no -- commitlint --edit \$1&quot; &gt; .husky/commit-msg</span><br><span class="line"></span><br><span class="line">// 在 package.json 中添加</span><br><span class="line">&quot;husky&quot;: &#123;</span><br><span class="line">  &quot;hooks&quot;: &#123;</span><br><span class="line">    &quot;pre-commit&quot;: &quot;lint-staged&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h1><p><code>lint - staged</code>是一个在 Git 暂存区（staged area）文件上运行 linters（代码检查工具）的工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i lint-staged -D</span><br><span class="line"></span><br><span class="line">&quot;lint-staged&quot;: &#123;</span><br><span class="line">  &quot;*.&#123;js,ts,jsx,tsx&#125;&quot;: [</span><br><span class="line">    &quot;npx prettier --write .&quot;,</span><br><span class="line">    &quot;npx eslint --fix&quot;,</span><br><span class="line">    &quot;git add .&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="commitlint"><a href="#commitlint" class="headerlink" title="commitlint"></a>commitlint</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. commitlint</span><br><span class="line">npm install -D @commitlint/&#123;cli,config-conventional&#125;</span><br><span class="line">echo &quot;export default &#123; extends: [&#x27;@commitlint/config-conventional&#x27;] &#125;;&quot; &gt; .commitlintrc.js</span><br><span class="line">// 配置commitlint</span><br><span class="line">echo &quot;npx --no -- commitlint --edit \$1&quot; &gt; .husky/commit-msg</span><br><span class="line"></span><br><span class="line">2. changelog</span><br><span class="line">//配置 changelog 文件</span><br><span class="line">npm install -g conventional-changelog-cli</span><br><span class="line">//不覆盖</span><br><span class="line">conventional-changelog -p angular -i CHANGELOG.md -s</span><br><span class="line">//覆盖之前的记录</span><br><span class="line">conventional-changelog -p angular -i CHANGELOG.md -s -r 0</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s &amp;&amp; git add CHANGELOG.md&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="commitizen"><a href="#commitizen" class="headerlink" title="commitizen"></a>commitizen</h1><p>作用就是能够直接写好规范的 commit 信息，跟 webstorm 插件一样(Git Commit Message Helper)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i commitizen cz-conventional-changelog -D</span><br><span class="line"></span><br><span class="line">npm set-script commit &quot;git-cz&quot;</span><br><span class="line"></span><br><span class="line">npx commitizen init cz-conventional-changelog --save-dev --save-exact</span><br><span class="line"></span><br><span class="line">//配置package.json 默认会加好</span><br><span class="line">&quot;config&quot;: &#123;</span><br><span class="line">  &quot;commitizen&quot;: &#123;</span><br><span class="line">    &quot;path&quot;: &quot;./node_modules/cz-customizable&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完结撒花🌸</p>
<p>引用：</p>
<ol>
<li><a class="link"   href="https://juejin.cn/post/6990929456382607374" >https://juejin.cn/post/6990929456382607374<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/6938687606687432740" >https://juejin.cn/post/6938687606687432740<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://github.com/prettier/eslint-plugin-prettier?tab=readme-ov-file" >https://github.com/prettier/eslint-plugin-prettier?tab=readme-ov-file<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7143800548704124935" >https://juejin.cn/post/7143800548704124935<i class="fas fa-external-link-alt"></i></a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>手撕题</title>
    <url>/2025/01/05/2024/%E6%89%8B%E6%92%95%E9%A2%98/</url>
    <content><![CDATA[<p>柯里化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> argsList = [...args];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.<span class="property">length</span>) &#123;</span><br><span class="line">            argsList = [...argsList, ...args];</span><br><span class="line">            <span class="keyword">return</span> fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> argsList.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curry</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)());</span><br></pre></td></tr></table></figure>

<p>hardMAn</p>
<p><a class="link"   href="https://mp.weixin.qq.com/s/-hEjxY0yI6ZBTzAlc3xwAw" >https://mp.weixin.qq.com/s/-hEjxY0yI6ZBTzAlc3xwAw<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>vue学习记录</title>
    <url>/2024/01/23/2024/vue/</url>
    <content><![CDATA[<h1 id="vue的优势"><a href="#vue的优势" class="headerlink" title="vue的优势"></a>vue的优势</h1><ol>
<li>轻量级框架：Vue.js 是一个轻量级的框架，文件大小小，易于上手和学习</li>
<li>简单易学：Vue.js 的语法简单直观，易于理解和掌握</li>
<li>双向数据绑定：Vue.js 支持双向数据绑定，使得数据的变化能够自动反映在视图上，同时视图的变化也能自动更新到数据层</li>
<li>组件化：Vue.js 支持组件化开发，能够将页面拆分成多个独立的、可复用的组件，便于开发和维护</li>
<li>数据和结构的分离：Vue.js 支持将数据和结构分离，使得前端开发更加清晰和高效</li>
<li>虚拟DOM：Vue.js 使用虚拟DOM 技术，能够最大限度地减少对实际DOM的操作，提高性能</li>
</ol>
<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>Vuex是一个专为Vue.js应用程序开发的状态管理模式+库，用于集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. 它解决了多个组件共享状态时可能遇到的问题，如多个视图依赖于同一状态、来自不同视图的行为需要变更同一状态等 在大型项目中，Vuex能够高效实现组件之间的数据共享，提高开发效率，且存储在Vuex中的数据都是响应式的，能够实时保持数据与页面的同步 因此，Vuex的作用是实现组件全局状态（数据）管理的一种机制，方便实现组件之间数据的共享，解决了组件之间统一状态的共享问题，实现组件之间的数据持久化</p>
<h1 id="ssr"><a href="#ssr" class="headerlink" title="ssr"></a>ssr</h1><p>SSR（Server-Side Rendering）是一种前端渲染技术，它在服务器端生成页面的 HTML，并将其发送给客户端进行显示。相对于传统的客户端渲染（CSR，Client-Side Rendering），SSR 提供了一些优势和改进：</p>
<ol>
<li><strong>SEO（搜索引擎优化）：</strong> 由于搜索引擎爬虫更容易处理服务器端生成的 HTML，SSR 有助于提高页面的搜索引擎排名，而不是依赖于客户端执行 JavaScript。</li>
<li><strong>首屏加载性能：</strong> SSR 可以在页面加载时直接提供完整的 HTML，无需等待客户端渲染完成。这有助于减少首屏加载时间，提高用户体验。</li>
<li><strong>性能优化：</strong> 对于一些内容静态的页面或者对用户请求较为频繁的页面，SSR 可以减轻客户端的渲染负担，提高页面性能。</li>
<li><strong>社交分享等预览信息：</strong> 一些社交分享平台，如 Facebook、Twitter，能够获取服务器端生成的 HTML 中的预览信息，从而提供更好的社交分享效果</li>
</ol>
<h1 id="vue-router的两种模式，原理"><a href="#vue-router的两种模式，原理" class="headerlink" title="vue-router的两种模式，原理"></a>vue-router的两种模式，原理</h1><p>Vue Router 提供了两种路由模式：哈希模式（Hash mode）和历史模式（History mode）。</p>
<ol>
<li><p><strong>哈希模式（Hash mode）：</strong></p>
<ul>
<li><p><strong>原理：</strong> 在浏览器 URL 中的 <code>#</code> 符号后面的部分被称为哈希（hash），<strong>哈希模式通过监听浏览器的 <code>hashchange</code> 事件来实现路由切换</strong>。例如，<code>http://example.com/#/path</code>。</p>
</li>
<li><p><strong>优点：</strong> 不需要服务器配置，适用于单页应用。<strong>哈希部分的改变不会导致浏览器向服务器发起请求</strong>，可以避免一些问题，比如在没有配置服务器支持时刷新页面不会导致404错误。</p>
</li>
<li><p><strong>缺点：</strong> 带有 <code>#</code> 符号，看起来不够友好；对于一些搜索引擎爬虫，哈希部分不会被发送到服务器，可能<strong>对 SEO 不够友好</strong>。</p>
</li>
<li><p><strong>配置：</strong> 在创建 <code>VueRouter</code> 实例时，通过 <code>mode: &#39;hash&#39;</code> 来启用哈希模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst router = new VueRouter(&#123;</span><br><span class="line">  mode: &#x27;hash&#x27;,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>历史模式（History mode）：</strong></p>
<ul>
<li><p><strong>原理：</strong> 利用 HTML5 History API 中的 <code>pushState</code> 和 <code>replaceState</code> 方法，History 模式实现了无需 <code>#</code> 符号的路由。例如，<code>http://example.com/path</code>。</p>
</li>
<li><p><strong>优点：</strong> URL 看起来更加干净，去除了 <code>#</code> 符号；对于一些搜索引擎爬虫更友好。</p>
</li>
<li><p><strong>缺点：</strong> 需要服务器配置，确保在除基本路由之外的所有路由返回同一个 HTML 文件；刷新页面或直接访问某个路由时，会向服务器发送请求，需要服务器支持。</p>
</li>
<li><p><strong>配置：</strong> 在创建 <code>VueRouter</code> 实例时，通过 <code>mode: &#39;history&#39;</code> 来启用历史模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst router = new VueRouter(&#123;</span><br><span class="line">  mode: &#x27;history&#x27;,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="vuex在刷新页面的时候-会清除保存的数据嘛-为什么"><a href="#vuex在刷新页面的时候-会清除保存的数据嘛-为什么" class="headerlink" title="vuex在刷新页面的时候 会清除保存的数据嘛 为什么"></a>vuex在刷新页面的时候 会清除保存的数据嘛 为什么</h1><p>当你刷新页面时，Vuex保存的数据会被清除。这是因为 Vuex 的状态保存在内存中，当页面刷新时，应用会重新加载，Vuex 的状态也会被清除，并重新初始化状态。</p>
<p>这是JavaScript和 Vuex设计的固有特性</p>
<h1 id="nextick"><a href="#nextick" class="headerlink" title="nextick"></a><a class="link"   href="https://juejin.cn/post/7331591798332424201?searchId=2024041923495759324E6AAAAAB6B861AC" >nextick<i class="fas fa-external-link-alt"></i></a></h1><p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240419235355364.png"  alt="image-20240419235355364"></p>
<p>它允许你等待Vue完成DOM的更新，然后执行某些操作</p>
<p>当你在Vue组件中更改数据时，视图不会立即更新，而是异步更新。为了获得更新后的DOM状态，在更新数据之后立即查询DOM可能是不准确的。<code>nextTick</code>就是用来解决这个问题的。</p>
<h1 id="v-if-v-show"><a href="#v-if-v-show" class="headerlink" title="v-if&amp;v-show"></a>v-if&amp;v-show</h1><h2 id="使用v-show替代v-if"><a href="#使用v-show替代v-if" class="headerlink" title="使用v-show替代v-if"></a>使用v-show替代v-if</h2><p>对于频繁切换显示状态的元素，使用v-show可以保证虚拟dom树的稳定，避免频繁的新增和删除元素，特别是对于那些内部包含大量dom元素的节点，这一点极其重要</p>
<p>关键字：频繁切换显示状态、内部包含大量dom元素</p>
<h1 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h1><p>当使用Element UI框架进行组件封装时，经常需要考虑到底层组件的属性或插槽可能会发生变化的情况。要在不改变已封装组件的基础上实现兼容性，可以考虑以下几种方法：</p>
<ol>
<li><p><strong>属性透传（Prop Forwarding）</strong>：</p>
<p>利用<code>v-bind</code>的对象语法或使用<code>$attrs</code>对象将接收到的所有属性传递给子组件。这种方法确保了任何额外的属性都能传递给底层组件，即使这些属性在封装组件时没有明确声明。</p>
</li>
</ol>
<p>​	v-bind&#x3D;”$attrs”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-button v-bind=&quot;$attrs&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/el-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<ol>
<li><strong>插槽透传（Slot Forwarding）</strong>：<br>使用<code>&lt;slot&gt;</code>元素可以将内容分发至底层组件的对应插槽。使用 <code>&lt;template&gt;</code> 标签和 <code>v-slot</code> 指令可以将封装组件接收的插槽内容透传到底层组件。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-dialog&gt;</span><br><span class="line">    &lt;!-- 默认插槽内容 --&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;!-- 具名插槽内容 --&gt;</span><br><span class="line">    &lt;template v-slot:footer&gt;</span><br><span class="line">      &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/el-dialog&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<ol>
<li><strong>监听属性变化</strong>：<br>如果是预料到某些属性可能会发生变化，可以在封装组件中使用<code>watch</code>监听这些属性，然后做出相应的处理。</li>
<li><strong>文档和版本兼容性声明</strong>：<br>在封装组件的文档中明确声明组件兼容的Element UI版本，并及时更新兼容性信息。这样使用者就可以意识到可能存在的限制，并根据需要进行调整。</li>
<li><strong>封装扩展插槽（Scoped Slots）</strong>：<br>如果Element的组件更新了插槽，可以通过增加扩展插槽来兼容新的功能，同时保持向后兼容。</li>
<li><strong>保持更新</strong>：<br>关注Element UI框架的更新，特别是破坏性更新（breaking changes）。当框架更新时，及时检查封装的组件，并对必要的部分做适配和兼容性调整。</li>
<li><strong>使用事件发射（Event Emitting）</strong>：<br>在某些情况下，如果底层组件的事件发生了改变，通过在封装组件中监听这些事件并重新发射（emit）可以保证外部可以正常监听到。</li>
<li><strong>提供配置选项</strong>：<br>对于封装组件，可以提供一些配置选项，使得使用者在使用时能够调整这些配置以应对底层组件的变化。</li>
</ol>
<h1 id="vue中key的作用"><a href="#vue中key的作用" class="headerlink" title="vue中key的作用"></a>vue中key的作用</h1><p>key是给每一个vnode的唯一id，可以依靠key，更准确，更快的拿到oldVnode中对应的vnode节点 提高虚拟dom的更新 触发过渡效果</p>
<p>结论:   如果key没有发生变化，元素不会销毁重建</p>
<p>​			如果是组件，不会触发生命周期的勾子函数</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染原理</title>
    <url>/2024/11/09/2024/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h3><span id="more"></span>

<p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p>
<p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p>
<p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p>
<p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p>
<p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p>
<p>#解析 HTML<br>解析过程中遇到 CSS</p>
<p><img   src="/../images/chrome/image-20230901145948801.png" ></p>
<p>遇到 JS</p>
<p><img   src="/../images/chrome/image-20230901150037013.png" ></p>
<p>为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p>
<p>如果主线程解析到link位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p>
<p>如果主线程解析到script位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p>
<p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p>
<p><img   src="/../images/chrome/image-20230901150218827.png" ></p>
<p>#样式计算<br>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p>
<p>在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)；相对单位会变成绝对单位，比如em会变成px</p>
<p>这一步完成后，会得到一棵带有样式的 DOM 树。</p>
<p><img   src="/../images/chrome/image-20230901150449029.png" ></p>
<p>#布局<br>布局完成后会得到布局树</p>
<p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p>
<p>大部分时候，DOM 树和布局树并非一一对应。</p>
<p>比如display:none的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p>
<p><img   src="/../images/chrome/image-20230901150532770.png" ></p>
<p>#分层<br>主线程会使用一套复杂的策略对整个布局树中进行分层。</p>
<p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p>
<p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过will-change属性更大程度的影响分层结果。</p>
<p><img   src="/../images/chrome/image-20230901150548654.png" ></p>
<p>#绘制<br>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p>
<p><img   src="/../images/chrome/image-20230901150600166.png" ></p>
<p>渲染主线程的⼯作到此为⽌，剩余步骤交给其他线程完成</p>
<p><img   src="/../images/chrome/image-20230901150633287.png" ></p>
<p>#分块<br>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p>
<p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p>
<p>它会从线程池中拿取多个线程来完成分块工作。</p>
<p><img   src="/../images/chrome/image-20230901150650578.png" ></p>
<p><img   src="/../images/chrome/image-20230901150726296.png" ></p>
<p>#光栅化<br>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p>
<p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p>
<p>光栅化的结果，就是一块一块的位图</p>
<p><img   src="/../images/chrome/image-20230901150831893.png" ></p>
<p>#最后一个阶段 画<br>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p>
<p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p>
<p>变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因。</p>
<p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p>
<p><img   src="/../images/chrome/image-20230901150927920.png" ></p>
<p>#什么是 reflow？<br>reflow 的本质就是重新计算 layout 树。</p>
<p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p>
<p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p>
<p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p>
<p>浏览器在反复权衡下，最终决定在调用某些属性时立即 reflow。</p>
<p>会引起reflow的属性：</p>
<p>Offset相关属性offsetWidth、offsetHeight、offsetTop、offsetLeft 等<br>client相关属性 clientWidth、clientHeight等<br>Scroll相关属性：例如 scrollWidth、scrollHeight、scrollTop、scrollLeft 等<br>getComputedStyle() 方法：当使用 getComputedStyle() 方法获取计算后的样式（computed style）时<br>#什么是 repaint？<br>repaint 的本质就是重新根据分层信息计算了绘制指令。</p>
<p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p>
<p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p>
<p>#为什么 transform 的效率高？<br>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p>
<p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>
<p><img   src="/../images/chrome/image-20230901151924571.png" ></p>
]]></content>
      <tags>
        <tag>浏览器</tag>
        <tag>渲染原理</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>docker_nginx</title>
    <url>/2025/03/02/2025/docker-nginx/</url>
    <content><![CDATA[<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p>总结： 前端项目打包后直接将静态资源放到nginx服务器上，最重要的还是对配置文件熟练</p>
<ol>
<li>&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 存放静态资源目录</li>
<li>&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf 配置文件路径</li>
</ol>
<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>总结：使用 dockerfile 构建镜像，然后启动容器</p>
<ol>
<li>制作镜像（需要对常用的几个 dockerfile 命令熟悉，比如 from,run,args,copy,add,expose,cmd），就是基于一个基础镜像，然后把打包好的产物放到指定目录下<ol>
<li>中间还可以挂载 volumes</li>
<li>设置参数</li>
</ol>
</li>
<li>运行命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t 自定义镜像名 dockerfile路径</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用镜像运行一个容器</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>interview_plan</title>
    <url>/2025/02/25/2025/interview-plan/</url>
    <content><![CDATA[<p>复习路线是啥呢，哎</p>
<ol>
<li>实习</li>
<li>项目</li>
<li>八股</li>
<li>算法</li>
</ol>
<h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ol>
<li>进程是资源分配的基本单位，具有独立的内存空间和资源，适合资源隔离和资源密集型任务。</li>
<li>线程是CPU调度的基本单位，共享进程资源，适合并发执行和计算密集型任务。</li>
</ol>
<p>我们称已经执行结束但PCB仍存在的进程为僵尸进程，僵尸进程虽然有PCB,但已经不可能再次运行。 </p>
<p>父进程执行waitpid函数，在读走子进程退出状态和其他信息后，就将其PCB清理掉，让子进程彻</p>
<p>底消失，完成对已结束子进程的善后处理工作。 </p>
<p>进程与程序的区别</p>
<p>了解进程的概念后，现在停下来，确认一下你理解了程序和进程之间的区别：</p>
<p>(1)程序是永存的，作为源代码或目标模块存在于外存中；进程是暂时的，是程序在数据集上</p>
<p>的一次执行，有创建，有撤销，存在是暂时的。</p>
<p>(2)程序是静态的，关机后仍然存在，进程是动态的，有从产生到消亡的生命周期。</p>
<p>(3)进程具有并发性，而程序没有。</p>
<p>(4)进程和程序不是一一对应的：一个程序可对应多个进程，即多个进程可执行同一程序；一</p>
<p>个进程可以执行一个或多个程序。</p>
<h3 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a><strong>进程间通信（IPC）</strong></h3><ul>
<li><p>管道（Pipe&#x2F;FIFO）</p>
<ul>
<li><p>无名管道（<code>pipe()</code>）用于父子进程通信；命名管道（<code>mkfifo()</code>）支持无关进程通信。</p>
</li>
<li><pre><code class="c">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main() &#123;
    int fd[2];
    pipe(fd);  // 创建管道，fd[0]读端，fd[1]写端
  
    if (fork() == 0) &#123;  // 子进程
        close(fd[1]);   // 关闭写端
        char buf[20];
        read(fd[0], buf, sizeof(buf));
        printf(&quot;Child received: %s\n&quot;, buf);
    &#125; else &#123;            // 父进程
        close(fd[0]);   // 关闭读端
        write(fd[1], &quot;Hello from parent&quot;, 17);
        close(fd[1]);
    &#125;
    return 0;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - </span><br><span class="line"></span><br><span class="line">- 消息队列</span><br><span class="line"></span><br><span class="line">  - 基于 `msgget()`、`msgsnd()`、`msgrcv()` 实现结构化消息传递。</span><br><span class="line"></span><br><span class="line">  - ```c</span><br><span class="line">    # 发送</span><br><span class="line">    #include &lt;sys/msg.h&gt;</span><br><span class="line">    </span><br><span class="line">    struct msg_buffer &#123;</span><br><span class="line">        long mtype;       // 消息类型（必须为长整型）</span><br><span class="line">        char mtext[100];  // 消息内容</span><br><span class="line">    &#125; message;</span><br><span class="line">    </span><br><span class="line">    int main() &#123;</span><br><span class="line">        // 创建或获取消息队列（键值 1234，权限 0666）</span><br><span class="line">        int msgid = msgget(1234, 0666 | IPC_CREAT);</span><br><span class="line">        message.mtype = 1;  // 设置消息类型（用于接收端过滤）</span><br><span class="line">        strcpy(message.mtext, &quot;Hello via Message Queue&quot;);</span><br><span class="line">        msgsnd(msgid, &amp;message, sizeof(message), 0); // 发送消息（0 表示阻塞发送）</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 接收</span><br><span class="line">    int main() &#123;</span><br><span class="line">        int msgid = msgget(1234, 0666); // 获取已有的消息队列</span><br><span class="line">        struct msg_buffer message;</span><br><span class="line">        // 接收类型为 1 的消息（最后一个参数 0 表示阻塞接收）</span><br><span class="line">        msgrcv(msgid, &amp;message, sizeof(message), 1, 0);</span><br><span class="line">        printf(&quot;Received: %s\n&quot;, message.mtext);</span><br><span class="line">        msgctl(msgid, IPC_RMID, NULL); // 删除消息队列</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ul>
</li>
<li><p>共享内存</p>
<ul>
<li><p>通过 <code>shmget()</code> 创建共享内存区，<code>shmat()</code>&#x2F;<code>shmdt()</code> 挂接&#x2F;分离内存，高效但需同步机制。</p>
</li>
<li><pre><code class="c"># 写入端
#include &lt;sys/shm.h&gt;

int main() &#123;
    // 创建共享内存（键值 5678，大小 1024 字节，权限 0666）
    int shmid = shmget(5678, 1024, 0666 | IPC_CREAT);
    char *str = (char*)shmat(shmid, NULL, 0); // 将共享内存附加到进程地址空间
    strcpy(str, &quot;Shared Memory Data&quot;);        // 写入数据
    shmdt(str);              // 分离共享内存（数据保留在内存中）
    return 0;
&#125;
# 读取端
int main() &#123;
    int shmid = shmget(5678, 1024, 0666); // 获取已有共享内存
    char *str = (char*)shmat(shmid, NULL, 0); // 附加到进程
    printf(&quot;Read: %s\n&quot;, str);
    shmdt(str);              // 分离共享内存
    shmctl(shmid, IPC_RMID, NULL); // 删除共享内存（释放资源）
    return 0;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - </span><br><span class="line"></span><br><span class="line">- 信号量</span><br><span class="line"></span><br><span class="line">  - 使用 `semget()`、`semop()` 控制资源访问，解决进程同步问题（如PV操作）。</span><br><span class="line"></span><br><span class="line">  - ```c</span><br><span class="line">    #include &lt;signal.h&gt;</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    </span><br><span class="line">    void handler(int sig) &#123;</span><br><span class="line">        printf(&quot;Child received SIGUSR1\n&quot;);  // 子进程实际收到信号</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int main() &#123;</span><br><span class="line">        pid_t child_pid;</span><br><span class="line">        signal(SIGUSR1, handler);</span><br><span class="line">      </span><br><span class="line">        child_pid = fork();</span><br><span class="line">        if (child_pid == 0) &#123;       // 子进程</span><br><span class="line">            pause();                // 等待信号</span><br><span class="line">        &#125; else &#123;                    // 父进程</span><br><span class="line">            sleep(1);</span><br><span class="line">            kill(child_pid, SIGUSR1); // 向子进程发送信号</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>套接字</p>
<ul>
<li><pre><code class="c">#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;

int main() &#123;
    int sockfd = socket(AF_UNIX, SOCK_STREAM, 0); // 创建本地套接字
    struct sockaddr_un addr;
    addr.sun_family = AF_UNIX;                   // 使用 Unix 域套接字
    strcpy(addr.sun_path, &quot;/tmp/mysocket&quot;);      // 绑定到文件路径
  
    bind(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr)); // 绑定套接字
    listen(sockfd, 5);                          // 监听连接（最大队列长度 5）
    int client = accept(sockfd, NULL, NULL);     // 接受客户端连接
    send(client, &quot;Hello via Socket&quot;, 16, 0);     // 发送数据
    close(client);
    return 0;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - </span><br><span class="line"></span><br><span class="line">- IPC综合应用</span><br><span class="line"></span><br><span class="line">  - 结合共享内存和信号量实现进程间数据高效交换。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">多进程与多线程的区别：可将多进程比喻成把一个大家庭分成很多有独立房屋的小家庭，而将</span><br><span class="line"></span><br><span class="line">多线程比喻成生活在同一屋檐下的家庭成员</span><br><span class="line"></span><br><span class="line">![image-20250303175714103](/Users/admin/Library/Application Support/typora-user-images/image-20250303175714103.png)</span><br><span class="line"></span><br><span class="line"># interface 和 type 的区别</span><br><span class="line">interface：</span><br><span class="line">更适合定义对象的结构。</span><br><span class="line">支持扩展和合并。</span><br><span class="line">更接近于传统面向对象编程中的接口概念。</span><br><span class="line">通常用于描述类的结构或对象的形状。</span><br><span class="line"></span><br><span class="line">type：</span><br><span class="line">更灵活，支持联合类型、交叉类型、函数类型等。</span><br><span class="line">不支持扩展和合并。</span><br><span class="line">适合定义复杂的类型结构或函数类型。</span><br><span class="line"></span><br><span class="line"># map和对象的区别</span><br><span class="line">对象：</span><br><span class="line">键必须是字符串或符号。</span><br><span class="line">默认继承自 Object.prototype，可能包含默认属性。</span><br><span class="line">遍历顺序不确定。</span><br><span class="line">性能在动态操作时可能不如 Map。</span><br><span class="line">适合用作配置对象或实体表示。</span><br><span class="line">Map：</span><br><span class="line">键可以是任意类型。</span><br><span class="line">不继承默认属性，是一个纯粹的键值对集合。</span><br><span class="line">遍历顺序按照插入顺序。</span><br><span class="line">性能在动态操作时更优。</span><br><span class="line">适合处理动态的键值对集合。</span><br><span class="line"></span><br><span class="line"># useContext的弊端</span><br><span class="line">`useContext` 是 React 提供的一种用于跨组件共享状态的 Hook，但它也有一些潜在的弊端和限制，主要体现在性能问题、数据流追踪、以及使用场景的限制上。以下是详细的分析：</span><br><span class="line"></span><br><span class="line">### **1. 性能问题**</span><br><span class="line">- **组件过度渲染**：当 Context 的值发生变化时，所有订阅了该 Context 的组件都会重新渲染，而不管它们是否真正需要这些更新。这可能导致不必要的性能开销，尤其是在组件树较大或组件渲染开销较高时。</span><br><span class="line">- **频繁更新问题**：如果 Context 中的状态频繁变化（如计数器或实时数据），会导致大量组件的频繁重新渲染，影响应用性能。</span><br><span class="line"></span><br><span class="line">### **2. 数据流追踪困难**</span><br><span class="line">- **难以调试**：由于 `useContext` 允许跨组件树共享数据，数据的流向可能变得复杂且难以追踪。这会增加调试的难度，尤其是在大型应用中。</span><br><span class="line">- **组件耦合度高**：使用 `useContext` 时，组件之间可能会因为共享状态而产生隐式耦合，这使得代码的可维护性和可扩展性受到影响。</span><br><span class="line"></span><br><span class="line">### **3. 使用场景的限制**</span><br><span class="line">- **不适合高频更新状态**：对于需要频繁更新的状态（如表单输入或动画），`useContext` 可能不是最佳选择，因为它会导致大量组件的重新渲染。</span><br><span class="line">- **不适合复杂的状态管理**：虽然 `useContext` 可以替代简单的状态管理场景，但对于复杂的状态逻辑（如异步数据加载、中间件等），它可能不如专门的状态管理库（如 Redux）强大。</span><br><span class="line"></span><br><span class="line">### **4. 如何优化或替代**</span><br><span class="line">- **拆分 Context**：将不同的状态拆分到多个独立的 Context 中，避免因单一 Context 的值变化导致大量组件重新渲染。</span><br><span class="line">- **使用 `React.memo` 或 `useMemo`**：对于纯展示组件，可以使用 `React.memo` 来避免不必要的渲染；对于复杂计算或函数，可以使用 `useMemo` 或 `useCallback` 来优化性能。</span><br><span class="line">- **结合 `useReducer`**：对于复杂的状态逻辑，可以结合 `useReducer` 使用 `useContext`，以实现更灵活的状态管理。</span><br><span class="line">- **使用专门的状态管理库**：对于大型应用或复杂的状态管理需求，可以考虑使用 Redux、MobX 等专门的状态管理库。</span><br><span class="line"></span><br><span class="line">### **总结**</span><br><span class="line">`useContext` 是一个强大的工具，适用于简化跨组件的状态共享，但它也有明显的弊端，特别是在性能和调试方面。开发者需要根据具体场景合理使用 `useContext`，并结合其他优化手段或替代方案，以避免潜在问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 在一个 ts 的前端项目中，webpack 或者 vite编译源码到最终产物的执行顺序是什么</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在使用 Webpack 或 Vite 进行前端项目构建时，源码到最终产物的编译执行顺序涉及多个阶段，包括文件解析、依赖处理、代码转换、打包和优化等。以下是两者在构建过程中的大致执行顺序：</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### Webpack 构建执行顺序</span><br><span class="line">Webpack 是一个模块打包器，它通过配置文件（`webpack.config.js` 或 `webpack.config.ts`）来定义构建过程。以下是 Webpack 构建的主要执行顺序：</span><br><span class="line"></span><br><span class="line">1. **配置加载与解析**：</span><br><span class="line">   - Webpack 首先加载配置文件，解析配置中的 `entry`（入口文件）、`output`（输出路径）、`module`（模块规则）、`plugins`（插件）等选项。</span><br><span class="line"></span><br><span class="line">2. **入口文件解析**：</span><br><span class="line">   - 根据 `entry` 配置，Webpack 开始解析入口文件（通常是 JavaScript 文件，如 `index.js` 或 `main.ts`）。入口文件是构建过程的起点。</span><br><span class="line"></span><br><span class="line">3. **依赖解析**：</span><br><span class="line">   - Webpack 从入口文件开始，递归解析代码中的依赖（如 `import` 或 `require` 语句），构建一个依赖图（Dependency Graph）。这个图包含了项目中所有模块及其相互关系。</span><br><span class="line"></span><br><span class="line">4. **Loader 处理**：</span><br><span class="line">   - 在解析模块时，Webpack 会根据 `module.rules` 配置中的规则，使用对应的 Loader 对文件进行处理。例如：</span><br><span class="line">     - 使用 `ts-loader` 或 `babel-loader` 处理 TypeScript 或 ES6+ 代码。</span><br><span class="line">     - 使用 `style-loader` 和 `css-loader` 处理 CSS 文件。</span><br><span class="line">     - 使用 `file-loader` 或 `url-loader` 处理静态资源（如图片、字体等）。</span><br><span class="line"></span><br><span class="line">5. **插件执行**：</span><br><span class="line">   - 在构建过程中，Webpack 会触发多个生命周期钩子（如 `emit`、`done` 等），插件会在这些钩子上执行特定任务。例如：</span><br><span class="line">     - `HtmlWebpackPlugin` 用于生成 HTML 文件。</span><br><span class="line">     - `MiniCssExtractPlugin` 用于提取 CSS 文件。</span><br><span class="line">     - `TerserPlugin` 用于压缩 JavaScript 代码。</span><br><span class="line"></span><br><span class="line">6. **模块打包**：</span><br><span class="line">   - Webpack 将解析后的模块按照依赖关系打包成一个或多个 bundle 文件。这些文件会根据 `output` 配置输出到指定目录。</span><br><span class="line"></span><br><span class="line">7. **代码优化**：</span><br><span class="line">   - 如果启用了代码分割（Code Splitting），Webpack 会根据配置将代码分割成多个 chunk，以优化加载性能。</span><br><span class="line">   - 如果启用了压缩插件（如 `TerserPlugin` 或 `ESBuildMinifyPlugin`），Webpack 会对代码进行压缩和优化。</span><br><span class="line"></span><br><span class="line">8. **输出最终产物**：</span><br><span class="line">   - 打包后的文件（如 `bundle.js`、`styles.css`、`index.html` 等）会被输出到 `output` 配置指定的目录。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### Vite 构建执行顺序</span><br><span class="line">Vite 是一个基于 Rollup 的现代前端构建工具，它通过预构建依赖和快速热更新（HMR）来实现快速开发体验。以下是 Vite 构建的主要执行顺序：</span><br><span class="line"></span><br><span class="line">1. **配置加载与解析**：</span><br><span class="line">   - Vite 首先加载配置文件（`vite.config.js` 或 `vite.config.ts`），解析配置中的 `build`、`plugins`、`resolve` 等选项。</span><br><span class="line"></span><br><span class="line">2. **依赖预构建**：</span><br><span class="line">   - 在开发模式下，Vite 会预先构建项目中的依赖（如第三方库）。这些依赖会被编译成一个或多个预构建模块，以加快后续的构建速度。</span><br><span class="line"></span><br><span class="line">3. **文件解析与模块解析**：</span><br><span class="line">   - Vite 从入口文件（如 `index.html` 或 `main.ts`）开始解析项目中的模块。它会递归解析代码中的依赖，构建模块依赖图。</span><br><span class="line"></span><br><span class="line">4. **插件处理**：</span><br><span class="line">   - Vite 提供了丰富的插件系统，插件可以在构建过程中对文件进行处理。例如：</span><br><span class="line">     - `@vitejs/plugin-vue` 用于处理 Vue 文件。</span><br><span class="line">     - `vite-plugin-eslint` 用于集成 ESLint。</span><br><span class="line">     - 自定义插件可以用于处理特定文件类型或执行特定任务。</span><br><span class="line"></span><br><span class="line">5. **代码转换**：</span><br><span class="line">   - Vite 使用 `esbuild` 对代码进行快速转换，支持 TypeScript、JSX 等语法。它会将代码转换为浏览器可执行的 JavaScript。</span><br><span class="line"></span><br><span class="line">6. **静态资源处理**：</span><br><span class="line">   - Vite 会自动处理静态资源（如图片、字体等），并将其输出到构建目录。它还支持资源的内联（base64 编码）或 URL 重写。</span><br><span class="line"></span><br><span class="line">7. **代码分割与优化**：</span><br><span class="line">   - 在生产模式下，Vite 会根据配置对代码进行分割，生成多个 chunk 文件，以优化加载性能。</span><br><span class="line">   - Vite 使用 `terser` 或 `esbuild` 对代码进行压缩和优化。</span><br><span class="line"></span><br><span class="line">8. **输出最终产物**：</span><br><span class="line">   - 构建完成后，Vite 会将输出文件（如 `index.html`、`assets/*.js`、`assets/*.css` 等）保存到 `dist` 目录。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line">虽然 Webpack 和 Vite 的构建过程在细节上有所不同，但它们的基本逻辑是类似的：从入口文件开始，解析依赖，处理模块，优化代码，最终输出构建产物。Webpack 更灵活，功能强大，但配置相对复杂；Vite 则通过预构建依赖和快速 HMR 提供了更快的开发体验，同时在生产模式下也能生成高效的构建产物。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># webpack 是在什么时候将 ts 文件转换成 js 文件的</span><br><span class="line"></span><br><span class="line">在 Webpack 的构建过程中，TypeScript 文件被转换为 JavaScript 文件的时机是在 **Loader 处理阶段**。具体来说，Webpack 会根据配置文件中的 `module.rules` 规则，使用指定的 Loader（如 `ts-loader` 或 `babel-loader`）来处理 `.ts` 文件。</span><br><span class="line"></span><br><span class="line">以下是详细的处理过程：</span><br><span class="line"></span><br><span class="line">1. **配置 Loader**：</span><br><span class="line">   在 Webpack 配置文件中，需要指定处理 `.ts` 文件的 Loader。例如，使用 `ts-loader` 的配置如下：</span><br><span class="line">   ```javascript</span><br><span class="line">   module.exports = &#123;</span><br><span class="line">     module: &#123;</span><br><span class="line">       rules: [</span><br><span class="line">         &#123;</span><br><span class="line">           test: /\.tsx?$/, // 匹配 .ts 或 .tsx 文件</span><br><span class="line">           use: &#x27;ts-loader&#x27;, // 使用 ts-loader 进行编译</span><br><span class="line">           exclude: /node_modules/, // 排除 node_modules 文件夹</span><br><span class="line">         &#125;,</span><br><span class="line">       ],</span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p> 这里，<code>ts-loader</code> 会调用 TypeScript 编译器（<code>tsc</code>）将 <code>.ts</code> 文件转换为 JavaScript。</p>
</li>
</ul>
<ol start="2">
<li><p><strong>转换时机</strong>：</p>
<ul>
<li>当 Webpack 遍历项目文件并解析依赖时，遇到 <code>.ts</code> 文件时会触发 Loader 的处理。</li>
<li><code>ts-loader</code> 会读取项目的 <code>tsconfig.json</code> 配置文件，根据其中的编译选项（如目标 JavaScript 版本、模块系统等）将 TypeScript 文件编译为 JavaScript。</li>
</ul>
</li>
<li><p><strong>与 Babel 的结合</strong>：<br>如果项目中同时使用了 Babel，可以通过 <code>babel-loader</code> 和 <code>@babel/preset-typescript</code> 来处理 TypeScript 文件。这种方式可以让 Babel 负责转译 TypeScript 和 ES6+ 语法，而不需要单独使用 <code>ts-loader</code>。</p>
</li>
</ol>
<p>总结来说，Webpack 在构建过程中通过 Loader 处理阶段将 TypeScript 文件转换为 JavaScript 文件，具体转换由 <code>ts-loader</code> 或 <code>babel-loader</code> 完成，取决于项目配置。</p>
<h1 id="vite-是在什么时候将-ts-文件转换成-js-文件的"><a href="#vite-是在什么时候将-ts-文件转换成-js-文件的" class="headerlink" title="vite 是在什么时候将 ts 文件转换成 js 文件的"></a>vite 是在什么时候将 ts 文件转换成 js 文件的</h1><p>在 Vite 项目中，TypeScript 文件被转换为 JavaScript 文件的过程主要发生在 <strong>开发服务器启动时</strong> 和 <strong>生产构建时</strong>。Vite 使用了 <code>esbuild</code> 作为其默认的 TypeScript 编译工具，因为它比传统的 <code>tsc</code> 或 <code>babel</code> 更快，能够提供即时的编译反馈和热更新（HMR）能力。</p>
<p>以下是 Vite 在不同阶段处理 TypeScript 文件的具体过程：</p>
<hr>
<h3 id="1-开发模式（Development-Mode）"><a href="#1-开发模式（Development-Mode）" class="headerlink" title="1. 开发模式（Development Mode）"></a>1. <strong>开发模式（Development Mode）</strong></h3><p>在开发模式下，Vite 会启动一个开发服务器，监听文件变化并实时编译 TypeScript 文件。以下是关键步骤：</p>
<h4 id="a-启动开发服务器时"><a href="#a-启动开发服务器时" class="headerlink" title="a. 启动开发服务器时"></a>a. <strong>启动开发服务器时</strong></h4><p>当运行 <code>vite</code> 或 <code>npm run dev</code> 时，Vite 会执行以下操作：</p>
<ul>
<li><strong>解析项目配置</strong>：加载 <code>vite.config.ts</code> 或 <code>vite.config.js</code> 文件，解析其中的配置。</li>
<li><strong>初始化构建环境</strong>：Vite 会初始化一个内部的构建环境，用于处理项目中的文件。</li>
<li>**启动 <code>esbuild</code>**：Vite 使用 <code>esbuild</code> 来处理 TypeScript 文件。<code>esbuild</code> 会读取项目的 <code>tsconfig.json</code> 配置，并根据配置将 <code>.ts</code> 文件编译为 JavaScript。</li>
<li><strong>生成内存中的模块</strong>：编译后的 JavaScript 文件会被存储在内存中，而不是直接写入磁盘。这样可以加快热更新的速度。</li>
</ul>
<h4 id="b-文件变化时"><a href="#b-文件变化时" class="headerlink" title="b. 文件变化时"></a>b. <strong>文件变化时</strong></h4><p>当开发者修改 <code>.ts</code> 文件时：</p>
<ul>
<li><strong>触发热更新（HMR）</strong>：Vite 会检测到文件变化，并重新触发 <code>esbuild</code> 对修改的文件进行编译。</li>
<li><strong>更新内存中的模块</strong>：重新编译后的模块会替换内存中的旧模块。</li>
<li><strong>通知浏览器刷新</strong>：Vite 会通过 WebSocket 向浏览器发送更新信号，浏览器会根据 HMR 的规则更新页面。</li>
</ul>
<hr>
<h3 id="2-生产模式（Production-Mode）"><a href="#2-生产模式（Production-Mode）" class="headerlink" title="2. 生产模式（Production Mode）"></a>2. <strong>生产模式（Production Mode）</strong></h3><p>在生产模式下，Vite 会执行完整的构建过程，将项目打包为最终的生产文件。以下是关键步骤：</p>
<h4 id="a-运行-vite-build"><a href="#a-运行-vite-build" class="headerlink" title="a. 运行 vite build"></a>a. <strong>运行 <code>vite build</code></strong></h4><p>当运行 <code>vite build</code> 时，Vite 会执行以下操作：</p>
<ul>
<li><strong>解析项目配置</strong>：加载 <code>vite.config.ts</code> 或 <code>vite.config.js</code> 文件，解析其中的配置。</li>
<li><strong>预构建依赖</strong>：Vite 会预先构建项目中的第三方依赖，将它们编译为兼容浏览器的格式。</li>
<li><strong>处理项目文件</strong>：Vite 使用 <code>esbuild</code> 对项目中的 <code>.ts</code> 文件进行编译，将它们转换为 JavaScript。</li>
<li><strong>代码优化</strong>：Vite 会根据配置对代码进行优化，例如：<ul>
<li><strong>代码分割</strong>：将代码分割为多个 chunk，以优化加载性能。</li>
<li><strong>压缩代码</strong>：使用 <code>terser</code> 或其他工具对代码进行压缩。</li>
</ul>
</li>
<li><strong>生成最终产物</strong>：编译后的文件会被输出到 <code>dist</code> 目录。</li>
</ul>
<hr>
<h3 id="Vite-使用-esbuild-的优势"><a href="#Vite-使用-esbuild-的优势" class="headerlink" title="Vite 使用 esbuild 的优势"></a>Vite 使用 <code>esbuild</code> 的优势</h3><ol>
<li><strong>高性能</strong>：<code>esbuild</code> 是用 Go 语言编写的，编译速度比传统的 <code>tsc</code> 或 <code>babel</code> 快得多。</li>
<li><strong>即时反馈</strong>：<code>esbuild</code> 能够快速编译 TypeScript 文件，并在开发模式下提供即时的错误提示和热更新。</li>
<li><strong>集成性</strong>：Vite 将 <code>esbuild</code> 集成到其构建流程中，开发者无需额外配置，即可享受高效的 TypeScript 支持。</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Vite 在开发模式下通过 <code>esbuild</code> 动态编译 TypeScript 文件，并将结果存储在内存中，以支持快速的热更新。在生产模式下，Vite 会在构建过程中将 TypeScript 文件转换为 JavaScript，并进行优化和打包。整个过程是自动化的，开发者无需手动配置编译工具，这使得 Vite 的开发体验非常流畅。</p>
<h1 id="es-cjs-amd-umd"><a href="#es-cjs-amd-umd" class="headerlink" title="es cjs amd umd"></a>es cjs amd umd</h1><p>cjs:</p>
<ol>
<li>node 专用格式</li>
<li>require module.exports</li>
<li>同步加载模块的方式  运行时加载</li>
<li>输出的是一个值的拷贝</li>
</ol>
<p>amd 异步模块定义 浏览器:</p>
<ol>
<li>通过define来定义模块，使用require来异步加载模块</li>
<li>require 多用于解决循环依赖中，在运行时加载文件</li>
</ol>
<p>umd Universal Module Definition: </p>
<ol>
<li>通用的模块规范 包含CommonJS、AMD</li>
<li></li>
</ol>
<p>es：</p>
<ol>
<li>浏览器专用格式</li>
<li>支持静态分析 利于 tree-shaking 编译时加载</li>
<li>异步导入</li>
<li>import export</li>
<li>输出的是值的引用</li>
</ol>
<h3 id="XSS-攻击的本质手段"><a href="#XSS-攻击的本质手段" class="headerlink" title="XSS 攻击的本质手段"></a>XSS 攻击的本质手段</h3><ul>
<li><strong>利用输入输出漏洞</strong>：目标网站对用户输入没有进行充分的过滤和验证，以及对输出到页面的数据没有进行适当的编码处理。攻击者借此输入恶意脚本，如 JavaScript 代码，当网站将这些未处理的恶意内容输出到其他用户的浏览器时，浏览器会将其解析并执行，从而导致攻击成功。</li>
<li><strong>突破同源策略限制</strong>：同源策略是浏览器的一种安全机制，用于限制不同源的页面之间的交互。但 XSS 攻击通过在目标网站注入脚本，使恶意脚本在目标网站的源下执行，从而绕过同源策略的限制。这样恶意脚本就能够获取目标网站的敏感信息，如用户的登录凭证、个人数据等，或者执行一些对用户有害的操作，如修改页面内容、发起钓鱼攻击等。</li>
</ul>
<h3 id="CSRF-攻击的本质手段"><a href="#CSRF-攻击的本质手段" class="headerlink" title="CSRF 攻击的本质手段"></a>CSRF 攻击的本质手段</h3><ul>
<li><strong>伪装合法请求</strong>：攻击者利用用户在目标网站已登录的状态，构造一个看似合法的请求。这个请求可能看起来像是用户主动发起的正常操作，例如转账、修改密码等，但实际上是攻击者在用户不知情的情况下诱导浏览器发送的。攻击者通常会在恶意网站或邮件等地方隐藏这些伪造的请求，当用户访问恶意内容时，浏览器会自动发送这些请求到目标网站。</li>
<li><strong>利用用户身份凭证</strong>：用户在登录目标网站后，浏览器会保存用户的身份凭证，如 cookie、会话令牌等。CSRF 攻击的核心就是利用这些身份凭证，在用户没有主动操作的情况下，让浏览器携带这些凭证向目标网站发送请求。由于服务器只验证请求中携带的身份凭证是否有效，而不会验证请求是否真的是用户主动发起的，所以攻击者能够以用户的身份执行操作，达到篡改用户数据、执行恶意交易等目的</li>
</ul>
]]></content>
      <tags>
        <tag>面试八股复习</tag>
      </tags>
  </entry>
</search>
