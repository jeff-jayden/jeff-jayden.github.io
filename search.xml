<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>对浏览器的理解</title>
    <url>/2021/11/09/2021/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<h1 id="浏览器的事件循环"><a href="#浏览器的事件循环" class="headerlink" title="浏览器的事件循环"></a>浏览器的事件循环</h1><p>浏览器的事件循环是一种机制，用于管理和处理异步任务，以确保 JavaScript 在单线程环境中能够处理事件、执行代码和保持响应性。</p>
<p>事件循环的基本原理如下：</p>
<ol>
<li><strong>调用栈（Call Stack）：</strong> JavaScript代码的执行是通过调用栈来处理的。当你调用一个函数，它会被推入调用栈，当函数执行完成，它就会从调用栈中弹出。</li>
<li><strong>任务队列（Task Queue）：</strong> 任务队列存放异步任务，如事件处理函数、定时器回调等。任务队列中的任务在调用栈为空时才会被执行。</li>
<li><strong>事件循环（Event Loop）：</strong> 不断地检查调用栈和任务队列。如果调用栈为空，它会从任务队列中取出一个任务推入调用栈执行。这个过程不断重复，形成事件循环。</li>
</ol>
<p>基本流程：</p>
<ul>
<li>当执行同步代码时，代码会依次推入调用栈执行。</li>
<li>当遇到异步任务时（如定时器、事件监听器、网络请求等），会将任务放入任务队列。</li>
<li>当调用栈为空时，事件循环检查任务队列是否有任务。</li>
<li>如果有任务，将任务推入调用栈执行，重复上述过程。</li>
</ul>
<p>以下是事件循环的简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconsole.log(&#x27;Start&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setTimeout callback&#x27;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Promise resolved&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;End&#x27;);</span><br></pre></td></tr></table></figure>

<p>输出的顺序是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeStart</span><br><span class="line">End</span><br><span class="line">Promise resolved</span><br><span class="line">setTimeout callback</span><br></pre></td></tr></table></figure>

<p>这是因为 <code>setTimeout</code> 回调会被放入任务队列，而 <code>Promise</code> 的回调则会在微任务队列中，微任务队列的执行优先级高于任务队列。因此，先执行微任务中的 <code>Promise</code>，然后再执行 <code>setTimeout</code> 的回调。</p>
<h1 id="settimeout为什么不一定在指定时间后调用"><a href="#settimeout为什么不一定在指定时间后调用" class="headerlink" title="settimeout为什么不一定在指定时间后调用"></a>settimeout为什么不一定在指定时间后调用</h1><p><code>setTimeout</code> 的确切执行时间并不是精确的，并且不能保证在指定的时间后立即执行。这是因为JavaScript是单线程的，它在事件循环中处理任务队列，而不是通过多线程实现的。</p>
<p><code>setTimeout</code> 的行为受到事件循环和浏览器的实现方式的影响。具体来说，<code>setTimeout</code> 的执行时间取决于下面的几个因素：</p>
<ol>
<li><strong>最小延迟时间：</strong> 浏览器通常有一个最小的定时器延迟，即使你将定时器设置为0，它也可能会有一定的延迟，通常是4毫秒。这是因为浏览器会将定时器任务添加到任务队列，并在下一个事件循环迭代中执行。</li>
<li><strong>事件循环阶段：</strong> 如果在执行 <code>setTimeout</code> 的时候，事件循环正处于某个特定的阶段，那么定时器的回调会等到下一个合适的事件循环阶段再执行。这可能导致定时器的执行时间延迟。</li>
<li><strong>页面是否被隐藏：</strong> 如果页面被隐藏（例如，用户切换到其他标签或最小化浏览器），某些浏览器可能会将定时器的执行时间延迟，以减少对系统资源的使用。</li>
</ol>
<p>总体来说，<code>setTimeout</code> 并不是实现实时精确计时的最佳工具。如果需要更精确的计时，可以考虑使用 <code>requestAnimationFrame</code> 或 <code>Web Workers</code>，这些机制提供了更可靠的定时和并行处理能力。</p>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>监听器 变量引用 闭包  循环引用</p>
<p>垃圾回收机制：标记清除法 引用计数法有问题（循环引用）</p>
<h1 id="强制缓存与协商缓存"><a href="#强制缓存与协商缓存" class="headerlink" title="强制缓存与协商缓存"></a>强制缓存与协商缓存</h1><p>HTTP缓存是一种优化性能的重要机制，它可以减少资源的加载时间并减轻服务器的负担。缓存主要分为强制缓存和协商缓存两种策略。</p>
<h3 id="强制缓存："><a href="#强制缓存：" class="headerlink" title="强制缓存："></a>强制缓存：</h3><p>强制缓存是通过<code>Cache-Control</code>和<code>Expires</code>两个HTTP头来实现的。它告诉浏览器在特定时间内不需要再次请求相同的资源，而是直接从本地缓存中获取。常用的设置有：</p>
<ul>
<li><strong>Cache-Control：</strong> 使用<code>max-age</code>来设置资源在本地缓存中的最长时间（秒），例如 <code>Cache-Control: max-age=3600</code> 表示缓存有效期为1小时。</li>
<li><strong>Expires：</strong> 是一个过时的设置，它指定了缓存资源的到期时间。服务器返回的时间是绝对时间，由于存在时钟不同步等问题，因此<code>Cache-Control</code>的使用更为推荐。</li>
</ul>
<p>如果资源在强制缓存期间被请求，浏览器会直接从缓存中获取资源，而不发起实际的请求。</p>
<h3 id="协商缓存："><a href="#协商缓存：" class="headerlink" title="协商缓存："></a>协商缓存：</h3><p>协商缓存依赖于服务器与浏览器之间的“协商”，即服务器根据请求的条件来判断是否返回实际的资源或告诉浏览器直接使用缓存。协商缓存的实现主要依赖于以下两个HTTP头：</p>
<ul>
<li><strong>Last-Modified &#x2F; If-Modified-Since：</strong> 服务器在响应头中返回资源的最后修改时间，下次请求时浏览器通过<code>If-Modified-Since</code>头将上次的最后修改时间发送给服务器。如果资源在这之后没有被修改，服务器返回304 Not Modified，浏览器直接使用缓存。</li>
<li><strong>ETag &#x2F; If-None-Match：</strong> 服务器在响应头中返回资源的唯一标识，称为ETag。下次请求时浏览器通过<code>If-None-Match</code>头将上次的ETag发送给服务器。如果资源的ETag匹配，服务器返回304 Not Modified，浏览器直接使用缓存。</li>
</ul>
<p>协商缓存更加灵活，不仅可以判断资源是否修改，还可以使用更精确的标识来验证。如果同时存在<code>Last-Modified</code>和<code>ETag</code>，浏览器会优先使用<code>ETag</code>。</p>
<h1 id="cookie-sessionStorage-localStorage-的区别"><a href="#cookie-sessionStorage-localStorage-的区别" class="headerlink" title="cookie&#x2F;sessionStorage&#x2F;localStorage 的区别"></a>cookie&#x2F;sessionStorage&#x2F;localStorage 的区别</h1><p>参考答案:<br>cookie sessionStorage、localStorage都是保存本地数据的方式<br>其中，cookie 兼容性较好，所有浏览器均支持。</p>
<p>浏览器针对 cookie 会有一些默认行为，比如当响应头中出现 set-cookie 字段时，浏览器会自动保存 cookie 的值;</p>
<p>再比如，浏览器发送请求时，会附带匹配的 cookie 到请求头中。这些默认行为，使得cookie 长期以来担任着维持登录状态的责任。与此同时，也正是因为浏览器的默认行为给了恶意攻击者可乘之机，CSRF 攻击就是一个典型的利用 cookie 的攻击方式。虽然cookie 不断的改进，但前端仍然需要另一种更加安全的保存数据的方式<br>HTML5 新增了 sessionStorage 和 localStorage，前者用于保存会话级别的数据后者用于更持久的保存数据。浏览器针对它们没有任何默认行为，这样一来，就把保存数据读取数据的工作交给了前端开发者，这就让恶意攻击者难以针对登录状态进行攻击。</p>
<p>cookie 的大小是有限制的，一般浏览器会限制同一个域下的 cookie 总量为 4M，</p>
<p>而sessionStorage 和 localStorage 则没有限制cookie 会与 domain、path 关联，而 sessionStorage 和 localStorage 只与domain 关联</p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240507202004397.png"  alt="image-20240507202004397"></p>
<h1 id="cookie-sessionStorage-localStorage-的区别-1"><a href="#cookie-sessionStorage-localStorage-的区别-1" class="headerlink" title="cookie&#x2F;sessionStorage&#x2F;localStorage 的区别"></a>cookie&#x2F;sessionStorage&#x2F;localStorage 的区别</h1><p>Cookie、SessionStorage 和 LocalStorage 是用于在客户端存储数据的三种机制，它们之间有以下区别：</p>
<ol>
<li><strong>存储容量</strong>：<ul>
<li>Cookie：每个 Cookie 的大小一般被限制在 4KB 左右。</li>
<li>SessionStorage：通常可以存储 5MB 到 10MB 的数据。</li>
<li>LocalStorage：通常可以存储 5MB 到 10MB 的数据。</li>
</ul>
</li>
<li><strong>数据存储位置</strong>：<ul>
<li>Cookie：存储在客户端的浏览器中，并且会随着每次 HTTP 请求被发送到服务器端。</li>
<li>SessionStorage：存储在客户端的浏览器中，但数据仅在当前会话（当前页面或者标签页）有效，在关闭页面或者标签页时会被清除。</li>
<li>LocalStorage：存储在客户端的浏览器中，并且数据在不同的会话之间是共享的，除非手动清除。</li>
</ul>
</li>
<li><strong>数据生命周期</strong>：<ul>
<li>Cookie：可以设置过期时间，可以在设置的过期时间之前一直保存在客户端。</li>
<li>SessionStorage：仅在当前会话中有效，关闭页面或者标签页时会被清除。</li>
<li>LocalStorage：永久有效，除非被手动清除。</li>
</ul>
</li>
<li><strong>数据与服务器的通信</strong>：<ul>
<li>Cookie：会随着每次 HTTP 请求被发送到服务器端，因此可以用于在客户端和服务器之间传递数据。</li>
<li>SessionStorage 和 LocalStorage：数据仅在客户端存储，不会随着 HTTP 请求发送到服务器端。</li>
</ul>
</li>
<li><strong>访问权限</strong>：<ul>
<li>Cookie、SessionStorage 和 LocalStorage 的访问权限都受到同源策略的限制，即只能访问同源（协议、域名、端口号均相同）页面的存储数据。</li>
</ul>
</li>
</ol>
<h1 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h1><p>解析html（生成dom树，cssom树）–&gt; 样式计算（合并dom,cssom树）–&gt; 布局（布局树）–&gt; 分层（层次树）–&gt; 生成绘制指令集（未执行, 渲染主线程工作结束）–&gt; 分块（合成线程）–&gt; 光栅化 gpu将每个块变成位图 就是确认每一个像素点的 <em>rgb</em> 信息 –&gt;  绘制 （合成线程中执行）</p>
<p>为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 <em>HTML</em> 中的外部 <em>CSS</em> 文件和外部的 <em>JS</em> 文件。</p>
<p>如果主线程解析到 <em>link</em> 位置，此时外部的 <em>CSS</em> 文件还没有下载解析好，主线程不会等待，继续解析后续的 <em>HTML</em>。这是因为<strong>下载和解析 <em>CSS</em> 的工作是在预解析线程中进行的</strong>。这就是 <em>CSS</em> 不会阻塞 <em>HTML</em> 解析的根本原因。</p>
<p>这是<strong>因为 <em>JS</em> 代码的执行过程可能会修改当前的 <em>DOM</em> 树</strong>，所以 <em>DOM</em> 树的生成必须暂停。这就是 <em>JS</em> 会阻塞 <em>HTML</em> 解析的根本原因</p>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>算法总结</title>
    <url>/2022/11/09/2022/algorithm/</url>
    <content><![CDATA[<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><p>快速排序的关键在于分解步骤中如何选择基准元素以及如何进行分区。通常，可以选择数组中的一个元素作为基准，然后通过交换元素的方式将小于基准的元素移到基准的左边，大于基准的元素移到基准的右边。</p>
<p>由于快速排序使用了递归，它是一种高效的排序算法，<strong>平均时间复杂度为O(n log n)<strong>。然而，</strong>最坏情况下的时间复杂度为O(n^2)<strong>，这发生在每次选择的基准元素都是当前数组中的最大或最小值的情况下。为了避免最坏情况，可以</strong>采用随机选择基准元素</strong>的策略。</p>
]]></content>
      <tags>
        <tag>Algo</tag>
      </tags>
  </entry>
  <entry>
    <title>axios的使用</title>
    <url>/2023/11/09/2023/axios/</url>
    <content><![CDATA[<h1 id="Ajax-和-Axios的区别"><a href="#Ajax-和-Axios的区别" class="headerlink" title="Ajax 和 Axios的区别"></a>Ajax 和 Axios的区别</h1><p>Ajax 和 Axios 都用于发出异步的 HTTP 请求，但它们具有不同的基本机制。</p>
<ol>
<li>Ajax 是一组 Web 开发技术，利用客户端的许多 Web 技术来创建异步 Web 应用程序。</li>
<li>Ajax 是一种传统的 JavaScript 异步请求方法，通常使用 <code>XMLHttpRequest</code> 对象或 <code>fetch</code> API。</li>
<li>Ajax 是一组利用各种 Web 技术的 Web 开发技术</li>
</ol>
<hr>
<ol>
<li>Axios 是一个基于 Promise 的 HTTP 客户端，用于在浏览器和 Node.js 中轻松发送异步 HTTP 请求到 REST 端点并执行 CRUD .</li>
<li>Axios 则是一个更现代、用户友好的替代方案，它基于 Promise，并提供了比传统的 Ajax 方法更简单、更清晰的语法来发出 HTTP 请求。</li>
<li>Axios 是一个特定的 JavaScript 库，提供了一种简单的方式来发出异步的 HTTP 请求</li>
</ol>
]]></content>
      <tags>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>css学习记录</title>
    <url>/2023/11/09/2023/css/</url>
    <content><![CDATA[<h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a><a class="link"   href="https://www.w3school.com.cn/css/css3_flexbox.asp" >flex布局<i class="fas fa-external-link-alt"></i></a></h1><ul>
<li><code>flex-direction</code> 定义容器要在哪个方向上堆叠 flex 项目</li>
<li><code>flex-wrap</code>  规定是否应该对 flex 项目换行</li>
<li><code>flex-flow </code>   用于同时设置 flex-direction 和 flex-wrap 属性的简写属性</li>
<li><code>flex</code> 用于同时设置<code>flex-grow</code>(默认0) <code>flex-shrink</code> (默认1) <code>flex-basis</code> (默认auto)</li>
<li><code>justify-content</code>   用于对齐 flex 项目 （一行 左右方向操作）</li>
<li><code>align-items </code> 用于垂直对齐 flex 项目  (不换行的时候 上下方向操作)</li>
<li><code>align-content </code> 用于对齐弹性线 （换行得时候 上下方向操作）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex-flow: flex-direction flex-wrap</span><br><span class="line">flex: flex-grow(有剩余宽度的情况 0) flex-shrink(超出规定宽度的情况 1) flex-basis(基本的宽度 auto flex-basis比width具有更高的优先级)</span><br></pre></td></tr></table></figure>

<p><strong>align-self</strong>：auto | flex-start | flex-end | center | baseline | stretch</p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240323194835754.png"  alt="image-20240323194835754"></p>
<h1 id="li元素"><a href="#li元素" class="headerlink" title="li元素"></a>li元素</h1><p>list-style: &lt;’ <a class="link"   href="https://james-curtis.github.io/css-handbook/properties/list/list-style-type.htm" >list-style-type<i class="fas fa-external-link-alt"></i></a> ‘&gt; || &lt;’ <a class="link"   href="https://james-curtis.github.io/css-handbook/properties/list/list-style-position.htm" >list-style-position<i class="fas fa-external-link-alt"></i></a> ‘&gt; || &lt;’ <a class="link"   href="https://james-curtis.github.io/css-handbook/properties/list/list-style-image.htm" >list-style-image<i class="fas fa-external-link-alt"></i></a> ‘&gt;</p>
<p>disc outside none</p>
<h1 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h1><p>定位元素。即定义了<a class="link"   href="https://eric-gitta-moore.github.io/css-handbook/properties/positioning/position.htm" >position<i class="fas fa-external-link-alt"></i></a>为<code>非static</code>的元素</p>
<h1 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h1><h5 id="transform-translate-50-是参考哪个元素的50-参考自身的宽高"><a href="#transform-translate-50-是参考哪个元素的50-参考自身的宽高" class="headerlink" title="transform: translate(-50%);是参考哪个元素的50%  参考自身的宽高"></a>transform: translate(-50%);是参考哪个元素的50%  参考自身的宽高</h5><p><code>transform: translate(-50%,-50%);</code> 表示将元素沿着其自身的宽度和高度的一半进行平移。</p>
<p>需要注意的是，这种技术通常与绝对定位（absolute positioning）或固定定位（fixed positioning）一起使用，以便相对于其父元素进行居中定位。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.big</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.small</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://www.w3school.com.cn/css/css3_2dtransforms.asp"><code>transform</code></a> 变换  translate左右移动</p>
<p><code>transition</code> 过渡   元素慢慢变化</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition-property</span>: width;</span><br><span class="line"><span class="attribute">transition-duration</span>: <span class="number">2s</span>;</span><br><span class="line"><span class="attribute">transition-timing-function</span>: linear;</span><br><span class="line"><span class="attribute">transition-delay</span>: <span class="number">1s</span>;</span><br></pre></td></tr></table></figure>



<p><code>animation</code> 动画   none 0 ease 0 1 normal</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation</span>: name duration <span class="built_in">timing-function</span>(动画的速度) delay iteration-count direction;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@keyframes</span> 定义关键帧</span><br><span class="line"></span><br><span class="line"><span class="attribute">name</span>: 动画名</span><br><span class="line"><span class="attribute">duration</span>: 持续时间</span><br><span class="line">iteration-count：设置动画应运行多少次  infinite 无限次</span><br><span class="line">direction：反向或交替运行动画  normal - 动画正常播放（向前）。默认值</span><br><span class="line">                            reverse - 动画以反方向播放（向后）</span><br><span class="line">                            alternate - 动画先向前播放，然后向后</span><br><span class="line">                            alternate-reverse - 动画先向后播放，然后向前</span><br><span class="line">timing-function(动画的速度)</span><br><span class="line">                            ease - 指定从慢速开始，然后加快，然后缓慢结束的动画（默认）</span><br><span class="line">                            linear - 规定从开始到结束的速度相同的动画</span><br><span class="line">                            ease-in - 规定慢速开始的动画</span><br><span class="line">                            ease-out - 规定慢速结束的动画</span><br><span class="line">                            ease-in-out - 指定开始和结束较慢的动画</span><br><span class="line">                            cubic-bezier(n,n,n,n) - 运行您在三次贝塞尔函数中定义自己的值</span><br></pre></td></tr></table></figure>





<h1 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h1><p><a class="link"   href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" >链接<i class="fas fa-external-link-alt"></i></a></p>
<p>align-item 纵向  justify-item 横向</p>
<p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-items: &lt;align-items&gt; &lt;justify-items&gt;;</span><br></pre></td></tr></table></figure>

<p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: &lt;align-content&gt; &lt;justify-content&gt;</span><br></pre></td></tr></table></figure>

<p>grid-row  1&#x2F;3   1&#x2F;span 2</p>
<p>grid-column</p>
<p>grid-area  左上角点位置，右下角位置开区间，不包含  1&#x2F;2&#x2F;5&#x2F;6    [(1,2)到(5,6))这个区域</p>
<p><code>grid-gap</code> 属性是 grid-row-gap 和 grid-column-gap 属性的简写属性</p>
<h1 id="background"><a href="#background" class="headerlink" title="background"></a>background</h1><h1 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类&amp;伪元素"></a><a class="link"   href="https://www.w3school.com.cn/css/css_pseudo_elements.asp" >伪类&amp;伪元素<i class="fas fa-external-link-alt"></i></a></h1><p>: 伪类</p>
<p><code>:link</code>  未浏览</p>
<p><code>:visited</code>  已浏览</p>
<p><code>:hover</code>  鼠标放上去</p>
<p><code>:active</code> 点击得时候</p>
<p>:: 伪元素</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">例子</th>
<th align="left">例子描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/cssref/selector_after.asp" >::after<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">p::after</td>
<td align="left">在每个 <p> 元素之后插入内容。</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/cssref/selector_before.asp" >::before<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">p::before</td>
<td align="left">在每个 <p> 元素之前插入内容。</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/cssref/selector_first-letter.asp" >::first-letter<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">p::first-letter</td>
<td align="left">选择每个 <p> 元素的首字母。</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/cssref/selector_first-line.asp" >::first-line<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">p::first-line</td>
<td align="left">选择每个 <p> 元素的首行。</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/cssref/selector_selection.asp" >::selection<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">p::selection</td>
<td align="left">选择用户选择的元素部分。</td>
</tr>
</tbody></table>
<h1 id="nth-child-nth-of-type"><a href="#nth-child-nth-of-type" class="headerlink" title="nth-child&amp;nth-of-type()"></a>nth-child&amp;nth-of-type()</h1><p>:nth-child(n) :nth-last-child(n)(倒着数) :first-child :last-child  表示在每一组有父子结构的都会生效</p>
<p>:first-of-type :last-of-type :nth-of-type(n) :nth-last-of-type(n)  匹配父元素的倒数第n个子元素</p>
<p><a href="https://www.cnblogs.com/2050/p/3569509.html"><code>first-child</code>与<code>first-of-type</code>的区别</a> </p>
<p><strong>:first-child</strong> 匹配的是某父元素的第一个子元素，可以说是结构上的第一个子元素。</p>
<p><strong>:first-of-type</strong> 匹配的是某父元素下相同类型子元素中的第一个，比如 p:first-of-type，就是指所有类型为p的子元素中的第一个。这里不再限制是第一个子元素了，只要是该类型元素的第一个就行了。</p>
<p>同样类型的选择器 :last-child 和 :last-of-type、:nth-child(n) 和 :nth-of-type(n) 也可以这样去理解。</p>
<h1 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h1><p><a class="link"   href="https://www.w3school.com.cn/css/css_attribute_selectors.asp" >链接<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li><p>[attribute|&#x3D;”value”] 选择器用于选取指定属性以指定值开头的元素</p>
</li>
<li><p>[attribute^&#x3D;”value”] 选择器用于选取指定属性以指定值开头的元素 值不必是完整单词</p>
</li>
<li><p>[attribute$&#x3D;”value”] 选择器用于选取指定属性以指定值结尾的元素 值不必是完整单词</p>
</li>
<li><p>[attribute*&#x3D;”value”] 选择器选取属性值包含指定词的元素 值不必是完整单词</p>
</li>
</ul>
<h1 id="position"><a href="#position" class="headerlink" title="position"></a>position</h1><p><a class="link"   href="https://www.w3school.com.cn/css/css_positioning.asp" >链接<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li><p>static                                              top、bottom、left 和 right不起作用</p>
</li>
<li><p>relative                                          相对于其正常位置进行定位</p>
</li>
<li><p>fixed                                               固定某个元素不动   top、bottom、left 和 right进行调整位置在哪固定</p>
</li>
<li><p>absolute                                        相对于最近的定位祖先元素（除了static都算定位元素）进行定位（而不是相对于视口定位，如          fixed）如果绝对定位的元素没有祖先，它将使用文档主体（body），并随页面滚动一起移动</p>
</li>
<li><p>sticky                                              起先它会被相对定位，直到在视口中遇到给定的偏移位置为止 - 然后将其“粘贴”在适当的位置（比如  </p>
<p>​                                                        position:fixed）</p>
</li>
</ul>
<p>absolute和fixed会脱离文档流</p>
<h1 id="margin塌陷"><a href="#margin塌陷" class="headerlink" title="margin塌陷"></a>margin塌陷</h1><p><a class="link"   href="https://juejin.cn/post/6976272394247897101" >https://juejin.cn/post/6976272394247897101<i class="fas fa-external-link-alt"></i></a></p>
<p>父子嵌套的元素垂直方向的<code>margin</code>取最大值</p>
<p>解决margin塌陷方法</p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240105224715948.png"  alt="image-20240105224715948"></p>
<p>margin合并</p>
<p>两个上下相邻元素的外边距取最大值</p>
<h1 id="rem和em区别"><a href="#rem和em区别" class="headerlink" title="rem和em区别"></a>rem和em区别</h1><p>rem与em都是相对单位，我们使用它们的目的就是为了适应各种不同的移动端和pc端的屏幕。 <strong>rem是根据html根节点来计算的，而em是根据父级元素的字体计算的</strong>。 简单概括就是: rem相对于根元素,   em相对于父元素字体</p>
<h1 id="预处理器-后处理器"><a href="#预处理器-后处理器" class="headerlink" title="预处理器&amp;后处理器"></a>预处理器&amp;后处理器</h1><p>less sass cssnext</p>
<p>autoprefixer</p>
<h1 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h1><p>box-shadow: h-shadow v-shadow blur spread color inset;</p>
<h3 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h3><table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
<th align="left">测试</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>h-shadow</em></td>
<td align="left">必需。水平阴影的位置。允许负值。</td>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/tiy/c.asp?f=css_box-shadow" >测试<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td align="left"><em>v-shadow</em></td>
<td align="left">必需。垂直阴影的位置。允许负值。</td>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/tiy/c.asp?f=css_box-shadow" >测试<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td align="left"><em>blur</em></td>
<td align="left">可选。模糊距离。</td>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/tiy/c.asp?f=css_box-shadow&p=3" >测试<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td align="left"><em>spread</em></td>
<td align="left">可选。阴影的尺寸。</td>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/tiy/c.asp?f=css_box-shadow&p=7" >测试<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td align="left"><em>color</em></td>
<td align="left">可选。阴影的颜色。请参阅 CSS 颜色值。</td>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/tiy/c.asp?f=css_box-shadow&p=10" >测试<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td align="left">inset</td>
<td align="left">可选。将外部阴影 (outset) 改为内部阴影。</td>
<td align="left"><a class="link"   href="https://www.w3school.com.cn/tiy/c.asp?f=css_box-shadow&p=15" >测试<i class="fas fa-external-link-alt"></i></a></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>默认值：</th>
<th>none</th>
</tr>
</thead>
</table>
<h1 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h1><ul>
<li><a class="link"   href="https://www.w3school.com.cn/cssref/pr_grid-template-rows.asp" >grid-template-rows<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.w3school.com.cn/cssref/pr_grid-template-columns.asp" >grid-template-columns<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.w3school.com.cn/cssref/pr_grid-template-areas.asp" >grid-template-areas<i class="fas fa-external-link-alt"></i></a> 要设置grid-area属性</li>
<li><a class="link"   href="https://www.w3school.com.cn/cssref/pr_grid-auto-rows.asp" >grid-auto-rows<i class="fas fa-external-link-alt"></i></a>  grid-template-rows 属性覆盖此属性</li>
<li><a class="link"   href="https://www.w3school.com.cn/cssref/pr_grid-auto-columns.asp" >grid-auto-columns<i class="fas fa-external-link-alt"></i></a>  grid-template-columns 属性会覆盖此属性</li>
<li><a class="link"   href="https://www.w3school.com.cn/cssref/pr_grid-auto-flow.asp" >grid-auto-flow<i class="fas fa-external-link-alt"></i></a>  两个属性 row column</li>
</ul>
<p>grid-area: 语法是 grid-row-start &#x2F; grid-column-start &#x2F; grid-row-end &#x2F; grid-column-end<br>默认值 auto &#x2F; auto &#x2F; auto &#x2F; auto	</p>
<p>grid: none|grid-template-rows &#x2F; grid-template-columns|grid-template-areas|grid-template-rows &#x2F; [grid-auto-flow] grid-auto-columns|[grid-auto-flow] grid-auto-rows &#x2F; grid-template-columns|initial|inherit;</p>
<h2 id="属性值-1"><a href="#属性值-1" class="headerlink" title="属性值"></a>属性值</h2><table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">默认值。不定义行或列的尺寸。</td>
</tr>
<tr>
<td align="left"><em>grid-template-rows</em> &#x2F; <em>grid-template-columns</em></td>
<td align="left">规定列和行的尺寸。</td>
</tr>
<tr>
<td align="left"><em>grid-template-areas</em></td>
<td align="left">规定使用命名项目的网格布局。</td>
</tr>
<tr>
<td align="left"><em>grid-template-rows</em> &#x2F; <em>grid-auto-columns</em></td>
<td align="left">规定行的尺寸（高度），以及列的自动尺寸。</td>
</tr>
<tr>
<td align="left"><em>grid-auto-rows</em> &#x2F; <em>grid-template-columns</em></td>
<td align="left">规定行的自动尺寸，并设置 grid-template-columns 属性。</td>
</tr>
<tr>
<td align="left"><em>grid-template-rows</em> &#x2F; <em>grid-auto-flow</em> <em>grid-auto-columns</em></td>
<td align="left">规定行的尺寸（高度），以及如何放置自动就位的项目，和列的自动尺寸。</td>
</tr>
<tr>
<td align="left"><em>grid-auto-flow</em> <em>grid-auto-rows</em> &#x2F; <em>grid-template-columns</em></td>
<td align="left">规定如何放置自动就位的项目，和行的自动尺寸，以及设置 grid-template-columns 属性。</td>
</tr>
<tr>
<td align="left">initial</td>
<td align="left">将此属性设置为其默认值。参阅 <a class="link"   href="https://www.w3school.com.cn/cssref/css_initial.asp" >initial<i class="fas fa-external-link-alt"></i></a>。</td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">从其父元素继承此属性。参阅 <a class="link"   href="https://www.w3school.com.cn/cssref/css_inherit.asp" >inherit<i class="fas fa-external-link-alt"></i></a>。</td>
</tr>
</tbody></table>
<h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><table>
<thead>
<tr>
<th>默认值：</th>
<th>none none none auto auto row</th>
</tr>
</thead>
</table>
<h1 id="实现图片文字居中"><a href="#实现图片文字居中" class="headerlink" title="实现图片文字居中"></a>实现图片文字居中</h1><p>vertical-align</p>
<h1 id="如何实现盒子内容水平居中"><a href="#如何实现盒子内容水平居中" class="headerlink" title="如何实现盒子内容水平居中"></a>如何实现盒子内容水平居中</h1><ul>
<li><p>行内元素或者内联元素 使用父元素的 <code>text-align</code> 属性来实现文本水平居中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>块级元素 使用<code>margin: auto;</code> 来使元素水平居中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 flex 布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 grid 布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  place-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用transform</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="如何实现两栏分开布局"><a href="#如何实现两栏分开布局" class="headerlink" title="如何实现两栏分开布局"></a>如何实现两栏分开布局</h1><h4 id="1-流式布局（使用-float）："><a href="#1-流式布局（使用-float）：" class="headerlink" title="1. 流式布局（使用 float）："></a>1. 流式布局（使用 <code>float</code>）：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left-column</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right-column</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Flex-布局："><a href="#2-Flex-布局：" class="headerlink" title="2. Flex 布局："></a>2. Flex 布局：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left-column</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">70%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right-column</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Grid-布局："><a href="#3-Grid-布局：" class="headerlink" title="3. Grid 布局："></a>3. Grid 布局：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">70%</span> <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何实现三栏布局"><a href="#如何实现三栏布局" class="headerlink" title="如何实现三栏布局"></a>如何实现三栏布局</h1><h3 id="1-流式布局（使用-float）：-1"><a href="#1-流式布局（使用-float）：-1" class="headerlink" title="1. 流式布局（使用 float）："></a>1. 流式布局（使用 <code>float</code>）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left-column &#123;</span><br><span class="line">  width: 30%;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.center-column &#123;</span><br><span class="line">  width: 40%;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right-column &#123;</span><br><span class="line">  width: 30%;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Flex-布局：-1"><a href="#2-Flex-布局：-1" class="headerlink" title="2. Flex 布局："></a>2. Flex 布局：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left-column &#123;</span><br><span class="line">  flex: 30%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.center-column &#123;</span><br><span class="line">  flex: 40%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right-column &#123;</span><br><span class="line">  flex: 30%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Grid-布局：-1"><a href="#3-Grid-布局：-1" class="headerlink" title="3. Grid 布局："></a>3. Grid 布局：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 30% 40% 30%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-圣杯布局（使用-flex-和负边距）："><a href="#4-圣杯布局（使用-flex-和负边距）：" class="headerlink" title="4. 圣杯布局（使用 flex 和负边距）："></a>4. 圣杯布局（使用 <code>flex</code> 和负边距）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left-column,</span><br><span class="line">.right-column,</span><br><span class="line">.center-column &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.center-column &#123;</span><br><span class="line">  order: 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left-column &#123;</span><br><span class="line">  order: 1;</span><br><span class="line">  margin-right: -100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right-column &#123;</span><br><span class="line">  order: 3;</span><br><span class="line">  margin-left: -100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-双飞翼布局（使用-float-和-margin）："><a href="#5-双飞翼布局（使用-float-和-margin）：" class="headerlink" title="5. 双飞翼布局（使用 float 和 margin）："></a>5. 双飞翼布局（使用 <code>float</code> 和 <code>margin</code>）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.column &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left-column &#123;</span><br><span class="line">  width: 30%;</span><br><span class="line">  margin-left: -100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.center-column &#123;</span><br><span class="line">  width: 40%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right-column &#123;</span><br><span class="line">  width: 30%;</span><br><span class="line">  margin-left: -30%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="块级格式化上下文"><a href="#块级格式化上下文" class="headerlink" title="块级格式化上下文"></a>块级格式化上下文</h1><p>BFC 主要用于处理布局和浮动等问题，它规定了块级盒子如何堆叠、定位和清除浮动</p>
<p>创建 BFC 的方式有多种，其中一些包括：</p>
<ul>
<li><strong>根元素：</strong> HTML 文档的根元素（html）就是一个 BFC。</li>
<li><strong>浮动元素：</strong> 元素的 float 属性不是 none。</li>
<li><strong>绝对定位元素：</strong> 元素的 position 属性为 absolute 或 fixed。</li>
<li><strong>display 属性值不为 block、inline-block、flex、inline-flex 之一的元素：</strong> 例如，table 元素会生成一个 BFC。</li>
<li><strong>overflow 属性不为 visible 的元素：</strong> 设置了 overflow 属性值为 auto、scroll、hidden 的元素会生成 BFC。</li>
</ul>
<h1 id="尺寸的百分比"><a href="#尺寸的百分比" class="headerlink" title="尺寸的百分比"></a>尺寸的百分比</h1><p>普通元素相对于父元素的内容区域  （没有定位的元素称为普通元素）</p>
<p>绝对 (固定) 定位元素的参考系为父元素中 第一个定位元素的padding区域</p>
<h1 id="隐藏元素的三种方式"><a href="#隐藏元素的三种方式" class="headerlink" title="隐藏元素的三种方式"></a>隐藏元素的三种方式</h1><p>如果需要彻底隐藏元素且不占据页面空间，可以使用 <code>display: none;</code>；</p>
<p>如果需要隐藏元素但仍然占据页面空间，可以使用 <code>visibility: hidden;</code>；</p>
<p>如果需要隐藏元素但仍然保留占据的空间且可能需要进行过渡效果，可以使用 <code>opacity: 0;</code></p>
<h1 id="css-loader-style-loader-less-loader-sass-loader"><a href="#css-loader-style-loader-less-loader-sass-loader" class="headerlink" title="css-loader&amp;style-loader&amp;less-loader&amp;sass-loader"></a>css-loader&amp;style-loader&amp;less-loader&amp;sass-loader</h1><p>由于css-loader仅提供了将css转换为字符串导出的能力</p>
<p>style-loader可以将css-loader转换后的代码进一步处理，将css-loader导出的字符串加入到页面的style元素中</p>
<p>BEM  &amp;  CSS in js  &amp; CSS module</p>
<p>BEM全称是：<strong>B</strong>lock <strong>E</strong>lement <strong>M</strong>odifier</p>
<p>BEM是一套针对css类样式的命名方法</p>
<p>三个部分的具体含义为：</p>
<ul>
<li><strong>Block</strong>：页面中的大区域，表示最顶级的划分，例如：轮播图(<code>banner</code>)、布局(<code>layout</code>)、文章(<code>article</code>)等等</li>
<li><strong>element</strong>：区域中的组成部分，例如：轮播图中的横幅图片(<code>banner__img</code>)、轮播图中的容器（<code>banner__container</code>）、布局中的头部(<code>layout__header</code>)、文章中的标题(<code>article_title</code>)</li>
<li><strong>modifier</strong>：可选。通常表示状态，例如：处于展开状态的布局左边栏（<code>layout__left_expand</code>）、处于选中状态的轮播图小圆点(<code>banner__dot_selected</code>)</li>
</ul>
<p>css in js 的核心思想是：用一个JS对象来描述样式，而不是css样式表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> styles = &#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>: <span class="string">&quot;#f40&quot;</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;#fff&quot;</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="string">&quot;400px&quot;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="string">&quot;500px&quot;</span>,</span><br><span class="line">    <span class="attr">margin</span>: <span class="string">&quot;0 auto&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="postcss"><a href="#postcss" class="headerlink" title="postcss"></a>postcss</h1><p>真正起作用的是里面的插件<code>postcss-preset-env</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: &#123;</span><br><span class="line">        <span class="string">&quot;postcss-preset-env&quot;</span>: &#123;&#125; <span class="comment">// &#123;&#125; 中可以填写插件的配置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="border"><a href="#border" class="headerlink" title="border"></a>border</h1><p><a class="link"   href="https://www.w3school.com.cn/css/css_border_shorthand.asp" >https://www.w3school.com.cn/css/css_border_shorthand.asp<i class="fas fa-external-link-alt"></i></a></p>
<p>border:  三个属性简写</p>
<ul>
<li><code>border-width</code></li>
<li><code>border-style</code>（必需）</li>
<li><code>border-color</code></li>
</ul>
<p>以切角的形式相连  比如做个三角形</p>
<p>在CSS中，样式权重（也称为“优先级”）决定了当多个规则作用于同一个元素时，哪一个规则会被应用。权重的计算是基于选择器的类型和优先级规则来确定的。以下是CSS样式权重的具体计算方法：</p>
<h3 id="1-权重的基本组成"><a href="#1-权重的基本组成" class="headerlink" title="1. 权重的基本组成"></a>1. <strong>权重的基本组成</strong></h3><p>CSS权重由以下几部分组成，从高到低依次为：</p>
<ol>
<li><strong>内联样式（Inline Styles）</strong>：直接写在HTML标签的<code>style</code>属性中的样式。</li>
<li><strong>ID选择器（ID Selectors）</strong>：通过<code>id</code>属性选择元素。</li>
<li><strong>类选择器、属性选择器和伪类选择器（Class, Attribute, Pseudo-class Selectors）</strong>：通过类名、属性或伪类选择元素。</li>
<li><strong>元素选择器和伪元素选择器（Element Selectors and Pseudo-elements）</strong>：通过标签名或伪元素选择元素。</li>
<li><strong>通用选择器（Universal Selector）</strong>：<code>*</code>选择器，权重最低。</li>
</ol>
<h3 id="2-权重的计算方法"><a href="#2-权重的计算方法" class="headerlink" title="2. 权重的计算方法"></a>2. <strong>权重的计算方法</strong></h3><p>权重通常用一个四元组<code>(a, b, c, d)</code>来表示，其中：</p>
<ul>
<li><code>a</code>：内联样式（<code>style</code>属性）的数量。</li>
<li><code>b</code>：ID选择器的数量。</li>
<li><code>c</code>：类选择器、属性选择器和伪类选择器的数量。</li>
<li><code>d</code>：元素选择器和伪元素选择器的数量。</li>
</ul>
<p><strong>规则：</strong></p>
<ul>
<li>如果两个选择器的权重不同，则权重高的优先。</li>
<li>如果权重相同，则后定义的样式优先（CSS的“后定义覆盖先定义”规则）。</li>
<li>如果权重相同且定义顺序也相同，则继承的样式优先级最低。</li>
</ul>
<h3 id="3-权重计算示例"><a href="#3-权重计算示例" class="headerlink" title="3. 权重计算示例"></a>3. <strong>权重计算示例</strong></h3><p>以下是一些权重计算的例子：</p>
<h4 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: blue; &#125; <span class="comment">/* 权重：(0, 0, 0, 1) */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123; <span class="attribute">color</span>: green; &#125; <span class="comment">/* 权重：(0, 0, 1, 0) */</span></span><br><span class="line"><span class="selector-id">#main</span> &#123; <span class="attribute">color</span>: yellow; &#125; <span class="comment">/* 权重：(0, 1, 0, 0) */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.container</span> &#123; <span class="attribute">color</span>: purple; &#125; <span class="comment">/* 权重：(0, 0, 1, 1) */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#main</span> &#123; <span class="attribute">color</span>: orange; &#125; <span class="comment">/* 权重：(0, 1, 0, 1) */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#main</span><span class="selector-class">.container</span> &#123; <span class="attribute">color</span>: pink; &#125; <span class="comment">/* 权重：(0, 1, 1, 1) */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[style]</span> &#123; <span class="attribute">color</span>: black; &#125; <span class="comment">/* 权重：(1, 0, 0, 1) */</span></span><br></pre></td></tr></table></figure>
<p>最终，<code>color: red;</code>（内联样式）会生效，因为它的权重最高：<code>(1, 0, 0, 0)</code>。</p>
<h4 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.container</span> &#123; <span class="attribute">color</span>: purple; &#125; <span class="comment">/* 权重：(0, 0, 1, 1) */</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: green; &#125; <span class="comment">/* 权重：(0, 0, 1, 1) */</span></span><br></pre></td></tr></table></figure>
<p>两个选择器的权重相同，但<code>div.container</code>定义在前，<code>color: purple</code>会生效。</p>
<h4 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: blue; &#125; <span class="comment">/* 权重：(0, 0, 0, 1) */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123; <span class="attribute">color</span>: green; &#125; <span class="comment">/* 权重：(0, 0, 1, 0) */</span></span><br></pre></td></tr></table></figure>
<p><code>color: green;</code>会生效，因为它的权重更高。</p>
<h3 id="4-特殊情况"><a href="#4-特殊情况" class="headerlink" title="4. 特殊情况"></a>4. <strong>特殊情况</strong></h3><ul>
<li><strong><code>!important</code>规则</strong>：如果样式中使用了<code>!important</code>，则该样式会覆盖其他任何权重更高的样式。但<code>!important</code>应谨慎使用，因为它会破坏正常的权重规则。</li>
<li><strong>继承样式</strong>：某些CSS属性（如<code>color</code>和<code>font-size</code>）会从父元素继承，但继承的样式权重最低，可以被其他任何规则覆盖。</li>
</ul>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h3><p>CSS样式的权重计算是基于选择器的类型和数量来决定的。通过合理使用选择器和避免过度依赖<code>!important</code>，可以更好地控制样式的优先级，使CSS代码更加清晰和易于维护。</p>
]]></content>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>html</title>
    <url>/2023/08/11/2023/html/</url>
    <content><![CDATA[<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><p><img   src="/../images/html/Standard-box-model.png"  alt="images"><br><img   src="/../images/html/Weird-box-model.webp"  alt="images"></p>
<h1 id="元素的offsetHeight、scrollHeight、clientHeight属性"><a href="#元素的offsetHeight、scrollHeight、clientHeight属性" class="headerlink" title="元素的offsetHeight、scrollHeight、clientHeight属性"></a>元素的offsetHeight、scrollHeight、clientHeight属性</h1><p>offsetHeight: 包含元素的边框、内边距、内容和元素的水平滚动条（如果存在且渲染的话）<br><img   src="/../images/html/dimensions-offset.png"  alt="images"></p>
<p>offsetTop: 仅仅是元素边框之间的距离，当前元素相对于最近的定位父元素或者最近的 <code>table</code>, <code>td</code>, <code>th</code>, <code>body</code> 元素<br><img   src="/../images/html/offsetTop.webp"  alt="images"></p>
<p>scrollHeight: 只读属性 包括由于溢出导致的视图中不可见内容 即包括元素的内边距、内容高度<br><img   src="/../images/html/scrollheight.png"  alt="images"></p>
<p>scrollTop: 可以获取或设置元素内容从其顶部边缘滚动的像素数<br><img   src="/../images/html/scrollTop.webp"  alt="images"></p>
<p>clientHeight: 通过 CSS <code>height</code> + CSS <code>padding</code> - 水平滚动条高度（如果存在）来计算<br><img   src="/../images/html/dimensions-client.png"  alt="images"></p>
<p>clientTop: 获取元素顶部边框的宽度（以像素表示）</p>
]]></content>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript学习记录</title>
    <url>/2023/03/09/2023/javascript/</url>
    <content><![CDATA[<h1 id="js核心一点的东西"><a href="#js核心一点的东西" class="headerlink" title="js核心一点的东西"></a>js核心一点的东西</h1><ol>
<li><p>堆栈</p>
</li>
<li><p>事件循环</p>
</li>
<li><p>原型和原型链</p>
</li>
<li><p>执行上下文</p>
<ul>
<li>不会保存匿名函数</li>
</ul>
</li>
<li><p>作用域和作用域链</p>
</li>
<li><p><a class="link"   href="https://juejin.cn/post/6937469222251560990#heading-0" >闭包<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li>函数创建时形成闭包</li>
<li>闭包是指有权访问另一函数作用域中变量的函数</li>
<li>内部的函数存在外部作用域的引用就会导致闭包</li>
</ul>
</li>
</ol>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240317135032288.png"  alt="image-20240317135032288"></p>
<h1 id="基本数据类型，复杂"><a href="#基本数据类型，复杂" class="headerlink" title="基本数据类型，复杂"></a>基本数据类型，复杂</h1><p>string，number, boolean, null, undefined, symbol, bigint<br>object, function, date</p>
<h1 id="事件捕获冒泡"><a href="#事件捕获冒泡" class="headerlink" title="事件捕获冒泡"></a>事件捕获冒泡</h1><p>先捕获 在冒泡</p>
<p>addEventListener（‘click’,cb,false）</p>
<p>false 表示冒泡 （默认） true : 捕获</p>
<p>preventDefault <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault#%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C" >阻止默认的点击事件执行<i class="fas fa-external-link-alt"></i></a></p>
<p>stopPropagation <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event"><code>Event</code></a> 接口的 <strong><code>stopPropagation()</code></strong> 方法阻止捕获和冒泡阶段中当前事件的进一步传播。但是，它不能防止任何默认行为的发生；例如，对链接的点击仍会被处理	总结无用</p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240404140003753.png"  alt="image-20240404140003753"></p>
<h1 id="数组的sort"><a href="#数组的sort" class="headerlink" title="数组的sort"></a>数组的sort</h1><p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240405195816117.png"  alt="image-20240405195816117"></p>
<h1 id="settimeout-知识点"><a href="#settimeout-知识点" class="headerlink" title="settimeout 知识点"></a><a class="link"   href="https://blog.csdn.net/weixin_44179269/article/details/113420767" >settimeout<i class="fas fa-external-link-alt"></i></a> 知识点</h1><p>this关键字将指向全局环境</p>
<p>使用匿名函数在局部作用域作用</p>
<h1 id="闭包-实现数据的私有"><a href="#闭包-实现数据的私有" class="headerlink" title="闭包 实现数据的私有"></a>闭包 实现数据的私有</h1><p>1.return  将局部变量返回 让外部能够使用</p>
<p>2.内存泄漏 （占用内存无法释放）</p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106112237318.png"  alt="image-20240106112237318"></p>
<h1 id="节流与防抖"><a href="#节流与防抖" class="headerlink" title="节流与防抖"></a><a class="link"   href="https://juejin.cn/post/7324522555268366351?searchId=20240317144635AC78650ACECF33156AFD" >节流与防抖<i class="fas fa-external-link-alt"></i></a></h1><p>防抖：<img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106112829283.png"  alt="image-20240106112829283"></p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106113827578.png"  alt="image-20240106113827578"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleDebounce</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Debounced function called&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> debouncedFunction = <span class="title function_">debounce</span>(handleDebounce, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟高频率调用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">debouncedFunction</span>();</span><br><span class="line">    &#125;, i * <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106113417048.png"  alt="image-20240106113417048"></p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106113652153.png"  alt="image-20240106113652153"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleThrottle</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Throttled function called&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> throttledFunction = <span class="title function_">throttle</span>(handleThrottle, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟高频率调用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">throttledFunction</span>();</span><br><span class="line">    &#125;, i * <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106113750195.png"  alt="image-20240106113750195"></p>
<h1 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h1><p>一种 函数对象的 __ proto __ &#x3D;&#x3D;&gt; Function.prototype</p>
<p>一种 原型对象的 __ proto __ &#x3D;&#x3D;&gt; Object.prototype</p>
<p><a class="link"   href="https://juejin.cn/post/7255605810453217335?searchId=20240819224623005400B7CDE5BA5B584B" >下图来源<i class="fas fa-external-link-alt"></i></a></p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240316221910332.png"  alt="image-20240316221910332"></p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240316222709961.png"  alt="image-20240316222709961"></p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106114817353.png"  alt="image-20240106114817353"></p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240106114855144.png"  alt="image-20240106114855144"></p>
<h1 id="关于变量提升"><a href="#关于变量提升" class="headerlink" title="关于变量提升"></a>关于变量提升</h1><p>var变量声明提升，函数声明提升，函数内部var声明变量提升</p>
<p>函数表达式不会被提升</p>
<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p><a class="link"   href="https://juejin.cn/post/6844903682283143181" >https://juejin.cn/post/6844903682283143181<i class="fas fa-external-link-alt"></i></a></p>
<p>1.this绑定是在函数运行时发生的   </p>
<p>在全局执行上下文中，<code>this</code> 的值指向全局对象。(在浏览器中，<code>this</code>引用 Window 对象)。 默认</p>
<p>在函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象，否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）  隐式</p>
<p>2.词法环境组件 let const</p>
<ul>
<li>在<strong>全局环境</strong>（全局执行上下文）中，环境记录器是<strong>对象</strong>环境记录器。用来定义出现在<strong>全局上下文</strong>中的变量和函数的关系</li>
<li>在<strong>函数环境</strong>中，环境记录器是<strong>声明式</strong>环境记录器     存储变量、函数和参数 arguments对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong></li>
</ul>
<p>3.变量环境组件  var</p>
<h1 id="this指向四种调用模式判断"><a href="#this指向四种调用模式判断" class="headerlink" title="this指向四种调用模式判断"></a>this指向四种调用模式判断</h1><p><a class="link"   href="https://www.yuque.com/cuggz/interview/vgbphi#e39a6ab8b784fd88bbcf2aeb2ed82b8d" >https://www.yuque.com/cuggz/interview/vgbphi#e39a6ab8b784fd88bbcf2aeb2ed82b8d<i class="fas fa-external-link-alt"></i></a></p>
<p>优先级：构造器（new）–&gt; call apply bind  –&gt; 方法 –&gt;  函数        new  显式 隐式  默认</p>
<p>1.this绑定是在函数运行时发生的   </p>
<p>在全局执行上下文中，<code>this</code> 的值指向全局对象。(在浏览器中，<code>this</code>引用 Window 对象)。 默认</p>
<p>在函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象，否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）  隐式</p>
<p>1、fn.call (newThis,params) call函数的第一个参数是this的新指向，后面依次传入函数fn要用到的参数。会立即执行fn函数。<br>2、fn.apply (newThis,paramsArr) apply函数的第一个参数是this的新指向,第二个参数是fn要用到的参数数组，会立即执行fn函数。<br>3、fn.bind (newThis,params) bind函数的第一个参数是this的新指向，后面的参数可以直接传递，也可以按数组的形式传入。  不会立即执行fn函数，且只能改变一次fn函数的指向，后续再用bind更改无效。返回的是已经更改this指向的新fn</p>
<p>箭头函数.它的this由定义它的结构代码时父级执行上下文决定的</p>
<ul>
<li>如果是在全局环境,或者是<strong>在一个对象里</strong>,它的父级执行上下文就是全局环境,它的this就指向了window</li>
<li>如果它的外部是一个函数,那么它的this就指向了函数的执行上下文.而函数的执行上下文就是活的.取决于调用时的情况.也就上面列举的四种情况</li>
</ul>
<h1 id="执行上下文中包含的东西："><a href="#执行上下文中包含的东西：" class="headerlink" title="执行上下文中包含的东西："></a>执行上下文中包含的东西：</h1><p>1.this指向</p>
<ol>
<li><p>. 直接调用函数，this指向全局对象  eg:  fn();</p>
</li>
<li><p>. 在函数外，this指向全局对象</p>
</li>
<li><p>.通过<strong>对象调用或new一个函数</strong>，this指向<strong>调用的对象</strong>或<strong>新对象</strong></p>
</li>
</ol>
<p>2.VO 变量对象<br>Variable object: VO中记录了该环境中所有声明的<strong>参数、变量和函数</strong><br>Global object: GO，全局执行上下文中的vO</p>
<p>1).确定所有形参值以及特殊变量arguments</p>
<p>2).确定函数中通过var声明的变量，将它们的值设置为undefined （ 变量名重复 忽略）</p>
<p>3).确定函数中通过字面量声明的函数，将它们的值设置为指向函数对象 （函数名重复 覆盖） 函数还优于变量</p>
<p>当一个上下文中的代码执行的时候，如果上下文中不存在某个属性，则会从之前的上下文寻找。</p>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><ol>
<li>VO中包含一个额外的属性，该属性指向创建该VO的函数本身</li>
<li>每个函数在创建时，会有一个隐藏属性<code>[[scope]]</code>，它指向创建该函数时的AO</li>
<li>当访问一个变量时，会先查找自身VO中是否存在，如果不存在，则依次查找<code>[[scope]]</code>属性。</li>
<li><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240510114429132.png"  alt="image-20240510114429132"></li>
</ol>
<h1 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var let const"></a>var let const</h1><p>var 和 func都会存在变量提升</p>
<p>在全局声明var a b  在函数内部写成 var a &#x3D; b &#x3D; 3  a就成了局部变量了？！ 不写var 全局</p>
<h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><p><a class="link"   href="https://juejin.cn/post/7007224479218663455?searchId=20240316163826AD692671C0071193C544" >https://juejin.cn/post/7007224479218663455?searchId=20240316163826AD692671C0071193C544<i class="fas fa-external-link-alt"></i></a></p>
<p>1.在全局作用域中</p>
<ul>
<li><p>var 和 func 会在同一级都有变量提升 并且函数优先级比变量高</p>
</li>
<li><p>除了变量提升，函数实际上也是存在提升的。JavaScript中具名的函数的声明形式有两种：</p>
</li>
</ul>
<p>当使用<strong>变量形式声明</strong>函数时，和普通的变量一样会存在提升的现象，而函数声明式会提升到作用域最前边，并且将声明内容一起提升到最上边</p>
<p>2.在函数作用域中</p>
<p>函数作用域中也存在变量提升</p>
<h1 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h1><p>在这运行流程进入作用域创建变量，到变量可以被访问之间的这段时间，就称之为暂时死区。</p>
<h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><p>静态方法: then catch finally all allsettled race any</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise封装Ajax请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">method, url, data</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(xhr.<span class="property">statusText</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line">        xhr.<span class="title function_">send</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="指定回调与改变状态先后顺序问题"><a href="#指定回调与改变状态先后顺序问题" class="headerlink" title="指定回调与改变状态先后顺序问题"></a>指定回调与改变状态先后顺序问题</h2><p>正常情况下是先指定回调再改变状态，但也可以先改变状态在指定回调</p>
<p>Promise本身是同步的立即执行函数，当在executor中执行resolve或者reject的时候,此时是异步操作，会先执行then&#x2F;catch等，当主栈完成后，才会去调用resolve&#x2F;reiect中存放的方法执行<br>await 表达式的运算结果取决于它等的是什么。<br>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西<br>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阳塞后面的代码，等着 Promise 对象 resolve然后得到 resolve 的值，作为 await 表达式的运算结果</p>
<h1 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h1><p>1.工厂</p>
<p>2.构造函数</p>
<p>3.原型</p>
<p>4.组合使用2，3</p>
<p>5.动态原型</p>
<p>6.寄生构造函数</p>
<h1 id="js中filter-map-foreach的区别"><a href="#js中filter-map-foreach的区别" class="headerlink" title="js中filter map foreach的区别"></a>js中filter map foreach的区别</h1><p><strong>forEach</strong>方法：遍历数组的每一个元素，默认没有返回值。 </p>
<p><strong>filter</strong>方法：对数组元素进行条件筛选。 返回一个数组，将原数组符合条件的元素放入数组<strong>中</strong>。 (<strong>filter</strong>方法不改变原数组) </p>
<p><strong>map</strong>方法：返回一个数组，这个新数组的每一个元素都是原数组元素执行了回调函数之后的返回值。</p>
<h1 id="为什么0-1-0-2-0-3在js中"><a href="#为什么0-1-0-2-0-3在js中" class="headerlink" title="为什么0.1+0.2!&#x3D;&#x3D;0.3在js中"></a>为什么0.1+0.2!&#x3D;&#x3D;0.3在js中</h1><p>由于浮点数的精度问题</p>
<p>在js中 浮点数是以二进制表示的 但是十进制无法精确转为二进制</p>
<p>0.1 和 0.2 在二进制中是无限循环的小数</p>
<p>使用toFixed方法</p>
<h1 id="如何理解-JS的异步"><a href="#如何理解-JS的异步" class="headerlink" title="如何理解 JS的异步?"></a>如何理解 JS的异步?</h1><p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个而渲染主线程承担着诸多的工作，渲染页面、执行 JS都在其中运行。如果使用<strong>同步</strong>的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。<br>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如<strong>计时器、网络、事件监听</strong>，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，<strong>将事先传递的回调函数包装成任务</strong>，加入到消息队列的末尾排队，等待主线程调度执行。在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240124205355652.png"  alt="image-20240124205355652"></p>
<h1 id="js阻碍渲染"><a href="#js阻碍渲染" class="headerlink" title="js阻碍渲染"></a>js阻碍渲染</h1><p>因为渲染主线程在执行某个js代码时用时过长 导致渲染任务一直在队列 无法执行     react fiber机制</p>
<h1 id="js事件循环机制"><a href="#js事件循环机制" class="headerlink" title="js事件循环机制"></a>js事件循环机制</h1><p>事件循环又叫做消息循环，是浏览器染主线程的工作方式。在 Chrome 的源码中，它<strong>开启一个不会结束的 for 循环</strong>，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。<br>根据 W3C官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p>
<h1 id="JS-中的计时器能做到精确计时吗-为什么"><a href="#JS-中的计时器能做到精确计时吗-为什么" class="headerlink" title="JS 中的计时器能做到精确计时吗? 为什么?"></a>JS 中的计时器能做到精确计时吗? 为什么?</h1><p>1.受事件循环机制，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</p>
<p>2.定时器的最小延迟时间4ms</p>
<h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><p>递归  flat()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">      result = result.<span class="title function_">concat</span>(<span class="title function_">flattenArray</span>(item));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> flattenedArray = <span class="title function_">flattenArray</span>(nestedArray);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flattenedArray);  <span class="comment">// 输出：[1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h1 id="实现发布订阅"><a href="#实现发布订阅" class="headerlink" title="实现发布订阅"></a>实现发布订阅</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="params">eventName, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName].<span class="title function_">push</span>(callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">publish</span>(<span class="params">eventName, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName].<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="params">eventName, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName] = <span class="variable language_">this</span>.<span class="property">subscribers</span>[eventName].<span class="title function_">filter</span>(<span class="function"><span class="params">cb</span> =&gt;</span> cb !== callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback1</span> = data =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Callback 1 received data: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback2</span> = data =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Callback 2 received data: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">subscribe</span>(<span class="string">&quot;event1&quot;</span>, callback1);</span><br><span class="line">eventBus.<span class="title function_">subscribe</span>(<span class="string">&quot;event1&quot;</span>, callback2);</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">publish</span>(<span class="string">&quot;event1&quot;</span>, <span class="string">&quot;Hello, subscribers!&quot;</span>);</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">unsubscribe</span>(<span class="string">&quot;event1&quot;</span>, callback1);</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">publish</span>(<span class="string">&quot;event1&quot;</span>, <span class="string">&quot;After unsubscribing callback1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="OPTIONS请求方法的主要用途有两个"><a href="#OPTIONS请求方法的主要用途有两个" class="headerlink" title="OPTIONS请求方法的主要用途有两个:"></a>OPTIONS请求方法的主要用途有两个:</h1><ol>
<li>获取服务器支持的所有HTTP请求方法，</li>
<li>用来检查访问权限。例如: 在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送<strong>嗅探请求</strong>，以判断是否有对指定资源的访问权限</li>
</ol>
<h1 id="babel的安装和使用"><a href="#babel的安装和使用" class="headerlink" title="babel的安装和使用"></a>babel的安装和使用</h1><h2 id="babel的安装"><a href="#babel的安装" class="headerlink" title="babel的安装"></a>babel的安装</h2><p>babel可以和构建工具联合使用，也可以独立使用</p>
<p>如果要独立的使用babel，需要安装下面两个库：</p>
<ul>
<li>@babel&#x2F;core：babel核心库，提供了编译所需的所有api</li>
<li>@babel&#x2F;cli：提供一个命令行工具，调用核心库的api完成编译</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D @babel/core @babel/cli</span><br></pre></td></tr></table></figure>

<h2 id="babel的使用"><a href="#babel的使用" class="headerlink" title="babel的使用"></a>babel的使用</h2><p>@babel&#x2F;cli的使用极其简单</p>
<p>它提供了一个命令<code>babel</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按文件编译</span></span><br><span class="line">babel 要编译的文件 -o 编辑结果文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按目录编译</span></span><br><span class="line">babel 要编译的整个目录 -d 编译结果放置的目录</span><br></pre></td></tr></table></figure>

<h2 id="babel的配置"><a href="#babel的配置" class="headerlink" title="babel的配置"></a>babel的配置</h2><p>可以看到，babel本身没有做任何事情，真正的编译要依托于<strong>babel插件</strong>和<strong>babel预设</strong>来完成</p>
<blockquote>
<p>babel预设和postcss预设含义一样，是多个插件的集合体，用于解决一系列常见的兼容问题</p>
</blockquote>
<p>如何告诉babel要使用哪些插件或预设呢？需要通过一个配置文件<code>.babelrc</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h1><p>它是一个工具，<strong>预先配置好各种规则</strong>，通过这些规则来自动化的验证代码，甚至自动修复</p>
<ul>
<li><p>如何让所有员工书写高质量的代码？</p>
<p>比如使用<code>===</code>替代<code>==</code></p>
</li>
<li><p>如何让所有员工书写的代码风格保持统一？</p>
<p>比如字符串统一使用单引号</p>
</li>
</ul>
<p>上面两个问题，一个代表着代码的质量，一个代表着代码的风格</p>
<ul>
<li>eslint-config-airbnb</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h4 id="类型检测-快速区分"><a href="#类型检测-快速区分" class="headerlink" title="类型检测 &amp; 快速区分"></a>类型检测 &amp; 快速区分</h4><ol>
<li>JS有几种基础数据类型?几种新增?*<br>JS 8种基础数据类型:  <strong>undefined null boolean number string object   l    symbol bigInt</strong><br>Symbol 独一无二 且 不可变 &#x3D;&gt;全局变量冲突、内部变量覆盖<br>bigInt 任意精度正数 安全地存储和操作大数据，即便超出了number的安全整数范围</li>
</ol>
<h1 id="事件捕获和事件冒泡机制"><a href="#事件捕获和事件冒泡机制" class="headerlink" title="事件捕获和事件冒泡机制"></a>事件捕获和事件冒泡机制</h1><p>事件捕获和事件冒泡是指在页面中触发某个元素上的事件时，事件传播的两种不同方式。</p>
<p>在事件捕获阶段，事件从最外层的元素开始向内部元素传播，直到达到触发事件的最具体的元素。</p>
<p>而在事件冒泡阶段，事件则从触发事件的元素开始向外传播，直到达到最外层的元素</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是指一个函数可以访问其外部函数的作用域中的变量，即使该外部函数已经执行完毕，这些变量仍然保存在内存中，不会被销毁。闭包可以用来模拟私有方法，提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p>
<p>闭包的好处是可以使外部函数的局部变量在函数执行完毕后仍然存在于内存中，可以被内部函数访问和修改，从而实现一些特殊的功能。闭包的坏处是因为闭包的调用最终是赋给了一个全局变量，所以导致它会一直存在于内存中，不会被 JavaScript 的垃圾回收机制回收，从而会影响计算机的性能，更严重点可能会导致内存泄露。闭包的适用场景包括防抖、节流等<a class="link"   href="https://juejin.cn/post/7040647854448197662" >1<i class="fas fa-external-link-alt"></i></a><a class="link"   href="https://blog.csdn.net/lizhengxv/article/details/105936925" >3<i class="fas fa-external-link-alt"></i></a><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" >4<i class="fas fa-external-link-alt"></i></a>。闭包的实现方式有多种，包括返回值、函数赋值、函数参数、IIFE、循环赋值、getter 和 setter、迭代器、区分是否首次的场景、缓存等<a class="link"   href="https://blog.csdn.net/lizhengxv/article/details/105936925" >3<i class="fas fa-external-link-alt"></i></a>。</p>
<h1 id="map-foreach"><a href="#map-foreach" class="headerlink" title="map&amp;foreach"></a>map&amp;foreach</h1><p>数组的map和forEach迭代有什么区别？哪个遍历更快？为什么更快？这两种迭代能不能中断</p>
<p><code>map</code> 和 <code>forEach</code> 是 JavaScript 中用于迭代数组的两种方法。它们之间有以下区别：</p>
<ol>
<li>返回值：<code>map</code> 方法返回一个新数组，该数组包含对原始数组中的每个元素应用回调函数后的结果。而 <code>forEach</code> 方法没有返回值，它只是对数组中的每个元素执行指定的回调函数，用于遍历数组并进行操作。</li>
<li>可变性：<code>map</code> 不会改变原始数组，并且会返回一个新的数组，而 <code>forEach</code> 会改变原始数组，返回值为 <code>undefined</code>。</li>
<li>速度：关于性能速度，它们有所不同，但具体取决于各种因素，例如计算机、处理的数据量等。一些测试显示 <code>map</code> 更快，而另一些测试显示 <code>forEach</code> 更快。在现代 Web 开发中，不必过分纠结这一点速度，因为它们都比传统的 <code>for</code> 循环慢。</li>
<li>中断：<code>forEach</code> 不能中断或跳出循环，而 <code>map</code> 可以通过 <code>return</code> 来提前结束循环。</li>
</ol>
<p>综上所述，<code>map</code> 和 <code>forEach</code> 各有各的优势，主要取决于你想要做什么。如果你想基于一个原数组返回一个新数组，可以选择 <code>map</code>；如果你只是想遍历数据而不需要考虑返回，可以选择 <code>forEach</code>。</p>
<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><p>浅拷贝：1.直接赋值  2.const copied &#x3D; { …original }  3.Object.assign() -&gt; const copied &#x3D; Object.assign({}, original);</p>
<p>​				4.slice  5.concat  6.jQuery中的 $.extend </p>
<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240117193528704.png"  alt="image-20240117193528704"></p>
<p>深拷贝：1.JSON.parse(JSON.stringify(obj))  缺陷：会丢失原对象的方法 </p>
<p>​				2.jQuery中的$.extend</p>
<p>​				3.递归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Json-stringfy有什么弊端"><a href="#Json-stringfy有什么弊端" class="headerlink" title="Json.stringfy有什么弊端"></a>Json.stringfy有什么弊端</h3><ul>
<li>无法处理循环引用</li>
<li>不支持特定的数据类型</li>
<li>丢失对象的原型链和方法</li>
<li>性能问题：在处理大量对象或者深层嵌套对象的时候，可能会消耗大量的时间和内存</li>
</ul>
<h1 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h1><ol>
<li><p>Let和Const关键字；</p>
</li>
<li><p>解构表达式</p>
<ul>
<li>数组解构</li>
<li>对象解构</li>
</ul>
</li>
<li><p>字符串扩展</p>
<ul>
<li><p>新的API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">includes</span>()：返回布尔值，表示是否找到了参数字符串。</span><br><span class="line"><span class="title function_">startsWith</span>()：返回布尔值，表示参数字符串是否在原字符串的头部。</span><br><span class="line"><span class="title function_">endsWith</span>()：返回布尔值，表示参数字符串是否在原字符串的尾部。</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串模板</p>
</li>
</ul>
</li>
<li><p>函数优化</p>
<ul>
<li><p>函数参数默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//现在可以这么写：直接给参数写上默认值，没传就会自动使用默认值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add2</span>(<span class="params">a , b = <span class="number">1</span></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传一个参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add2</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>不定参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">...values</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(values.<span class="property">length</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">//2</span></span><br><span class="line"><span class="title function_">fun</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数</p>
</li>
</ul>
</li>
<li><p>对象优化</p>
<ul>
<li><p>新增API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ES6</span> 给 <span class="title class_">Object</span> 拓展了许多新的方法，如：</span><br><span class="line">- <span class="title function_">keys</span>(obj)：获取对象的所有 key 形成的数组</span><br><span class="line">- <span class="title function_">values</span>(obj)：获取对象的所有 value 形成的数组</span><br><span class="line">- <span class="title function_">entries</span>(obj)：获取对象的所有 key 和 value 形成的二维数组。格式：<span class="string">`[[k1,v1],[k2,v2],...]`</span> - <span class="title function_">assign</span>(dest, ...src) ：将多个 src 对象的值 拷贝到 dest 中。（第一层为深拷贝，第二层为浅</span><br><span class="line">拷贝）</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line"><span class="attr">language</span>: [<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;css&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(person));<span class="comment">//[&quot;name&quot;, &quot;age&quot;, &quot;language&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(person));<span class="comment">//[&quot;jack&quot;, 21, Array(3)]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(person));<span class="comment">//[Array(2), Array(2), Arra</span></span><br><span class="line"><span class="title function_">y</span>(<span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="comment">//Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target)<span class="comment">//&#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明对象简写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">23</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="comment">// 传统</span></span><br><span class="line"><span class="keyword">const</span> person1 = &#123; <span class="attr">age</span>: age, <span class="attr">name</span>: name &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1)</span><br><span class="line"><span class="comment">// ES6：属性名和属性值变量名一样，可以省略</span></span><br><span class="line"><span class="keyword">const</span> person2 = &#123; age, name &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2) <span class="comment">//&#123;age: 23, name: &quot;张三&quot;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的函数属性简写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line"><span class="comment">// 以前：</span></span><br><span class="line"><span class="attr">eat</span>: <span class="keyword">function</span> (<span class="params">food</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;在吃&quot;</span> + food);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 箭头函数版：这里拿不到 this</span></span><br><span class="line"><span class="attr">eat2</span>: <span class="function"><span class="params">food</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span> + <span class="string">&quot;在吃&quot;</span> + food),</span><br><span class="line"><span class="comment">// 简写版：</span></span><br><span class="line"><span class="title function_">eat3</span>(<span class="params">food</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;在吃&quot;</span> + food);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">eat</span>(<span class="string">&quot;apple&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象拓展运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">拓展运算符（...）用于取出参数对象所有可遍历属性然后拷贝到当前对象。</span><br><span class="line"><span class="comment">// 1、拷贝对象（深拷贝）</span></span><br><span class="line"><span class="keyword">let</span> person1 = &#123; <span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>, <span class="attr">age</span>: <span class="number">15</span> &#125;</span><br><span class="line"><span class="keyword">let</span> someone = &#123; ...person1 &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(someone) <span class="comment">//&#123;name: &quot;Amy&quot;, age: 15&#125;</span></span><br><span class="line"><span class="comment">// 2、合并对象</span></span><br><span class="line"><span class="keyword">let</span> age = &#123; <span class="attr">age</span>: <span class="number">15</span> &#125;</span><br><span class="line"><span class="keyword">let</span> name = &#123; <span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> person2 = &#123; ...age, ...name &#125; <span class="comment">//如果两个对象的字段名重复，后面对象字段值会覆盖前面对象的字段值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2) <span class="comment">//&#123;age: 15, name: &quot;Amy&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>map&amp;reduce</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">map</span>()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;-5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">arr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">s</span> =&gt;</span> <span class="built_in">parseInt</span>(s));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">reduce</span>(callback,[initialValue])</span><br><span class="line">reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元</span><br><span class="line">素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调</span><br><span class="line">用 reduce 的数组。</span><br><span class="line">callback （执行数组中每个值的函数，包含四个参数）</span><br><span class="line"><span class="number">1</span>、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））</span><br><span class="line"><span class="number">2</span>、currentValue （数组中当前被处理的元素）</span><br><span class="line"><span class="number">3</span>、index （当前元素在数组中的索引）</span><br><span class="line"><span class="number">4</span>、array （调用 reduce 的数组）</span><br><span class="line">initialValue （作为第一次调用 callback 的第一个参数。）</span><br><span class="line">示例：</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">20</span>,-<span class="number">5</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//没有初始值：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b));<span class="comment">//19</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a*b));<span class="comment">//-300</span></span><br><span class="line"><span class="comment">//指定初始值：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b,<span class="number">1</span>));<span class="comment">//20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a*b,<span class="number">0</span>));<span class="comment">//-0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise</p>
<p>Promise是JavaScript中的一个对象，它代表了一个异步操作的最终完成或者失败<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" >4<i class="fas fa-external-link-alt"></i></a>。Promise可以用于解决回调地狱的问题，通过Promise对象可以将异步操作以链式调用的方式组织起来，使得代码更加可读性更高<a class="link"   href="https://juejin.cn/post/7063628439864999944" >2<i class="fas fa-external-link-alt"></i></a>。Promise对象有三种状态：pending（等待中）、fulfilled（已成功）和rejected（已失败）<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" >4<i class="fas fa-external-link-alt"></i></a>。当Promise对象的状态从pending变为fulfilled或rejected时，会触发then()方法中对应的回调函数</p>
<ul>
<li><a class="link"   href="https://juejin.cn/post/7063628439864999944" >https://juejin.cn/post/7063628439864999944<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
<li><p>模块化</p>
</li>
</ol>
<p>​		import export</p>
<p>​	9.ES6新特性：</p>
<ol>
<li><strong>let 和 const</strong>: 提供块级作用域绑定，<code>let</code>用于声明变量，<code>const</code>用于声明常量。</li>
<li><strong>箭头函数</strong> (<code>=&gt;</code>): 提供了一种更简洁的函数编写方式，并且解决了<code>this</code>关键字的一些常见问题。</li>
<li><strong>模板字符串</strong>: 使用反引号（&#96;&#96;&#96;）标示，它可以定义多行字符串和嵌入变量。</li>
<li><strong>默认参数值</strong>: 在函数中直接给参数赋予默认值。</li>
<li><strong>解构赋值</strong>: 对象和数组解构让批量赋值更简单。</li>
<li><strong>扩展运算符</strong> (<code>...</code>): 允许数组和对象字面量在无需循环的情况下扩展或合并。</li>
<li><strong>类</strong> (<code>class</code>): 引入了面向对象编程中类的概念，更容易实现对象的继承和复用。</li>
<li><strong>模块化</strong> (<code>import</code> &#x2F; <code>export</code>): 原生的模块化支持，可以导出和导入函数、变量等。</li>
<li><strong>Promises</strong>: 为JavaScript提供了原生的异步编程解决方案。</li>
<li><strong>迭代器</strong> (<code>Iterator</code>) 和 <strong>for…of</strong> 循环: 提供了遍历所有数据结构的统一方式。</li>
<li><strong>生成器</strong> (<code>function*</code>): 生成器函数可以通过<code>yield</code>关键字暂停执行，有助于处理异步操作和迭代器。</li>
<li><strong>集合</strong> (<code>Set</code>) 和 <strong>映射</strong> (<code>Map</code>): 新的数据结构用于存储唯一值的集合和键值对集合。</li>
<li><strong>新的内置方法</strong>: 如数组的<code>Array.from</code>、<code>Array.of</code>、<code>find</code>、<code>findIndex</code>等方法，对象的<code>Object.assign</code>等。</li>
<li><strong>Proxy 和 Reflect</strong>: 新的元编程特性，用于创建对象的代理以控制对象的行为，Reflect对象提供了一套用于操作对象的API。</li>
<li><strong>Symbols</strong>: 新的原始数据类型用于创建唯一的标识符。</li>
<li><strong>尾调用优化</strong>: 对尾递归函数进行优化，节省内存。</li>
</ol>
<h1 id="call-apply-bind区别"><a href="#call-apply-bind区别" class="headerlink" title="call apply bind区别"></a>call apply bind区别</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">call 和 apply 立即调用函数，而 bind 返回一个新的函数。</span><br><span class="line">call 和 apply 的参数列表不同，call 是逐个列举参数，而 apply 使用数组传递参数。</span><br><span class="line">bind 不会立即调用函数，而是返回一个新的函数，可以稍后调用</span><br></pre></td></tr></table></figure>

<h1 id="原型链的作用"><a href="#原型链的作用" class="headerlink" title="原型链的作用"></a>原型链的作用</h1><ol>
<li><strong>实现继承：</strong> 在JavaScript中，继承主要依赖于原型和原型链。子构造函数的实例可以继承父构造函数原型上的方法和属性。这意味着我们可以定义一个通用方法或属性在一个对象的原型上，让所有通过该构造函数创建的实例都可以访问它们，而不必在每个实例上重复定义。</li>
<li><strong>属性查找机制（属性解析）：</strong> 当访问对象上的一个属性或方法时，JavaScript首先会在对象自身上寻找这个属性。如果没有找到，它会沿着原型链向上查找，一直到<code>Object.prototype</code>，这是原型链的顶端。如果在原型链上仍然没有找到该属性，则返回<code>undefined</code>。</li>
<li><strong>共享方法：</strong> 利用原型链，多个实例可以共享原型对象上的方法，而不是在每个实例上都创建一个新的方法副本。这有助于减少内存的使用。</li>
<li><strong>创建动态方法：</strong> 如果你在程序运行时向一个构造函数的原型添加方法或属性，那么所有通过这个构造函数创建的实例——无论是在添加之前还是之后创建的——都将可以访问那个新增的方法或属性</li>
</ol>
<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><ol>
<li>创建对象</li>
<li>设置函数原型prototype对象</li>
<li>执行构造函数 为这个新对象添加属性</li>
<li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</li>
</ol>
<h1 id="异步场景解决方案"><a href="#异步场景解决方案" class="headerlink" title="异步场景解决方案"></a>异步场景解决方案</h1><p>io流操作都是异步的 异步场景 </p>
<p>1.返回一个promise</p>
<p>2.提供回调事件</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack</title>
    <url>/2023/05/09/2023/webpack/</url>
    <content><![CDATA[<h1 id="webpack核心功能和性能优化"><a href="#webpack核心功能和性能优化" class="headerlink" title="webpack核心功能和性能优化"></a><a class="link"   href="https://webpack.docschina.org/guides" >webpack<i class="fas fa-external-link-alt"></i></a>核心功能和性能优化</h1><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p><img   src="/../images/webpack/1741094588163.png" ><br><img   src="/../images/webpack/1741094704691.png" ></p>
<h2 id="编译结果分析"><a href="#编译结果分析" class="headerlink" title="编译结果分析"></a>编译结果分析</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并两个模块</span></span><br><span class="line"><span class="comment">//  ./src/a.js</span></span><br><span class="line"><span class="comment">//  ./src/index.js</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">modules</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> moduleExports = &#123;&#125;; <span class="comment">//用于缓存模块的导出结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//require函数相当于是运行一个模块，得到模块导出结果</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">__webpack_require</span>(<span class="params">moduleId</span>) &#123; <span class="comment">//moduleId就是模块的路径</span></span><br><span class="line">        <span class="keyword">if</span> (moduleExports[moduleId]) &#123;</span><br><span class="line">            <span class="comment">//检查是否有缓存</span></span><br><span class="line">            <span class="keyword">return</span> moduleExports[moduleId];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> func = modules[moduleId]; <span class="comment">//得到该模块对应的函数</span></span><br><span class="line">        <span class="keyword">var</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">            <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">func</span>(<span class="variable language_">module</span>, <span class="variable language_">module</span>.<span class="property">exports</span>, __webpack_require); <span class="comment">//运行模块</span></span><br><span class="line">        <span class="keyword">var</span> result = <span class="variable language_">module</span>.<span class="property">exports</span>; <span class="comment">//得到模块导出的结果</span></span><br><span class="line">        moduleExports[moduleId] = result; <span class="comment">//缓存起来</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行入口模块</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">__webpack_require</span>(<span class="string">&quot;./src/index.js&quot;</span>); <span class="comment">//require函数相当于是运行一个模块，得到模块导出结果</span></span><br><span class="line">&#125;)(&#123; <span class="comment">//该对象保存了所有的模块，以及模块对应的代码</span></span><br><span class="line">    <span class="string">&quot;./src/a.js&quot;</span>: <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span>, <span class="built_in">exports</span></span>) &#123;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">&quot;console.log(\&quot;module a\&quot;)\nmodule.exports = \&quot;a\&quot;;\n //# sourceURL=webpack:///./src/a.js&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;./src/index.js&quot;</span>: <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span>, <span class="built_in">exports</span>, __webpack_require</span>) &#123;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">&quot;console.log(\&quot;index module\&quot;)\nvar a = __webpack_require(\&quot;./src/a.js\&quot;)\na.abc();\nconsole.log(a)\n //# sourceURL=webpack:///./src/index.js&quot;</span>)</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader本质上是一个函数，它的作用是将某个源码字符串转换成另一个源码字符串返回。</p>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>plugin的<strong>本质</strong>是一个带有apply方法的对象    监听事件 事件触发做指定的事情</p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>加快了应用的初始加载速度，减轻了它的总体体积</p>
<h1 id="webpack打包优化"><a href="#webpack打包优化" class="headerlink" title="webpack打包优化"></a>webpack打包优化</h1><ol>
<li>优化loader</li>
<li>happypack 并行打包</li>
<li>dllplugin 提前打包</li>
<li>scope hoisting 合并代码</li>
<li>tree shaking 删除代码</li>
</ol>
<h1 id="vite热更新怎么实现的"><a href="#vite热更新怎么实现的" class="headerlink" title="vite热更新怎么实现的"></a>vite热更新怎么实现的</h1><p>Vite是一个现代化的前端开发与打包工具，它通过利用原生ES模块的特性实现了极快的服务器启动和热模块替换（Hot Module Replacement, HMR）。Vite的HMR实现依赖于以下几个关键点：</p>
<ol>
<li><strong>原生ES模块导入</strong>：Vite使用原生ES模块（ESM）来加载模块，这意味着它不需要对代码进行预打包，各个模块都是按需加载的。这使得启动速度非常快。</li>
<li><strong>WebSocket连接</strong>：Vite在开发服务器和客户端之间建立WebSocket连接，用于实时通信。服务器监测文件的变化，并且通过WebSocket通知客户端进行更新。</li>
<li><strong>文件系统监听</strong>：Vite使用文件系统监听工具（例如<code>chokidar</code>）来监视工作目录下所有文件的变化。一旦检测到文件变化，Vite将重新加载被修改的模块和依赖该模块的链路。</li>
<li><strong>模块热替换</strong>：Vite会发送一个HMR更新到客户端，客户端收到更新后，会清除相关模块的缓存并重新请求该模块。因为使用了ESM，浏览器会重新获取更新的模块并执行代码。</li>
<li><strong>状态保持</strong>：对于支持HMR API的模块（即在其代码中处理了<code>module.hot</code>接口的模块），Vite不仅会重新加载代码，还会尝试保持应用状态，例如组件的状态。这个过程需要开发者的配合，通过编写HMR接口的处理代码来实现。</li>
<li><strong>插件支持</strong>：Vite允许通过插件来扩展HMR功能。开发者可以自行编写HMR兼容的代码，或者使用第三方插件，实现特定框架或库的HMR集成</li>
</ol>
<h1 id="vite-webpack区别"><a href="#vite-webpack区别" class="headerlink" title="vite webpack区别"></a>vite webpack区别</h1><p>Vite 和 Webpack 是现代前端开发中常用的两个构建工具，它们在设计理念、实现方式以及性能表现上存在一些区别：</p>
<ol>
<li><p><strong>构建速度</strong>：</p>
<ul>
<li>Vite 在开发环境下提供了极快的服务器启动和热更新速度，因为它利用了浏览器的原生 ES 模块导入（ESM）能力，不需要打包整个项目，而是按需编译[^34^][^37^]。</li>
<li>Webpack 在启动时需要分析项目所有依赖并打包，因此启动速度相对较慢，随着项目规模的增长，这个时间可能会显著增加[^36^][^37^]。</li>
</ul>
</li>
<li><p><strong>打包原理</strong>：</p>
<ul>
<li>Vite 在开发环境中不生成捆绑包，而是提供一个开发服务器，当请求模块时，动态地构建并服务于浏览器[^37^]。</li>
<li>Webpack 通过 loader 和 plugin 系统处理项目资源，将它们打包成一个或多个 bundle，适用于生产环境[^36^][^43^]。</li>
</ul>
</li>
<li><p><strong>生产环境</strong>：</p>
<ul>
<li>Vite 在生产环境中使用 Rollup 进行打包，因为 Rollup 生成的文件更小，且插件生态更为完善[^34^]。</li>
<li>Webpack 同样适用于生产环境，提供了丰富的优化选项，如代码分割、压缩等[^43^]。</li>
</ul>
</li>
<li><p><strong>生态系统和插件</strong>：</p>
<ul>
<li>Webpack 拥有一个庞大的生态系统，有大量的 loader 和 plugin 可用于扩展功能[^36^][^43^]。</li>
<li>Vite 作为一个较新的工具，其生态系统正在迅速增长，提供了一些内置功能，同时也支持第三方插件[^34^]。</li>
</ul>
</li>
<li><p><strong>配置复杂度</strong>：</p>
<ul>
<li>Webpack 的配置相对复杂，需要手动配置许多选项来满足项目需求[^36^][^43^]。</li>
<li>Vite 旨在降低配置的复杂度，提供了许多开箱即用的功能，使得项目配置更为简洁[^34^][^36^]。</li>
</ul>
</li>
<li><p><strong>性能优化</strong>：</p>
<ul>
<li>Vite 利用 ESbuild 进行预构建依赖，ESbuild 用 Go 语言编写，性能优于基于 Node.js 的 Webpack[^37^]。</li>
<li>Webpack 5 开始引入持久化缓存等优化措施，提高构建性能[^40^]。</li>
</ul>
</li>
<li><p><strong>热更新（HMR）</strong>：</p>
<ul>
<li>Vite 的热更新非常快速，因为它只更新变更的部分，不需要重新编译整个项目[^34^]。</li>
<li>Webpack 也支持热更新，但在大型项目中，热更新的性能可能不如 Vite[^36^]。</li>
</ul>
</li>
<li><p><strong>浏览器支持</strong>：</p>
<ul>
<li>Vite 需要现代浏览器支持 ESM，且不能识别 CommonJS 语法[^37^]。</li>
<li>Webpack 支持多种模块类型，包括 ESM 和 CommonJS，兼容性更广[^43^]。</li>
</ul>
</li>
</ol>
<p>综上所述，Vite 和 Webpack 各有优势，选择哪个工具取决于项目需求、团队熟悉度以及对开发体验和生产环境性能的考量。</p>
]]></content>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>正则学习记录</title>
    <url>/2023/11/09/2023/%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<p>()的作用</p>
<ol>
<li>分组</li>
<li>捕获组</li>
<li>非捕获组</li>
</ol>
<p>[]的作用</p>
<ol>
<li>字符类</li>
<li>范围</li>
<li>排除字符</li>
</ol>
<p><strong>?</strong> 问号代表前面的字符最多只可以出现一次（0次或1次）</p>
<p><strong>+</strong> 号代表前面的字符必须至少出现一次（1次或多次）</p>
<p>***** 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次)</p>
<p>[abc] </p>
<p>[^abc]</p>
<p>[a-z]</p>
<p><strong>.</strong> 匹配除换行符的所有字符</p>
<p><strong>\w</strong>  匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</p>
<p><strong>\d</strong>  匹配任意一个阿拉伯数字（0 到 9）等价于 <strong>[0-9]</strong></p>
<p>( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )</p>
<p>贪婪：.*</p>
<p>非贪婪：.*?</p>
<p>限定符</p>
<p>有 ***** 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p>
<p>定位符</p>
<p>^ :  匹配输入字符串开始的位置。</p>
<p>**$**： 匹配一行文本的结束处的文本</p>
<p>&#x2F;&#x2F;i 忽略大小写</p>
<p>&#x2F;&#x2F;g匹配全局 多次</p>
<p><code>replace()</code> 替换多次的唯一情况是传入带有 <code>g</code> 标志的正则表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;get-element-by-id&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/-([a-z])/g</span>, <span class="keyword">function</span> (<span class="params">match, letter</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(letter)</span><br><span class="line">        <span class="keyword">return</span> letter.<span class="title function_">toUpperCase</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240219110951011.png"  alt="image-20240219110951011"></p>
<p>split</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abc12de&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">splitAndCapitalize</span>(<span class="params">str</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> parts = str.<span class="title function_">split</span>(<span class="regexp">/(\d+)/</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(parts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">splitAndCapitalize</span>(str)</span><br></pre></td></tr></table></figure>

<p>match</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string  split   match 如果使用 g 标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组</span></span><br><span class="line"><span class="comment">// Array   join   splice替换   slice截取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;The quick brown\&#x27;s fox jumps over the lazy dog.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findLongestWord</span>(<span class="params">str</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> match = str.<span class="title function_">match</span>(<span class="regexp">/\w+[&#x27;-]?\w*!/g</span>);x</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; match.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(match[i].<span class="property">length</span> &gt; res.<span class="property">length</span>)&#123;</span><br><span class="line">            res = match[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// console.log(match)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="title function_">findLongestWord</span>(str)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br></pre></td></tr></table></figure>

<p>repeat函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String.prototype.getRepeat = function (count) &#123;</span></span><br><span class="line"><span class="comment">//     if (count &lt; 0) &#123;</span></span><br><span class="line"><span class="comment">//         throw new RangeError(&#x27;error&#x27;)</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return new Array(count + 1).join(this)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>babel</title>
    <url>/2025/01/03/2024/babel/</url>
    <content><![CDATA[<p>babel 学习记录</p>
<p>babel-plugin-transform-runtime插件的能力：为了方便使用 babel-runtime，解决手动 require 的苦恼 </p>
<p>@babel&#x2F;preset-env也是一个预设，包含很多插件</p>
<p>babel-runtime 是 @babel&#x2F;polyfill 的后者 是垫片，是各种插件集合，主要为了能转换新的 API 例如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象<br>babel-runtime 更像是一种按需加载的实现</p>
<p>工作原理：解析，转换，生成</p>
<p>babel中有很多插件，也有预设，包含一系列插件，即presets,还有 core 包，parser 包，traverse,generator</p>
<p>eslint 也依赖 babel</p>
<p>参考文章</p>
<p><a class="link"   href="https://cloud.tencent.com/developer/article/2100524" >https://cloud.tencent.com/developer/article/2100524<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://blog.csdn.net/weixin_44019380/article/details/132684899" >https://blog.csdn.net/weixin_44019380/article/details/132684899<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://juejin.cn/post/6844903956905197576" >https://juejin.cn/post/6844903956905197576<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2023/03/09/2023/promise/</url>
    <content><![CDATA[<h1 id="100行实现promise"><a href="#100行实现promise" class="headerlink" title="100行实现promise"></a>100行实现promise</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isFunction</span> = (<span class="params">obj</span>) =&gt; <span class="keyword">typeof</span> obj === <span class="string">&quot;function&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isObject</span> = (<span class="params">obj</span>) =&gt; !!(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isThenable</span> = (<span class="params">obj</span>) =&gt; (<span class="title function_">isFunction</span>(obj) || <span class="title function_">isObject</span>(obj)) &amp;&amp; <span class="string">&quot;then&quot;</span> <span class="keyword">in</span> obj;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isPromise</span> = (<span class="params">promise</span>) =&gt; promise <span class="keyword">instanceof</span> <span class="title class_">Promise</span>;</span><br><span class="line"><span class="keyword">const</span> nextTick = queueMicrotask || <span class="built_in">setTimeout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  result = <span class="literal">null</span>;</span><br><span class="line">  state = <span class="variable constant_">PENDING</span>;</span><br><span class="line">  callbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">onFulfilled</span> = (<span class="params">value</span>) =&gt; <span class="variable language_">this</span>.#<span class="title function_">transition</span>(<span class="variable constant_">FULFILLED</span>, value);</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">onRejected</span> = (<span class="params">reason</span>) =&gt; <span class="variable language_">this</span>.#<span class="title function_">transition</span>(<span class="variable constant_">REJECTED</span>, reason);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ignore = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (ignore) <span class="keyword">return</span>;</span><br><span class="line">      ignore = <span class="literal">true</span>;</span><br><span class="line">      <span class="variable language_">this</span>.#<span class="title function_">resolvePromise</span>(value, onFulfilled, onRejected);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (ignore) <span class="keyword">return</span>;</span><br><span class="line">      ignore = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">onRejected</span>(reason);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> callback = &#123; onFulfilled, onRejected, resolve, reject &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(callback);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="title function_">handleCallback</span>(callback, <span class="variable language_">this</span>.<span class="property">state</span>, <span class="variable language_">this</span>.<span class="property">result</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">transition</span>(<span class="params">state, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result;</span><br><span class="line">    <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="property">length</span>)</span><br><span class="line">        <span class="title function_">handleCallback</span>(<span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">shift</span>(), state, result);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">resolvePromise</span>(<span class="params">result, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result === <span class="variable language_">this</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Can not fulfill promise with itself&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isPromise</span>(result)) &#123;</span><br><span class="line">      <span class="keyword">return</span> result.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isThenable</span>(result)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> then = result.<span class="property">then</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isFunction</span>(then)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(then.<span class="title function_">bind</span>(result)).<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">resolve</span>(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleCallback</span> = (<span class="params">callback, state, result</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; onFulfilled, onRejected, resolve, reject &#125; = callback;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="title function_">isFunction</span>(onFulfilled) ? <span class="title function_">resolve</span>(<span class="title function_">onFulfilled</span>(result)) : <span class="title function_">resolve</span>(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="title function_">isFunction</span>(onRejected) ? <span class="title function_">resolve</span>(<span class="title function_">onRejected</span>(result)) : <span class="title function_">reject</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resolved</span> = (<span class="params">value</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(value));</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">rejected</span> = (<span class="params">reason</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">_, reject</span>) =&gt;</span> <span class="title function_">reject</span>(reason));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">deferred</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> promise, resolve, reject;</span><br><span class="line">  promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">$resolve, $reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve = $resolve;</span><br><span class="line">    reject = $reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123; promise, resolve, reject &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; resolved, rejected, deferred &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a class="link"   href="https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g" >https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://github.com/Lucifier129/promise-aplus-impl/blob/master/src/naive.js" >https://github.com/Lucifier129/promise-aplus-impl/blob/master/src/naive.js<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="用promise封装ajax请求"><a href="#用promise封装ajax请求" class="headerlink" title="用promise封装ajax请求"></a>用promise封装ajax请求</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url, method, data</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line">        xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="title class_">XMLHttpRequest</span>.<span class="property">DONE</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Request failed with status <span class="subst">$&#123;xhr.status&#125;</span>`</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Request failed&#x27;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>, &#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Success:&#x27;</span>, response);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>executor函数:  执行器  (resolve, reject) &#x3D;&gt; {}</p>
<p>resolve函数: 内部定义成功时我们调用的函数 value &#x3D;&gt; {}</p>
<p>reject函数: 内部定义失败时我们调用的函数 reason &#x3D;&gt; {}</p>
<p>executor会在Promise内部立即同步调用,异步操作在执行器中执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将主要的代码执行功能的直接放在这里</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//成功就调resolve</span></span><br><span class="line">    <span class="comment">//失败就调reject</span></span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">log</span>(value);</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">log</span>(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>静态方法: then catch finally all allsettled race any</p>
<h1 id="手撕"><a href="#手撕" class="headerlink" title="手撕"></a>手撕</h1><h2 id="Promise的基本概念"><a href="#Promise的基本概念" class="headerlink" title="Promise的基本概念"></a>Promise的基本概念</h2><p><img   src="/../images/promise/20210618161125.png"  alt="image-20210618161125894"></p>
<h2 id="链式调用规则"><a href="#链式调用规则" class="headerlink" title="链式调用规则"></a>链式调用规则</h2><p><img   src="/../images/propmise/20210621103501.png"  alt="image-20210621103501094"></p>
<p><img   src="/../images/propmise/20210621103501.png"  alt="image-20210621103501094"></p>
<ol>
<li><p>then方法必定会返回一个新的Promise</p>
<p>可理解为<code>后续处理也是一个任务</code></p>
</li>
<li><p>新任务的状态取决于后续处理：</p>
<ul>
<li><p>若没有相关的后续处理，新任务的状态和前任务一致，数据为前任务的数据</p>
</li>
<li><p>若有后续处理但还未执行，新任务挂起。</p>
</li>
<li><p>若后续处理执行了，则根据后续处理的情况确定新任务的状态</p>
<ul>
<li>后续处理执行无错，新任务的状态为完成，数据为后续处理的返回值</li>
<li>后续处理执行有错，新任务的状态为失败，数据为异常对象</li>
<li>后续执行后返回的是一个任务对象，新任务的状态和数据与该任务对象一致</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Promise的静态方法"><a href="#Promise的静态方法" class="headerlink" title="Promise的静态方法"></a>Promise的静态方法</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Promise.resolve(data)</td>
<td>直接返回一个完成状态的任务</td>
</tr>
<tr>
<td>Promise.reject(reason)</td>
<td>直接返回一个拒绝状态的任务</td>
</tr>
<tr>
<td>Promise.all(任务数组)</td>
<td>返回一个任务<br />任务数组全部成功则成功<br />任何一个失败则失败</td>
</tr>
<tr>
<td>Promise.any(任务数组)</td>
<td>返回一个任务<br />任务数组任一成功则成功<br />任务全部失败则失败</td>
</tr>
<tr>
<td>Promise.allSettled(任务数组)</td>
<td>返回一个任务<br />任务数组全部已决则成功<br />该任务不会失败</td>
</tr>
<tr>
<td>Promise.race(任务数组)</td>
<td>返回一个任务<br />任务数组任一已决则已决，状态和其一致</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><p>有了Promise，异步任务就有了一种统一的处理方式</p>
<p>有了统一的处理方式，ES官方就可以对其进一步优化</p>
<p>ES7推出了两个关键字<code>async</code>和<code>await</code>，用于更加优雅的表达Promise</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async关键字用于修饰函数，被它修饰的函数，一定返回Promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">method1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 该函数的返回值是Promise完成后的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">method1</span>(); <span class="comment">// Promise &#123; 1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">method2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>); <span class="comment">// 若返回的是Promise，则method得到的Promise状态和其一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">method2</span>(); <span class="comment">// Promise &#123; 1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">method3</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="number">1</span>); <span class="comment">// 若执行过程报错，则任务是rejected</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">method3</span>(); <span class="comment">// Promise &#123; &lt;rejected&gt; Error(1) &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p><code>await</code>关键字表示等待某个Promise完成，<strong>它必须用于<code>async</code>函数中</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">method</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的函数等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">method</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>await</code>也可以等待其他数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">method</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="number">1</span>; <span class="comment">// 等同于 await Promise.resolve(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要针对失败的任务进行处理，可以使用<code>try-catch</code>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">method</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">123</span>); <span class="comment">// 这句代码将抛出异常</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>, n)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">method</span>(); <span class="comment">// 输出： 失败 123</span></span><br></pre></td></tr></table></figure>

<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>根据目前所学，进入事件队列的函数有以下几种：</p>
<ul>
<li><code>setTimeout</code>的回调，宏任务（macro task）</li>
<li><code>setInterval</code>的回调，宏任务（macro task）</li>
<li>Promise的<code>then</code>函数回调，<strong>微任务</strong>（micro task）</li>
<li><code>requestAnimationFrame</code>的回调，宏任务（macro task）</li>
<li>事件处理函数，宏任务(macro task)</li>
</ul>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ol>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); </span><br><span class="line">    <span class="title function_">resolve</span>(); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">      <span class="title function_">resolve</span>(); </span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2) </span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1) </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2) </span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">m</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//2 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="title function_">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">m</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//3 1 2</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="title function_">m1</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m3</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="title function_">m2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">//返回得是上一步得promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">m3</span>().<span class="title function_">then</span>(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">m3</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关键看有没有await关键字 如果有await后面得代码不执行 没有就会运行后面得</span></span><br><span class="line"><span class="comment">//promise&#123;pending&#125;</span></span><br><span class="line"><span class="comment">//promise&#123;pending&#125;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240310202316466.png"  alt="image-20240310202316466"></p>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="number">2</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//then里面只能传函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise3&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise4&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title function_">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">await</span> b;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after1&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> a;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line"></span><br><span class="line">promise1</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">end</span><br><span class="line">promise2</span><br><span class="line">promise3</span><br><span class="line">promise4</span><br><span class="line"><span class="title class_">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line">after1</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();   <span class="comment">//await 后面得代码会执行 别忘了</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">p1</span>: fulfilled</span><br><span class="line"></span><br><span class="line">微队列: </span><br><span class="line">宏队列: set1</span><br><span class="line"></span><br><span class="line">ss</span><br><span class="line">ay1 st</span><br><span class="line">a2</span><br><span class="line">p1</span><br><span class="line">se</span><br><span class="line">ae</span><br><span class="line">p2</span><br><span class="line">set</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>deepClone</title>
    <url>/2024/11/09/2024/deepClone/</url>
    <content><![CDATA[<h3 id="深拷贝实现（避免循环引用版本）"><a href="#深拷贝实现（避免循环引用版本）" class="headerlink" title="深拷贝实现（避免循环引用版本）"></a>深拷贝实现（避免循环引用版本）</h3><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(target).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepclone</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target === <span class="literal">null</span> || <span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">has</span>(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.<span class="title function_">get</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> type = <span class="title function_">getType</span>(target);</span><br><span class="line">    <span class="keyword">let</span> cloneTarget;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Object&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Array&#x27;</span>:</span><br><span class="line">            cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Date&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(target);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;RegExp&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(target.<span class="property">source</span>, target.<span class="property">flags</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Set&#x27;</span>:</span><br><span class="line">            cloneTarget = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Map&#x27;</span>:</span><br><span class="line">            cloneTarget = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map.<span class="title function_">set</span>(target, cloneTarget);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;Map&#x27;</span>) &#123;</span><br><span class="line">        target.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">            cloneTarget.<span class="title function_">set</span>(</span><br><span class="line">                <span class="title function_">deepclone</span>(val, map),</span><br><span class="line">                <span class="title function_">deepclone</span>(key, map)</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> cloneTarget</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;Set&#x27;</span>) &#123;</span><br><span class="line">        target.<span class="title function_">forEach</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            cloneTarget.<span class="title function_">add</span>(<span class="title function_">deepclone</span>(val, map))</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> cloneTarget</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> allkeys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(target).<span class="title function_">concat</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(target))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> allkeys) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(k)) &#123;</span><br><span class="line">            cloneTarget[k] = <span class="title function_">deepclone</span>(target[k], map)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]],</span><br><span class="line">    <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">    <span class="attr">c</span>: &#123;</span><br><span class="line">        <span class="attr">d</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">f</span>: <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;g&#x27;</span>]),</span><br><span class="line">    <span class="attr">g</span>: <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>]])</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">deepclone</span>(obj));</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>手写题</tag>
      </tags>
  </entry>
  <entry>
    <title>engineer</title>
    <url>/2024/08/16/2024/engineer/</url>
    <content><![CDATA[<h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p><strong>结构描述</strong></p>
<p>标准字段<br>package.json中原有的</p>
<p>非标字段<br>types module exports</p>
<p>如果不设置 main 字段，那么入口文件就是根目录下的 index.js。<br>main：代码入口。</p>
<p>项目在进行 npm 发布时，可以通过 files 指定需要跟随一起发布的内容来控制 npm 包的大小<br>files：数组。表示代码包下载安装完成时包括的所有文件</p>
<p>dependencies: 不要把测试工具、代码转换器或者打包工具等放在这里</p>
<p>peerDependencies: 指定当前组件的依赖以其版本。如果组件使用者在项目中安装了其他版本的同一依赖，会提示报错</p>
<p>private：如果设为true，无法通过npm publish发布代码</p>
<p>module: 项目也可以指定 ES 模块的入口文件，这就是 module 字段的作用。</p>
<p>exports: 是module更加细化的操作 exports 字段可以配置不同环境对应的模块入口文件，并且当它存在时，它的优先级最高</p>
<h1 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h1><p><strong>files属性的作用</strong>：<br>包含特定文件：当你想要确保某些文件被包含在编译过程中，即使它们没有被其他 TypeScript 文件引用。<br>包含文件夹：指定一个文件夹，让 TypeScript 编译器处理该文件夹下的所有 .ts 文件。<br>排除文件和文件夹：虽然 tsconfig.json 提供了 exclude 选项来排除文件和文件夹，但使用 files 选项可以更明确地指定哪些文件和文件夹是包含的，其余的将被排除。<br>控制编译顺序：在某些情况下，你可能需要控制编译的顺序，通过在 files 中指定文件，可以确保它们按照特定的顺序被编译。<br>避免自动包含：TypeScript 编译器会自动包含所有在 include 选项中指定的 .ts 文件，使用 files 选项可以覆盖这一行为，只包含你明确列出的文件。</p>
<h1 id="node的模块查找策略"><a href="#node的模块查找策略" class="headerlink" title="node的模块查找策略"></a>node的模块查找策略</h1><p>文件查找<br>以相对或绝对路径进行 require,没有后缀的时候支持自动匹配 js,json</p>
<p>文件夹查找<br>如果没有找到文件，先找到项目中的 package.json 文件中的 main 字段文件，如果没有package.json文件或者main字段（指向一个不存在的文件），会找默认的 index 文件</p>
<p>内置模块<br>直接以名称导入</p>
<p>第三方<br>直接以名称导入，但是没找到内置，就会进入第三方模块查找node_modules,没找到的话会重复 1,2 步骤</p>
]]></content>
      <tags>
        <tag>engineer</tag>
      </tags>
  </entry>
  <entry>
    <title>网络知识学习</title>
    <url>/2024/07/09/2024/http/</url>
    <content><![CDATA[<h1 id="http-版本区别-（阻塞-连接快慢）"><a href="#http-版本区别-（阻塞-连接快慢）" class="headerlink" title="http 版本区别 （阻塞 连接快慢）"></a>http 版本区别 （阻塞 连接快慢）</h1><p>1.1比较 1.0：</p>
<ol>
<li><p>长连接</p>
</li>
<li><p>缓存处理</p>
<ol>
<li><p>协商缓存</p>
<ol>
<li><p>Last_modified    if-modified-since</p>
</li>
<li><p>etag  if-none-match</p>
</li>
<li><p>强缓存</p>
</li>
<li><p>expires</p>
</li>
<li><p>Cache-control  max-age</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>2.0 比较 1.1</p>
<ol>
<li><p>头部压缩</p>
<ol>
<li>Hpack 算法<ol>
<li>静态字典；</li>
<li>动态字典；</li>
<li>Huffman 编码（压缩算法）</li>
</ol>
</li>
</ol>
</li>
<li><p>二进制帧</p>
</li>
<li><p>多路复用</p>
</li>
<li><p>服务端主动推送</p>
</li>
</ol>
<p>3.0 比较 2.0</p>
<ol>
<li>基于udp，给每个 stream 加一个滑动窗口的 quic 协议</li>
</ol>
<p>怎么保证数据包内容一致</p>
<ol>
<li>引入 frame header 这一层 <strong>通过 Stream ID + Offset 字段信息实现数据的有序性</strong></li>
<li>QUIC使用的Packet Number单调递增的设计，可以让数据包不再像TCP那样必须有序确认，QUIC支持乱序确认，当数据包Packet N丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动</li>
</ol>
<h1 id="tcp协议是如何实现稳定传输的"><a href="#tcp协议是如何实现稳定传输的" class="headerlink" title="tcp协议是如何实现稳定传输的"></a>tcp协议是如何实现稳定传输的</h1><p>1.确认和重传机制  要接受方的确认消息、</p>
<p>2.序号和确认号  排序确认、</p>
<p>3.流量控制、 TCP 使用流量控制机制来避免发送方发送过多的数据，导致接收方缓冲区溢出</p>
<p>4.拥塞机制   拥塞控制算法包括慢启动、拥塞避免和快速重传等</p>
<ol>
<li><strong>可靠性的确认和重传机制</strong>：<ul>
<li>TCP 使用确认和重传机制来确保数据的可靠传输。发送方在发送数据后会等待接收方发送的确认消息，如果在一定时间内没有收到确认消息，发送方会重新发送数据。</li>
<li>接收方在收到数据后会发送确认消息给发送方，以告知发送方数据已经接收。如果接收方检测到数据包丢失，它会要求发送方重传丢失的数据。</li>
</ul>
</li>
<li><strong>序号和确认号</strong>：<ul>
<li>TCP 使用序号和确认号来对数据包进行排序和确认。每个 TCP 报文段都有一个序号字段和一个确认号字段，用来标识数据包的顺序和确认已收到的数据。</li>
<li>接收方会使用确认号来告知发送方已成功接收到哪些数据，发送方根据确认号来决定是否重传丢失的数据。</li>
</ul>
</li>
<li><strong>流量控制</strong>：<ul>
<li>TCP 使用流量控制机制来避免发送方发送过多的数据，导致接收方缓冲区溢出。接收方可以通过窗口字段来告知发送方自己的可接受窗口大小，发送方根据接收方的窗口大小来调整发送的数据量。</li>
</ul>
</li>
<li><strong>拥塞控制</strong>：<ul>
<li>TCP 使用拥塞控制机制来避免网络拥塞。发送方根据网络拥塞的情况来调整发送速率，以避免发送过多的数据导致网络拥塞。常见的拥塞控制算法包括慢启动、拥塞避免和快速重传等。</li>
</ul>
</li>
<li><strong>超时重传机制</strong>：<ul>
<li>TCP 使用超时重传机制来处理丢失的数据包。如果发送方在一定时间内没有收到确认消息，它会假设数据包丢失，并触发重传机制重新发送数据。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh主题p10k快速安装</title>
    <url>/2024/03/09/2024/p10k/</url>
    <content><![CDATA[<p>zsh主题p10k快速安装命令集合</p>
<span id="more"></span>

<h1 id="install"><a href="#install" class="headerlink" title="install"></a>install</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zsh</span></span><br><span class="line">sudo apt install zsh</span><br><span class="line">chsh -s $(which zsh)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ohmyzsh</span></span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">p10k</span></span><br><span class="line">git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k</span><br><span class="line">sed -i &#x27;s#robbyrussell#powerlevel10k/powerlevel10k#&#x27; ~/.zshrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">plugin</span></span><br><span class="line">sed -i &#x27;s/plugins=(git)/\</span><br><span class="line">plugins=( \</span><br><span class="line">  git \</span><br><span class="line">  command-not-found \</span><br><span class="line">  colored-man-pages \</span><br><span class="line">  vi-mode \</span><br><span class="line">  zsh-autosuggestions \</span><br><span class="line">  zsh-syntax-highlighting \</span><br><span class="line">)/&#x27; ~/.zshrc</span><br><span class="line"></span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">z.lua</span></span><br><span class="line">sudo apt install -y lua5.2</span><br><span class="line">git clone https://github.com/skywind3000/z.lua.git ~/.z.lua</span><br><span class="line">echo &#x27;eval &quot;$(lua ~/.z.lua/z.lua  --init zsh once enhanced)&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 zsh 并配置 p10k</span></span><br><span class="line">exec zsh</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>实用软件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>plimit</title>
    <url>/2024/06/09/2024/plimit/</url>
    <content><![CDATA[<h3 id="两种实现-plimit-的方式"><a href="#两种实现-plimit-的方式" class="headerlink" title="两种实现 plimit 的方式"></a>两种实现 plimit 的方式</h3><span id="more"></span>

<h1 id="第一种实现"><a href="#第一种实现" class="headerlink" title="第一种实现"></a>第一种实现</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">request1</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">request2</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">request3</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">        &#125;, <span class="number">300</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">request4</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">        &#125;, <span class="number">400</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addRequest = <span class="title function_">scheduler</span>(<span class="number">2</span>);</span><br><span class="line"><span class="title function_">addRequest</span>(request1).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">addRequest</span>(request2).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">addRequest</span>(request3).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">addRequest</span>(request4).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withResolvers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> promise, resolve, reject;</span><br><span class="line">    promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve = res;</span><br><span class="line">        reject = rej;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        promise,</span><br><span class="line">        resolve,</span><br><span class="line">        reject</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduler</span>(<span class="params">concurrent</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">process</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= concurrent) <span class="keyword">return</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">const</span> &#123;request, promise, resolve, reject&#125; = queue.<span class="title function_">shift</span>() || &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!request) <span class="keyword">return</span>;</span><br><span class="line">        <span class="title function_">request</span>().<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(val);</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="title function_">process</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">request</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;promise, resolve, reject&#125; = <span class="title function_">withResolvers</span>();</span><br><span class="line">        queue.<span class="title function_">push</span>(&#123;request, promise, resolve, reject&#125;);</span><br><span class="line">        <span class="title function_">process</span>();</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二种实现"><a href="#第二种实现" class="headerlink" title="第二种实现"></a>第二种实现</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (url % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">val</span>: url &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(&#123; <span class="attr">status</span>: <span class="number">2</span>, <span class="attr">val</span>: url &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">conCurrency</span>(<span class="params">urls, maxCon</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line">        <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">process</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt === urls.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> url = urls[index];</span><br><span class="line">            <span class="keyword">let</span> i = index;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fn</span>(url)</span><br><span class="line">                result[i] = res;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                result[i] = err;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (cnt === urls.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">process</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxCon; i++) &#123;</span><br><span class="line">            <span class="title function_">process</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> urls = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="title function_">conCurrency</span>(urls, <span class="number">3</span>).<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>手写题</tag>
      </tags>
  </entry>
  <entry>
    <title>scss的学习记录</title>
    <url>/2024/03/19/2024/scss/</url>
    <content><![CDATA[<p>@use : 用于将另一个文件导入进来 使用里面的东西 （模块）</p>
<p>@mixin — @include</p>
<p>% — @extend </p>
<p>@each $var in (primary, success) {}</p>
<p>@for $i from 1 through 9 {}</p>
<p>@if @else</p>
<p>@at-root 这对于在嵌套规则中编写样式时希望某些规则能够跳出嵌套作用域</p>
<p>@content</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@function</span><br><span class="line">@return</span><br><span class="line">#&#123;&#125;</span><br></pre></td></tr></table></figure>





<p>变量$  </p>
<p>嵌套</p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>storybook</title>
    <url>/2024/11/30/2024/storybook/</url>
    <content><![CDATA[<ol>
<li>最上层的文件描述改 *.mdx 文件</li>
<li>每个组件文档修改 *.stores.ts</li>
<li>改组件分类下的doc，组件文件导出组件上面的注释修改</li>
<li>preview.tsx修改 doc文档格式</li>
</ol>
<p>作用：用 storybook 可以轻松的创建组件文档，可以写多个 story，直观的看到组件不同参数时的展示和交互，还可以用来做测试</p>
]]></content>
      <tags>
        <tag>文档建设</tag>
        <tag>组件库</tag>
      </tags>
  </entry>
  <entry>
    <title>tailwindcss</title>
    <url>/2024/11/30/2024/tailwindcss/</url>
    <content><![CDATA[<ol>
<li>tailwind 自动补全插件</li>
</ol>
<p>  <a class="link"   href="https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss" >https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss<i class="fas fa-external-link-alt"></i></a></p>
<p>  Tailwind CSS IntelliSense</p>
<ol start="2">
<li><p>prettier 设置自动 tailwind属性自动排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pnpm install -D prettier-plugin-tailwindcss</span><br><span class="line"></span><br><span class="line">// .prettierrc文件</span><br><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [&quot;prettier-plugin-tailwindcss&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加tailwind.config.js文件</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D tailwindcss</span><br><span class="line">npx tailwindcss init</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>引入样式文件</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// index<span class="selector-class">.css</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@tailwind</span> base;</span><br><span class="line"><span class="keyword">@tailwind</span> components;</span><br><span class="line"><span class="keyword">@tailwind</span> utilities;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>css</tag>
        <tag>tailwind</tag>
      </tags>
  </entry>
  <entry>
    <title>url</title>
    <url>/2024/10/09/2024/url/</url>
    <content><![CDATA[<h3 id="从浏览器输入url发生了什么"><a href="#从浏览器输入url发生了什么" class="headerlink" title="从浏览器输入url发生了什么"></a>从浏览器输入url发生了什么</h3><span id="more"></span>

<p>（1）解析URL： 当⽤户在地址栏中输⼊⼀个查询关键字时，地址栏会判断输⼊的关键字是搜索内容，还是请求的 URL。如果是搜索内容，地址栏会使⽤浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。如果判断输⼊内容符合 URL 规则，⽐如输⼊的baidu.com，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 <a class="link"   href="http://baidu.com/" >http://baidu.com<i class="fas fa-external-link-alt"></i></a></p>
<p>（2）缓存判断： 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p>
<p>（3）DNS解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p>
<p>（4）TCP三次握手： 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</p>
<p>（5）HTTPS握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p>
<p>（6）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</p>
<p>（7）页面渲染： <a class="link"   href="https://jeff-jayden.github.io/2024/11/09/2024/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/" >详情请看页面渲染流程<i class="fas fa-external-link-alt"></i></a></p>
<p>（8）TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p>
]]></content>
      <tags>
        <tag>浏览器</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>tsconfig 配置分类</title>
    <url>/2024/11/11/2024/tsconfig/</url>
    <content><![CDATA[<h1 id="tsconfig-配置"><a href="#tsconfig-配置" class="headerlink" title="tsconfig 配置"></a>tsconfig 配置</h1><ol>
<li><p>构建相关</p>
<ul>
<li>构建源码相关<ul>
<li>特殊语法相关<ol>
<li>jsx、jsxFactory、jsxFragmentFactory 与 jsxImportSource</li>
<li>target 与 lib、noLib</li>
</ol>
</li>
</ul>
</li>
</ul>
<p> <strong>这部分配置主要控制源码解析，包括从何处开始收集要构建的文件，如何解析别名路径等等</strong></p>
<ul>
<li><p>构建解析相关</p>
<ol>
<li>files、include 与 exclude</li>
<li>baseUrl</li>
<li>rootDir</li>
<li>types 与 typeRoots</li>
<li>moduleResolution</li>
<li>paths</li>
<li>resolveJsonModule &#x2F;&#x2F;对 json 文件类型推导</li>
</ol>
</li>
<li><p>构建产物相关</p>
<ul>
<li><p>构建输出相关</p>
<ol>
<li>outDir 与 outFile</li>
<li>module</li>
<li>noEmit 与 noEmitOnError &#x2F;&#x2F; 主要控制最终是否将构建产物实际写入文件系统</li>
<li>module &#x2F;&#x2F; 控制最终 JavaScript 产物使用的模块标准</li>
</ol>
</li>
<li><p>声明文件相关</p>
<ol>
<li>declaration、declarationDir</li>
</ol>
</li>
<li><p>Source Map 相关</p>
<ol>
<li>sourceMap 与 inlineSourceMap</li>
</ol>
</li>
</ul>
</li>
<li><p>构建产物代码格式化配置</p>
<ol>
<li>removeComments &#x2F;&#x2F; 移除所有 TS 文件的注释，默认启用</li>
</ol>
</li>
</ul>
</li>
<li><p>类型检查相关</p>
<ul>
<li><p>允许类</p>
</li>
<li><p>禁止类</p>
<ul>
<li>类型检查<ol>
<li>noImplicitAny</li>
</ol>
</li>
</ul>
</li>
<li><p>严格检查</p>
<ol>
<li>strict &#x2F;&#x2F;是一组规则的开关，开启 strict 会默认将这些规则全部启用</li>
<li>skipLibCheck 与 skipDefaultLibCheck &#x2F;&#x2F; 跳过对类型声明文件的检查</li>
</ol>
</li>
</ul>
</li>
<li><p>工程相关</p>
<ol>
<li>references</li>
<li>composite</li>
</ol>
<ul>
<li><p>兼容性</p>
<ol>
<li>isolatedModules</li>
</ol>
<ul>
<li>JavaScript 相关<ol>
<li>allowJs</li>
<li>checkJs</li>
</ol>
</li>
<li>模块相关<ol>
<li>esModuleInterop 与 allowSyntheticDefaultImports &#x2F;&#x2F; 为了解决 ES Module 和 CommonJS 之间的兼容性问题</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>ts</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>vue学习记录</title>
    <url>/2024/01/23/2024/vue/</url>
    <content><![CDATA[<h1 id="vue的优势"><a href="#vue的优势" class="headerlink" title="vue的优势"></a>vue的优势</h1><ol>
<li>轻量级框架：Vue.js 是一个轻量级的框架，文件大小小，易于上手和学习</li>
<li>简单易学：Vue.js 的语法简单直观，易于理解和掌握</li>
<li>双向数据绑定：Vue.js 支持双向数据绑定，使得数据的变化能够自动反映在视图上，同时视图的变化也能自动更新到数据层</li>
<li>组件化：Vue.js 支持组件化开发，能够将页面拆分成多个独立的、可复用的组件，便于开发和维护</li>
<li>数据和结构的分离：Vue.js 支持将数据和结构分离，使得前端开发更加清晰和高效</li>
<li>虚拟DOM：Vue.js 使用虚拟DOM 技术，能够最大限度地减少对实际DOM的操作，提高性能</li>
</ol>
<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>Vuex是一个专为Vue.js应用程序开发的状态管理模式+库，用于集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. 它解决了多个组件共享状态时可能遇到的问题，如多个视图依赖于同一状态、来自不同视图的行为需要变更同一状态等 在大型项目中，Vuex能够高效实现组件之间的数据共享，提高开发效率，且存储在Vuex中的数据都是响应式的，能够实时保持数据与页面的同步 因此，Vuex的作用是实现组件全局状态（数据）管理的一种机制，方便实现组件之间数据的共享，解决了组件之间统一状态的共享问题，实现组件之间的数据持久化</p>
<h1 id="ssr"><a href="#ssr" class="headerlink" title="ssr"></a>ssr</h1><p>SSR（Server-Side Rendering）是一种前端渲染技术，它在服务器端生成页面的 HTML，并将其发送给客户端进行显示。相对于传统的客户端渲染（CSR，Client-Side Rendering），SSR 提供了一些优势和改进：</p>
<ol>
<li><strong>SEO（搜索引擎优化）：</strong> 由于搜索引擎爬虫更容易处理服务器端生成的 HTML，SSR 有助于提高页面的搜索引擎排名，而不是依赖于客户端执行 JavaScript。</li>
<li><strong>首屏加载性能：</strong> SSR 可以在页面加载时直接提供完整的 HTML，无需等待客户端渲染完成。这有助于减少首屏加载时间，提高用户体验。</li>
<li><strong>性能优化：</strong> 对于一些内容静态的页面或者对用户请求较为频繁的页面，SSR 可以减轻客户端的渲染负担，提高页面性能。</li>
<li><strong>社交分享等预览信息：</strong> 一些社交分享平台，如 Facebook、Twitter，能够获取服务器端生成的 HTML 中的预览信息，从而提供更好的社交分享效果</li>
</ol>
<h1 id="vue-router的两种模式，原理"><a href="#vue-router的两种模式，原理" class="headerlink" title="vue-router的两种模式，原理"></a>vue-router的两种模式，原理</h1><p>Vue Router 提供了两种路由模式：哈希模式（Hash mode）和历史模式（History mode）。</p>
<ol>
<li><p><strong>哈希模式（Hash mode）：</strong></p>
<ul>
<li><p><strong>原理：</strong> 在浏览器 URL 中的 <code>#</code> 符号后面的部分被称为哈希（hash），<strong>哈希模式通过监听浏览器的 <code>hashchange</code> 事件来实现路由切换</strong>。例如，<code>http://example.com/#/path</code>。</p>
</li>
<li><p><strong>优点：</strong> 不需要服务器配置，适用于单页应用。<strong>哈希部分的改变不会导致浏览器向服务器发起请求</strong>，可以避免一些问题，比如在没有配置服务器支持时刷新页面不会导致404错误。</p>
</li>
<li><p><strong>缺点：</strong> 带有 <code>#</code> 符号，看起来不够友好；对于一些搜索引擎爬虫，哈希部分不会被发送到服务器，可能<strong>对 SEO 不够友好</strong>。</p>
</li>
<li><p><strong>配置：</strong> 在创建 <code>VueRouter</code> 实例时，通过 <code>mode: &#39;hash&#39;</code> 来启用哈希模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst router = new VueRouter(&#123;</span><br><span class="line">  mode: &#x27;hash&#x27;,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>历史模式（History mode）：</strong></p>
<ul>
<li><p><strong>原理：</strong> 利用 HTML5 History API 中的 <code>pushState</code> 和 <code>replaceState</code> 方法，History 模式实现了无需 <code>#</code> 符号的路由。例如，<code>http://example.com/path</code>。</p>
</li>
<li><p><strong>优点：</strong> URL 看起来更加干净，去除了 <code>#</code> 符号；对于一些搜索引擎爬虫更友好。</p>
</li>
<li><p><strong>缺点：</strong> 需要服务器配置，确保在除基本路由之外的所有路由返回同一个 HTML 文件；刷新页面或直接访问某个路由时，会向服务器发送请求，需要服务器支持。</p>
</li>
<li><p><strong>配置：</strong> 在创建 <code>VueRouter</code> 实例时，通过 <code>mode: &#39;history&#39;</code> 来启用历史模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst router = new VueRouter(&#123;</span><br><span class="line">  mode: &#x27;history&#x27;,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="vuex在刷新页面的时候-会清除保存的数据嘛-为什么"><a href="#vuex在刷新页面的时候-会清除保存的数据嘛-为什么" class="headerlink" title="vuex在刷新页面的时候 会清除保存的数据嘛 为什么"></a>vuex在刷新页面的时候 会清除保存的数据嘛 为什么</h1><p>当你刷新页面时，Vuex保存的数据会被清除。这是因为 Vuex 的状态保存在内存中，当页面刷新时，应用会重新加载，Vuex 的状态也会被清除，并重新初始化状态。</p>
<p>这是JavaScript和 Vuex设计的固有特性</p>
<h1 id="nextick"><a href="#nextick" class="headerlink" title="nextick"></a><a class="link"   href="https://juejin.cn/post/7331591798332424201?searchId=2024041923495759324E6AAAAAB6B861AC" >nextick<i class="fas fa-external-link-alt"></i></a></h1><p><img   src="C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240419235355364.png"  alt="image-20240419235355364"></p>
<p>它允许你等待Vue完成DOM的更新，然后执行某些操作</p>
<p>当你在Vue组件中更改数据时，视图不会立即更新，而是异步更新。为了获得更新后的DOM状态，在更新数据之后立即查询DOM可能是不准确的。<code>nextTick</code>就是用来解决这个问题的。</p>
<h1 id="v-if-v-show"><a href="#v-if-v-show" class="headerlink" title="v-if&amp;v-show"></a>v-if&amp;v-show</h1><h2 id="使用v-show替代v-if"><a href="#使用v-show替代v-if" class="headerlink" title="使用v-show替代v-if"></a>使用v-show替代v-if</h2><p>对于频繁切换显示状态的元素，使用v-show可以保证虚拟dom树的稳定，避免频繁的新增和删除元素，特别是对于那些内部包含大量dom元素的节点，这一点极其重要</p>
<p>关键字：频繁切换显示状态、内部包含大量dom元素</p>
<h1 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h1><p>当使用Element UI框架进行组件封装时，经常需要考虑到底层组件的属性或插槽可能会发生变化的情况。要在不改变已封装组件的基础上实现兼容性，可以考虑以下几种方法：</p>
<ol>
<li><p><strong>属性透传（Prop Forwarding）</strong>：</p>
<p>利用<code>v-bind</code>的对象语法或使用<code>$attrs</code>对象将接收到的所有属性传递给子组件。这种方法确保了任何额外的属性都能传递给底层组件，即使这些属性在封装组件时没有明确声明。</p>
</li>
</ol>
<p>​	v-bind&#x3D;”$attrs”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-button v-bind=&quot;$attrs&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/el-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<ol>
<li><strong>插槽透传（Slot Forwarding）</strong>：<br>使用<code>&lt;slot&gt;</code>元素可以将内容分发至底层组件的对应插槽。使用 <code>&lt;template&gt;</code> 标签和 <code>v-slot</code> 指令可以将封装组件接收的插槽内容透传到底层组件。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-dialog&gt;</span><br><span class="line">    &lt;!-- 默认插槽内容 --&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;!-- 具名插槽内容 --&gt;</span><br><span class="line">    &lt;template v-slot:footer&gt;</span><br><span class="line">      &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/el-dialog&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<ol>
<li><strong>监听属性变化</strong>：<br>如果是预料到某些属性可能会发生变化，可以在封装组件中使用<code>watch</code>监听这些属性，然后做出相应的处理。</li>
<li><strong>文档和版本兼容性声明</strong>：<br>在封装组件的文档中明确声明组件兼容的Element UI版本，并及时更新兼容性信息。这样使用者就可以意识到可能存在的限制，并根据需要进行调整。</li>
<li><strong>封装扩展插槽（Scoped Slots）</strong>：<br>如果Element的组件更新了插槽，可以通过增加扩展插槽来兼容新的功能，同时保持向后兼容。</li>
<li><strong>保持更新</strong>：<br>关注Element UI框架的更新，特别是破坏性更新（breaking changes）。当框架更新时，及时检查封装的组件，并对必要的部分做适配和兼容性调整。</li>
<li><strong>使用事件发射（Event Emitting）</strong>：<br>在某些情况下，如果底层组件的事件发生了改变，通过在封装组件中监听这些事件并重新发射（emit）可以保证外部可以正常监听到。</li>
<li><strong>提供配置选项</strong>：<br>对于封装组件，可以提供一些配置选项，使得使用者在使用时能够调整这些配置以应对底层组件的变化。</li>
</ol>
<h1 id="vue中key的作用"><a href="#vue中key的作用" class="headerlink" title="vue中key的作用"></a>vue中key的作用</h1><p>key是给每一个vnode的唯一id，可以依靠key，更准确，更快的拿到oldVnode中对应的vnode节点 提高虚拟dom的更新 触发过渡效果</p>
<p>结论:   如果key没有发生变化，元素不会销毁重建</p>
<p>​			如果是组件，不会触发生命周期的勾子函数</p>
<h1 id="在生命周期的表现"><a href="#在生命周期的表现" class="headerlink" title="在生命周期的表现"></a>在生命周期的表现</h1><ol>
<li>beforeCreate: 可以拿到 props</li>
<li>created: 可以拿到 data, methods, watch, computed</li>
</ol>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>代码格式化</title>
    <url>/2024/12/06/2024/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="前端代码格式化全套配置"><a href="#前端代码格式化全套配置" class="headerlink" title="前端代码格式化全套配置"></a>前端代码格式化全套配置</h1><span id="more"></span>

<h1 id="prettier-快速配置"><a href="#prettier-快速配置" class="headerlink" title="prettier 快速配置"></a>prettier 快速配置</h1><ol>
<li>安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev --save-exact prettier</span><br><span class="line"></span><br><span class="line">// 运行</span><br><span class="line">npx prettier --write index.js</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .prettierrc</span></span><br><span class="line"></span><br><span class="line">echo <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span>&gt; .prettierrc.json</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;trailingComma&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tabWidth&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;semi&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;singleQuote&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="eslint-快速配置"><a href="#eslint-快速配置" class="headerlink" title="eslint 快速配置"></a>eslint 快速配置</h1><ol>
<li>安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 安装一整套</span><br><span class="line">npm i eslint eslint-config-prettier eslint-plugin-prettier eslint-plugin-vue prettier typescript-eslint -D</span><br><span class="line"></span><br><span class="line">// 安装依赖并创建eslint.config.js 文件</span><br><span class="line">npm init @eslint/config@latest</span><br><span class="line"></span><br><span class="line">// 运行</span><br><span class="line">eslint 文件路径 --fix</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">es2021</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;standard&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;airbnb&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:vue/vue3-recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:prettier/recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;prettier&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="number">13</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;vue&#x27;</span>],</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;import/no-unresolved&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;import/no-extraneous-dependencies&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="冲突解决："><a href="#冲突解决：" class="headerlink" title="冲突解决："></a>冲突解决：</h2><p>安装解决冲突的依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//1. 安装 eslint-config-prettier</span><br><span class="line">npm i -D eslint-config-prettier</span><br><span class="line"></span><br><span class="line">//2. 在eslint的配置文件中写入以下内容</span><br><span class="line"> extends: [&#x27;prettier&#x27;], // 避免与 prettier 冲突</span><br><span class="line"></span><br><span class="line">//&quot;extends&quot;: [&quot;plugin:prettier/recommended&quot;]也可以解决冲突</span><br></pre></td></tr></table></figure>

<h2 id="eslint-文件配置文档"><a href="#eslint-文件配置文档" class="headerlink" title="eslint 文件配置文档"></a><a class="link"   href="https://eslint.org/docs/v8.x/use/configure/" >eslint 文件配置文档<i class="fas fa-external-link-alt"></i></a></h2><ol start="4">
<li><h3 id="其他依赖安装说明"><a href="#其他依赖安装说明" class="headerlink" title="其他依赖安装说明"></a>其他依赖安装说明</h3></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//由于ESlint本身只支持识别JavaScript，所以对于vue文件，还需要一个插件：eslint-plugin-vue，假如你的项目也跟我一样用的是typescript，那么还需要另一个解析器：typescript-eslint</span><br><span class="line"></span><br><span class="line">npm add eslint-plugin-vue typescript-eslint -D</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	extends: [&#x27;plugin:vue/vue3-recommended&#x27;,]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  extends: [&#x27;eslint:recommended&#x27;, &#x27;plugin:@typescript-eslint/recommended&#x27;],</span><br><span class="line">  parser: &#x27;@typescript-eslint/parser&#x27;,</span><br><span class="line">  plugins: [&#x27;@typescript-eslint&#x27;],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a class="link"   href="https://eslint.vuejs.org/user-guide/" >eslint-plugin-vue 配置文档<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="如何使用自定义解析器？"><a href="#如何使用自定义解析器？" class="headerlink" title="如何使用自定义解析器？"></a>如何使用自定义解析器？</h3><p>如果您想使用自定义解析器，例如<a class="link"   href="https://www.npmjs.com/package/@babel/eslint-parser" >@babel&#x2F;eslint-parser<i class="fas fa-external-link-alt"></i></a>或<a class="link"   href="https://www.npmjs.com/package/@typescript-eslint/parser" >@typescript-eslint&#x2F;parser<i class="fas fa-external-link-alt"></i></a> ，则必须使用<code>parserOptions.parser</code>选项而不是<code>parser</code>选项。因为这个插件需要<a class="link"   href="https://www.npmjs.com/package/vue-eslint-parser" >vue-eslint-parser<i class="fas fa-external-link-alt"></i></a>来解析<code>.vue</code>文件，所以如果你覆盖<code>parser</code>选项，这个插件将不起作用。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,</span></span><br><span class="line"><span class="addition">+ &quot;parser&quot;: &quot;vue-eslint-parser&quot;,</span></span><br><span class="line">  &quot;parserOptions&quot;: &#123;</span><br><span class="line"><span class="addition">+     &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,</span></span><br><span class="line">      &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h5 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h5><p>配置 eslint-config-prettier,就需要 extends: “prettier”, 才能真的使用到</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;prettier&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>而 plugin:prettier&#x2F;recommended 是插件附带的，主要是启用一些与 Prettier 相关的 ESLint 规则，在 eslint-plugin-prettier 的 readme 中有这个配置，例如，它可能会设置一些规则，使得当代码的引号使用、缩进等不符合 Prettier 的要求时，ESLint 会产生警告或者错误</p>
<p>而<code>eslint - config - prettier</code>的重点是关闭 ESLint 中与 Prettier 相冲突的规则。当它被应用时，它会查找那些可能与 Prettier 规则冲突的 ESLint 规则，并将它们设置为<code>off</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;plugin:prettier/recommended&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>eslint-config-prettier 主要作用是关闭 ESLint 中与 Prettier 相冲突的规则</p>
<p>eslint-plugin-prettier 是一个将 Prettier 作为 ESLint 规则来运行的插件。它允许 ESLint 使用 Prettier 的格式化规则来检查代码的格式问题</p>
<p>使用<code>eslint-plugin-prettier</code>这个插件, 让 eslint 可以使用 prettier</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i eslint-plugin-prettier -D</span><br></pre></td></tr></table></figure>

<p>在<code>.eslintrc.json</code>加入<code>perttier</code>插件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>...<span class="punctuation">,</span> <span class="string">&quot;prettier&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 注册插件</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;prettier/perttier&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span><span class="punctuation">,</span> <span class="comment">// 加入prettier规则</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>而<code>plugin:prettier/recommended</code>帮我们做了如下事情：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;prettier&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 使用eslinst-config-prettier中的配置项</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;prettier&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 注册该prettier插件</span></span><br><span class="line">  <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prettier/prettier&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span><span class="punctuation">,</span> <span class="comment">// 在eslint中运行prettier，并启用该插件提供的规则</span></span><br><span class="line">    <span class="attr">&quot;arrow-body-style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span> <span class="comment">// 关闭规则</span></span><br><span class="line">    <span class="attr">&quot;prefer-arrow-callback&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span> <span class="comment">// 关闭规则</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="husky-配置-前提是先执行-git-init"><a href="#husky-配置-前提是先执行-git-init" class="headerlink" title="husky 配置(前提是先执行 git init)"></a>husky 配置(前提是先执行 git init)</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev husky</span><br><span class="line"></span><br><span class="line">npx husky init</span><br><span class="line"></span><br><span class="line">// 配置 lint-staged</span><br><span class="line">echo &#x27;npm run lint-staged&#x27; &gt; .husky/pre-commit</span><br><span class="line"></span><br><span class="line">// 配置commitlint</span><br><span class="line">echo &quot;npx --no -- commitlint --edit \$1&quot; &gt; .husky/commit-msg</span><br><span class="line"></span><br><span class="line">// 在 package.json 中添加</span><br><span class="line">&quot;husky&quot;: &#123;</span><br><span class="line">  &quot;hooks&quot;: &#123;</span><br><span class="line">    &quot;pre-commit&quot;: &quot;lint-staged&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h1><p><code>lint - staged</code>是一个在 Git 暂存区（staged area）文件上运行 linters（代码检查工具）的工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i lint-staged -D</span><br><span class="line"></span><br><span class="line">&quot;lint-staged&quot;: &#123;</span><br><span class="line">  &quot;*.&#123;js,ts,jsx,tsx&#125;&quot;: [</span><br><span class="line">    &quot;npx prettier --write .&quot;,</span><br><span class="line">    &quot;npx eslint --fix&quot;,</span><br><span class="line">    &quot;git add .&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="commitlint"><a href="#commitlint" class="headerlink" title="commitlint"></a>commitlint</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. commitlint</span><br><span class="line">npm install -D @commitlint/&#123;cli,config-conventional&#125;</span><br><span class="line">echo &quot;export default &#123; extends: [&#x27;@commitlint/config-conventional&#x27;] &#125;;&quot; &gt; .commitlintrc.js</span><br><span class="line">// 配置commitlint</span><br><span class="line">echo &quot;npx --no -- commitlint --edit \$1&quot; &gt; .husky/commit-msg</span><br><span class="line"></span><br><span class="line">2. changelog</span><br><span class="line">//配置 changelog 文件</span><br><span class="line">npm install -g conventional-changelog-cli</span><br><span class="line">//不覆盖</span><br><span class="line">conventional-changelog -p angular -i CHANGELOG.md -s</span><br><span class="line">//覆盖之前的记录</span><br><span class="line">conventional-changelog -p angular -i CHANGELOG.md -s -r 0</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s &amp;&amp; git add CHANGELOG.md&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="commitizen"><a href="#commitizen" class="headerlink" title="commitizen"></a>commitizen</h1><p>作用就是能够直接写好规范的 commit 信息，跟 webstorm 插件一样(Git Commit Message Helper)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i commitizen cz-conventional-changelog -D</span><br><span class="line"></span><br><span class="line">npm set-script commit &quot;git-cz&quot;</span><br><span class="line"></span><br><span class="line">npx commitizen init cz-conventional-changelog --save-dev --save-exact</span><br><span class="line"></span><br><span class="line">//配置package.json 默认会加好</span><br><span class="line">&quot;config&quot;: &#123;</span><br><span class="line">  &quot;commitizen&quot;: &#123;</span><br><span class="line">    &quot;path&quot;: &quot;./node_modules/cz-customizable&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完结撒花🌸</p>
<p>引用：</p>
<ol>
<li><a class="link"   href="https://juejin.cn/post/6990929456382607374" >https://juejin.cn/post/6990929456382607374<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/6938687606687432740" >https://juejin.cn/post/6938687606687432740<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://github.com/prettier/eslint-plugin-prettier?tab=readme-ov-file" >https://github.com/prettier/eslint-plugin-prettier?tab=readme-ov-file<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7143800548704124935" >https://juejin.cn/post/7143800548704124935<i class="fas fa-external-link-alt"></i></a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>手撕题</title>
    <url>/2025/01/05/2024/%E6%89%8B%E6%92%95%E9%A2%98/</url>
    <content><![CDATA[<p>柯里化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> argsList = [...args];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.<span class="property">length</span>) &#123;</span><br><span class="line">            argsList = [...argsList, ...args];</span><br><span class="line">            <span class="keyword">return</span> fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> argsList.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curry</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)());</span><br></pre></td></tr></table></figure>

<p>hardMAn</p>
<p><a class="link"   href="https://mp.weixin.qq.com/s/-hEjxY0yI6ZBTzAlc3xwAw" >https://mp.weixin.qq.com/s/-hEjxY0yI6ZBTzAlc3xwAw<i class="fas fa-external-link-alt"></i></a></p>
<p>lru  o(1)不使用 map,set</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义双向链表节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">key = <span class="number">0</span>, value = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 LRU 缓存类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">        <span class="comment">// 缓存容量</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity;</span><br><span class="line">        <span class="comment">// 当前缓存中的元素数量</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 哈希表，用于快速查找节点</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span> = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 双向链表的虚拟头节点</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        <span class="comment">// 双向链表的虚拟尾节点</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        <span class="comment">// 初始化双向链表</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取缓存中的元素</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">cache</span>[key]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在，将该节点移动到链表头部</span></span><br><span class="line">        <span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="property">cache</span>[key];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入或更新缓存中的元素</span></span><br><span class="line">    <span class="title function_">put</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>[key]) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 已经存在，更新节点的值，并将其移动到链表头部</span></span><br><span class="line">            <span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="property">cache</span>[key];</span><br><span class="line">            node.<span class="property">value</span> = value;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">moveToHead</span>(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建新节点</span></span><br><span class="line">            <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cache</span>[key] = node;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">addToHead</span>(node);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">size</span> &gt; <span class="variable language_">this</span>.<span class="property">capacity</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果缓存已满，删除链表尾部的节点</span></span><br><span class="line">                <span class="keyword">const</span> removed = <span class="variable language_">this</span>.<span class="title function_">removeTail</span>();</span><br><span class="line">                <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">cache</span>[removed.<span class="property">key</span>];</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将节点添加到链表头部</span></span><br><span class="line">    <span class="title function_">addToHead</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        node.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">        node.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>.<span class="property">prev</span> = node;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span> = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="title function_">removeNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        node.<span class="property">prev</span>.<span class="property">next</span> = node.<span class="property">next</span>;</span><br><span class="line">        node.<span class="property">next</span>.<span class="property">prev</span> = node.<span class="property">prev</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将节点移动到链表头部</span></span><br><span class="line">    <span class="title function_">moveToHead</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(node);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">addToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表尾部的节点</span></span><br><span class="line">    <span class="title function_">removeTail</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用 map</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">LRUCache</span> = <span class="keyword">function</span> (<span class="params">capacity</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = capacity;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">LRUCache</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">        tmp = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp ?? -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">LRUCache</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">put</span> = <span class="keyword">function</span> (<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="property">size</span> &gt; <span class="variable language_">this</span>.<span class="property">limit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>浏览器渲染原理</title>
    <url>/2024/11/09/2024/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h3><span id="more"></span>

<p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p>
<p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p>
<p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p>
<p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p>
<p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p>
<p>#解析 HTML<br>解析过程中遇到 CSS</p>
<p><img   src="/../images/chrome/image-20230901145948801.png" ></p>
<p>遇到 JS</p>
<p><img   src="/../images/chrome/image-20230901150037013.png" ></p>
<p>为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p>
<p>如果主线程解析到link位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p>
<p>如果主线程解析到script位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p>
<p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p>
<p><img   src="/../images/chrome/image-20230901150218827.png" ></p>
<p>#样式计算<br>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p>
<p>在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)；相对单位会变成绝对单位，比如em会变成px</p>
<p>这一步完成后，会得到一棵带有样式的 DOM 树。</p>
<p><img   src="/../images/chrome/image-20230901150449029.png" ></p>
<p>#布局<br>布局完成后会得到布局树</p>
<p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p>
<p>大部分时候，DOM 树和布局树并非一一对应。</p>
<p>比如display:none的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p>
<p><img   src="/../images/chrome/image-20230901150532770.png" ></p>
<p>#分层<br>主线程会使用一套复杂的策略对整个布局树中进行分层。</p>
<p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p>
<p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过will-change属性更大程度的影响分层结果。</p>
<p><img   src="/../images/chrome/image-20230901150548654.png" ></p>
<p>#绘制<br>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p>
<p><img   src="/../images/chrome/image-20230901150600166.png" ></p>
<p>渲染主线程的⼯作到此为⽌，剩余步骤交给其他线程完成</p>
<p><img   src="/../images/chrome/image-20230901150633287.png" ></p>
<p>#分块<br>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p>
<p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p>
<p>它会从线程池中拿取多个线程来完成分块工作。</p>
<p><img   src="/../images/chrome/image-20230901150650578.png" ></p>
<p><img   src="/../images/chrome/image-20230901150726296.png" ></p>
<p>#光栅化<br>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p>
<p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p>
<p>光栅化的结果，就是一块一块的位图</p>
<p><img   src="/../images/chrome/image-20230901150831893.png" ></p>
<p>#最后一个阶段 画<br>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p>
<p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p>
<p>变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因。</p>
<p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p>
<p><img   src="/../images/chrome/image-20230901150927920.png" ></p>
<p>#什么是 reflow？<br>reflow 的本质就是重新计算 layout 树。</p>
<p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p>
<p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p>
<p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p>
<p>浏览器在反复权衡下，最终决定在调用某些属性时立即 reflow。</p>
<p>会引起reflow的属性：</p>
<p>Offset相关属性offsetWidth、offsetHeight、offsetTop、offsetLeft 等<br>client相关属性 clientWidth、clientHeight等<br>Scroll相关属性：例如 scrollWidth、scrollHeight、scrollTop、scrollLeft 等<br>getComputedStyle() 方法：当使用 getComputedStyle() 方法获取计算后的样式（computed style）时<br>#什么是 repaint？<br>repaint 的本质就是重新根据分层信息计算了绘制指令。</p>
<p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p>
<p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p>
<p>#为什么 transform 的效率高？<br>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p>
<p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>
<p><img   src="/../images/chrome/image-20230901151924571.png" ></p>
]]></content>
      <tags>
        <tag>浏览器</tag>
        <tag>渲染原理</tag>
      </tags>
  </entry>
  <entry>
    <title>docker_nginx</title>
    <url>/2025/03/02/2025/docker-nginx/</url>
    <content><![CDATA[<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p>总结： 前端项目打包后直接将静态资源放到nginx服务器上，最重要的还是对配置文件熟练</p>
<ol>
<li>&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 存放静态资源目录</li>
<li>&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf 配置文件路径</li>
</ol>
<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>总结：使用 dockerfile 构建镜像，然后启动容器</p>
<ol>
<li>制作镜像（需要对常用的几个 dockerfile 命令熟悉，比如 from,run,args,copy,add,expose,cmd），就是基于一个基础镜像，然后把打包好的产物放到指定目录下<ol>
<li>中间还可以挂载 volumes</li>
<li>设置参数</li>
</ol>
</li>
<li>运行命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t 自定义镜像名 dockerfile路径</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用镜像运行一个容器</li>
</ol>
]]></content>
  </entry>
</search>
