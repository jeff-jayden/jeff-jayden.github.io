---
title: vue学习记录
tags:
   - Vue
---



# vue的优势

1. 轻量级框架：Vue.js 是一个轻量级的框架，文件大小小，易于上手和学习
1. 简单易学：Vue.js 的语法简单直观，易于理解和掌握
1. 双向数据绑定：Vue.js 支持双向数据绑定，使得数据的变化能够自动反映在视图上，同时视图的变化也能自动更新到数据层
1. 组件化：Vue.js 支持组件化开发，能够将页面拆分成多个独立的、可复用的组件，便于开发和维护
1. 数据和结构的分离：Vue.js 支持将数据和结构分离，使得前端开发更加清晰和高效
1. 虚拟DOM：Vue.js 使用虚拟DOM 技术，能够最大限度地减少对实际DOM的操作，提高性能



# Vuex

Vuex是一个专为Vue.js应用程序开发的状态管理模式+库，用于集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. 它解决了多个组件共享状态时可能遇到的问题，如多个视图依赖于同一状态、来自不同视图的行为需要变更同一状态等 在大型项目中，Vuex能够高效实现组件之间的数据共享，提高开发效率，且存储在Vuex中的数据都是响应式的，能够实时保持数据与页面的同步 因此，Vuex的作用是实现组件全局状态（数据）管理的一种机制，方便实现组件之间数据的共享，解决了组件之间统一状态的共享问题，实现组件之间的数据持久化



# ssr

SSR（Server-Side Rendering）是一种前端渲染技术，它在服务器端生成页面的 HTML，并将其发送给客户端进行显示。相对于传统的客户端渲染（CSR，Client-Side Rendering），SSR 提供了一些优势和改进：

1. **SEO（搜索引擎优化）：** 由于搜索引擎爬虫更容易处理服务器端生成的 HTML，SSR 有助于提高页面的搜索引擎排名，而不是依赖于客户端执行 JavaScript。
2. **首屏加载性能：** SSR 可以在页面加载时直接提供完整的 HTML，无需等待客户端渲染完成。这有助于减少首屏加载时间，提高用户体验。
3. **性能优化：** 对于一些内容静态的页面或者对用户请求较为频繁的页面，SSR 可以减轻客户端的渲染负担，提高页面性能。
4. **社交分享等预览信息：** 一些社交分享平台，如 Facebook、Twitter，能够获取服务器端生成的 HTML 中的预览信息，从而提供更好的社交分享效果



# vue-router的两种模式，原理

Vue Router 提供了两种路由模式：哈希模式（Hash mode）和历史模式（History mode）。

1. **哈希模式（Hash mode）：**

   - **原理：** 在浏览器 URL 中的 `#` 符号后面的部分被称为哈希（hash），**哈希模式通过监听浏览器的 `hashchange` 事件来实现路由切换**。例如，`http://example.com/#/path`。

   - **优点：** 不需要服务器配置，适用于单页应用。**哈希部分的改变不会导致浏览器向服务器发起请求**，可以避免一些问题，比如在没有配置服务器支持时刷新页面不会导致404错误。

   - **缺点：** 带有 `#` 符号，看起来不够友好；对于一些搜索引擎爬虫，哈希部分不会被发送到服务器，可能**对 SEO 不够友好**。

   - **配置：** 在创建 `VueRouter` 实例时，通过 `mode: 'hash'` 来启用哈希模式。

     ```
     javascriptCopy codeconst router = new VueRouter({
       mode: 'hash',
       routes: [...]
     });
     ```

2. **历史模式（History mode）：**

   - **原理：** 利用 HTML5 History API 中的 `pushState` 和 `replaceState` 方法，History 模式实现了无需 `#` 符号的路由。例如，`http://example.com/path`。

   - **优点：** URL 看起来更加干净，去除了 `#` 符号；对于一些搜索引擎爬虫更友好。

   - **缺点：** 需要服务器配置，确保在除基本路由之外的所有路由返回同一个 HTML 文件；刷新页面或直接访问某个路由时，会向服务器发送请求，需要服务器支持。

   - **配置：** 在创建 `VueRouter` 实例时，通过 `mode: 'history'` 来启用历史模式。

     ```
     javascriptCopy codeconst router = new VueRouter({
       mode: 'history',
       routes: [...]
     });
     ```

# vuex在刷新页面的时候 会清除保存的数据嘛 为什么

当你刷新页面时，Vuex保存的数据会被清除。这是因为 Vuex 的状态保存在内存中，当页面刷新时，应用会重新加载，Vuex 的状态也会被清除，并重新初始化状态。

这是JavaScript和 Vuex设计的固有特性





# [nextick](https://juejin.cn/post/7331591798332424201?searchId=2024041923495759324E6AAAAAB6B861AC)

![image-20240419235355364](C:\Users\20457\AppData\Roaming\Typora\typora-user-images\image-20240419235355364.png)

它允许你等待Vue完成DOM的更新，然后执行某些操作

当你在Vue组件中更改数据时，视图不会立即更新，而是异步更新。为了获得更新后的DOM状态，在更新数据之后立即查询DOM可能是不准确的。`nextTick`就是用来解决这个问题的。



# v-if&v-show

## 使用v-show替代v-if

对于频繁切换显示状态的元素，使用v-show可以保证虚拟dom树的稳定，避免频繁的新增和删除元素，特别是对于那些内部包含大量dom元素的节点，这一点极其重要

关键字：频繁切换显示状态、内部包含大量dom元素



# 组件封装

当使用Element UI框架进行组件封装时，经常需要考虑到底层组件的属性或插槽可能会发生变化的情况。要在不改变已封装组件的基础上实现兼容性，可以考虑以下几种方法：



1. **属性透传（Prop Forwarding）**：

   利用`v-bind`的对象语法或使用`$attrs`对象将接收到的所有属性传递给子组件。这种方法确保了任何额外的属性都能传递给底层组件，即使这些属性在封装组件时没有明确声明。

​	v-bind="$attrs"

```vue
   <template>
     <el-button v-bind="$attrs">{{ content }}</el-button>
   </template>
```



1. **插槽透传（Slot Forwarding）**：
   使用`<slot>`元素可以将内容分发至底层组件的对应插槽。使用 `<template>` 标签和 `v-slot` 指令可以将封装组件接收的插槽内容透传到底层组件。



```vue
   <template>
     <el-dialog>
       <!-- 默认插槽内容 -->
       <slot></slot>
       <!-- 具名插槽内容 -->
       <template v-slot:footer>
         <slot name="footer"></slot>
       </template>
     </el-dialog>
   </template>
```



1. **监听属性变化**：
   如果是预料到某些属性可能会发生变化，可以在封装组件中使用`watch`监听这些属性，然后做出相应的处理。
2. **文档和版本兼容性声明**：
   在封装组件的文档中明确声明组件兼容的Element UI版本，并及时更新兼容性信息。这样使用者就可以意识到可能存在的限制，并根据需要进行调整。
3. **封装扩展插槽（Scoped Slots）**：
   如果Element的组件更新了插槽，可以通过增加扩展插槽来兼容新的功能，同时保持向后兼容。
4. **保持更新**：
   关注Element UI框架的更新，特别是破坏性更新（breaking changes）。当框架更新时，及时检查封装的组件，并对必要的部分做适配和兼容性调整。
5. **使用事件发射（Event Emitting）**：
   在某些情况下，如果底层组件的事件发生了改变，通过在封装组件中监听这些事件并重新发射（emit）可以保证外部可以正常监听到。
6. **提供配置选项**：
   对于封装组件，可以提供一些配置选项，使得使用者在使用时能够调整这些配置以应对底层组件的变化。



# vue中key的作用

key是给每一个vnode的唯一id，可以依靠key，更准确，更快的拿到oldVnode中对应的vnode节点 提高虚拟dom的更新 触发过渡效果

结论:   如果key没有发生变化，元素不会销毁重建

​			如果是组件，不会触发生命周期的勾子函数